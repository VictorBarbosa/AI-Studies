(self.webpackChunkapp=self.webpackChunkapp||[]).push([[3991],{4399:function(J,Y,f){var j=f(7820).default;!function(x,B,I){"use strict";const K={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class G{constructor(g,E){this.modelPath=E||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(g)}/model.json`}getPrefix(g){return"lite_mobilenet_v2"===g?`ssd${g}`:`ssd_${g}`}load(){var g=this;return j(function*(){g.model=yield B.loadGraphModel(g.modelPath);const E=I.zeros([1,300,300,3],"int32"),A=yield g.model.executeAsync(E);yield Promise.all(A.map(C=>C.data())),A.map(C=>C.dispose()),E.dispose()})()}infer(g,E,A){var C=this;return j(function*(){const z=I.tidy(()=>(g instanceof I.Tensor||(g=I.browser.fromPixels(g)),I.expandDims(g))),V=z.shape[1],$=z.shape[2],T=yield C.model.executeAsync(z),v=T[0].dataSync(),S=T[1].dataSync();z.dispose(),I.dispose(T);const[D,U]=C.calculateMaxScores(v,T[0].shape[1],T[0].shape[2]),y=I.getBackend();"webgl"===I.getBackend()&&I.setBackend("cpu");const R=I.tidy(()=>{const o=I.tensor2d(S,[T[1].shape[1],T[1].shape[3]]);return I.image.nonMaxSuppression(o,D,E,A,A)}),w=R.dataSync();return R.dispose(),y!==I.getBackend()&&I.setBackend(y),C.buildDetectedObjects($,V,S,D,w,U)})()}buildDetectedObjects(g,E,A,C,z,V){const $=z.length,T=[];for(let v=0;v<$;v++){const S=[];for(let w=0;w<4;w++)S[w]=A[4*z[v]+w];const D=S[0]*E,U=S[1]*g,y=S[2]*E,R=S[3]*g;S[0]=U,S[1]=D,S[2]=R-U,S[3]=y-D,T.push({bbox:S,class:K[V[z[v]]+1].displayName,score:C[z[v]]})}return T}calculateMaxScores(g,E,A){const C=[],z=[];for(let V=0;V<E;V++){let $=Number.MIN_VALUE,T=-1;for(let v=0;v<A;v++)g[V*A+v]>$&&($=g[V*A+v],T=v);C[V]=$,z[V]=T}return[C,z]}detect(g,E=20,A=.5){var C=this;return j(function*(){return C.infer(g,E,A)})()}dispose(){null!=this.model&&this.model.dispose()}}x.ObjectDetection=G,x.load=j(function*(H={}){if(null==I)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const g=H.base||"lite_mobilenet_v2",E=H.modelUrl;if(-1===["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(g))throw new Error(`ObjectDetection constructed with invalid base model ${g}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const A=new G(g,E);return yield A.load(),A}),x.version="2.2.2",Object.defineProperty(x,"__esModule",{value:!0})}(Y,f(3438),f(7575))},3438:(J,Y,f)=>{"use strict";f.r(Y),f.d(Y,{GraphModel:()=>Oe,deregisterOp:()=>Re,loadGraphModel:()=>Bt,loadGraphModelSync:()=>Gt,registerOp:()=>xe,version_converter:()=>Ut});var j={};f.r(j),f.d(j,{json:()=>$e});var x={};f.r(x),f.d(x,{json:()=>je});var B={};f.r(B),f.d(B,{json:()=>Be});var I={};f.r(I),f.d(I,{json:()=>Ge});var K={};f.r(K),f.d(K,{json:()=>He});var G={};f.r(G),f.d(G,{json:()=>Ue});var H={};f.r(H),f.d(H,{json:()=>We});var g={};f.r(g),f.d(g,{json:()=>Ke});var E={};f.r(E),f.d(E,{json:()=>Qe});var A={};f.r(A),f.d(A,{json:()=>Ye});var C={};f.r(C),f.d(C,{json:()=>Ze});var z={};f.r(z),f.d(z,{json:()=>qe});var V={};f.r(V),f.d(V,{json:()=>Xe});var $={};f.r($),f.d($,{json:()=>Je});var T={};f.r(T),f.d(T,{json:()=>Me});var v={};f.r(v),f.d(v,{json:()=>et});var S={};f.r(S),f.d(S,{json:()=>tt});var D={};f.r(D),f.d(D,{json:()=>at});var U={};f.r(U),f.d(U,{json:()=>st});var y=f(7575);(0,y.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var we,w=f(8239),o=(()=>((o=o||{})[o.DT_INVALID=0]="DT_INVALID",o[o.DT_FLOAT=1]="DT_FLOAT",o[o.DT_DOUBLE=2]="DT_DOUBLE",o[o.DT_INT32=3]="DT_INT32",o[o.DT_UINT8=4]="DT_UINT8",o[o.DT_INT16=5]="DT_INT16",o[o.DT_INT8=6]="DT_INT8",o[o.DT_STRING=7]="DT_STRING",o[o.DT_COMPLEX64=8]="DT_COMPLEX64",o[o.DT_INT64=9]="DT_INT64",o[o.DT_BOOL=10]="DT_BOOL",o[o.DT_QINT8=11]="DT_QINT8",o[o.DT_QUINT8=12]="DT_QUINT8",o[o.DT_QINT32=13]="DT_QINT32",o[o.DT_BFLOAT16=14]="DT_BFLOAT16",o[o.DT_QINT16=15]="DT_QINT16",o[o.DT_QUINT16=16]="DT_QUINT16",o[o.DT_UINT16=17]="DT_UINT16",o[o.DT_COMPLEX128=18]="DT_COMPLEX128",o[o.DT_HALF=19]="DT_HALF",o[o.DT_RESOURCE=20]="DT_RESOURCE",o[o.DT_VARIANT=21]="DT_VARIANT",o[o.DT_UINT32=22]="DT_UINT32",o[o.DT_UINT64=23]="DT_UINT64",o[o.DT_FLOAT_REF=101]="DT_FLOAT_REF",o[o.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",o[o.DT_INT32_REF=103]="DT_INT32_REF",o[o.DT_UINT8_REF=104]="DT_UINT8_REF",o[o.DT_INT16_REF=105]="DT_INT16_REF",o[o.DT_INT8_REF=106]="DT_INT8_REF",o[o.DT_STRING_REF=107]="DT_STRING_REF",o[o.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",o[o.DT_INT64_REF=109]="DT_INT64_REF",o[o.DT_BOOL_REF=110]="DT_BOOL_REF",o[o.DT_QINT8_REF=111]="DT_QINT8_REF",o[o.DT_QUINT8_REF=112]="DT_QUINT8_REF",o[o.DT_QINT32_REF=113]="DT_QINT32_REF",o[o.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",o[o.DT_QINT16_REF=115]="DT_QINT16_REF",o[o.DT_QUINT16_REF=116]="DT_QUINT16_REF",o[o.DT_UINT16_REF=117]="DT_UINT16_REF",o[o.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",o[o.DT_HALF_REF=119]="DT_HALF_REF",o[o.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",o[o.DT_VARIANT_REF=121]="DT_VARIANT_REF",o[o.DT_UINT32_REF=122]="DT_UINT32_REF",o[o.DT_UINT64_REF=123]="DT_UINT64_REF",o))();!function(s){let e;var t;(t=e=s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(we||(we={}));const pe={};function xe(s,e){pe[s]={tfOpName:s,category:"custom",inputs:[],attrs:[],customExecutor:e}}function Ee(s){return pe[s]}function Re(s){delete pe[s]}function r(s,e,t,a,i){const n=e.inputParams[s];if(n&&void 0!==n.inputIndexStart){const m=n.inputIndexStart,u=0===n.inputIndexEnd?void 0:void 0===n.inputIndexEnd?m+1:n.inputIndexEnd;if("tensor"===n.type)return P(e.inputNames[n.inputIndexStart],t,a,i);if("tensors"===n.type)return e.inputNames.slice(m,u).map(h=>P(h,t,a,i));const d=P(e.inputNames.slice(m)[0],t,a,i),l=d.dataSync();return"number"===n.type?l[0]:y.util.toNestedArray(d.shape,l)}const p=e.attrParams[s];return p&&p.value}function P(s,e,t,a){const[i,n]=W(s);if(null!=a){const m=a.getHashTableHandleByName(i);if(null!=m)return m}const p=t.currentContextIds.find(m=>!!e[se(i,m)]);return void 0!==p?e[se(i,p)][n]:void 0}function Z(s,e){const[t,a,i]=W(s);return[se(t,e&&e.currentContextId),a,i]}function se(s,e){return e?`${s}-${e}`:s}function W(s){const e=s.split(":");if(1===e.length)return[s,0,void 0];const a=3===e.length?e[1]:void 0;return[e[0],Number(e[e.length-1]),a]}function re(s,e,t){let a=r("pad",s,e,t);if("explicit"===a){a=r("explicitPaddings",s,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let n=0;n<4;n++)i[n][0]=a[2*n],i[n][1]=a[2*n+1];return i}return a}function q(s){return s.kept?s:(0,y.clone)(s)}const $e=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],je=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Be=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Ge=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],He=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ue=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],We=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Ke=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Qe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Ye=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Ze=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],qe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Xe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],Je=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Me=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],et=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],tt=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],at=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],st=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class ve{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[j,x,B,I,K,G,H,g,E,A,C,z,V,$,T,v,S,D,U].map(a=>a.json));this.opMappers=t.reduce((a,i)=>(a[i.tfOpName]=i,a),{})}transformGraph(e,t={}){const i=[],n=[],p=[],m=e.node.reduce((N,b)=>(N[b.name]=this.mapNode(b),b.op.startsWith("Placeholder")?i.push(N[b.name]):"Const"===b.op?n.push(N[b.name]):(null==b.input||0===b.input.length)&&p.push(N[b.name]),N),{});let u=[];const d=[];let l={},c={};null!=t&&(l=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const h=Object.keys(m);h.forEach(N=>{const b=m[N];b.inputNames.forEach((L,X)=>{const[ee,,k]=Z(L),te=m[ee];if(null!=te.outputs){const ie=te.outputs.indexOf(k);-1!==ie&&(b.inputNames[X]=`${ee}:${ie}`)}b.inputs.push(te),te.children.push(b)})}),0===Object.keys(c).length?h.forEach(N=>{const b=m[N];0===b.children.length&&d.push(b)}):Object.keys(c).forEach(N=>{const[b]=Z(N),L=m[b];null!=L&&(L.signatureKey=c[N],d.push(L))}),Object.keys(l).length>0?Object.keys(l).forEach(N=>{const[b]=Z(N),L=m[b];L&&(L.signatureKey=l[N],u.push(L))}):u=i;let O={};null!=e.library&&null!=e.library.function&&(O=e.library.function.reduce((N,b)=>(N[b.signature.name]=this.mapFunction(b),N),{}));const _={nodes:m,inputs:u,outputs:d,weights:n,placeholders:i,signature:t,functions:O};return p.length>0&&(_.initNodes=p),_}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,a)=>(t[e[a].name]=a,t),{})}mapNode(e){const t=Ee(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const a={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(a.inputParams=t.inputs.reduce((i,n)=>(i[n.name]={type:n.type,inputIndexStart:n.start,inputIndexEnd:n.end},i),{})),null!=t.attrs&&(a.attrParams=t.attrs.reduce((i,n)=>{const p=n.type;let m;switch(n.type){case"string":m=ue(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=ue(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":m=ge(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=ge(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":m=le(e.attr,n.tfName,n.defaultValue||0),void 0===m&&n.tfDeprecatedName&&(m=le(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":m=fe(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=fe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":m=oe(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=oe(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":m=Te(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=Te(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":m=he(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=he(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":m=Ne(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=Ne(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":m=de(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=de(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":m=ye(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=ye(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":m=Ae(e.attr,n.tfName,n.defaultValue),void 0===m&&n.tfDeprecatedName&&(m=Ae(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return i[n.name]={value:m,type:p},i},{})),a}mapFunction(e){const t=e.nodeDef,i=[];let n={};null!=t&&(n=t.reduce((c,h)=>(c[h.name]=this.mapNode(h),"Const"===h.op&&i.push(c[h.name]),c),{}));const p=[],m=[];e.signature.inputArg.forEach(c=>{const[h]=Z(c.name),O={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ce(c.type),type:"dtype"}},children:[]};O.signatureKey=c.name,p.push(O),n[h]=O}),Object.keys(n).forEach(c=>{const h=n[c];h.inputNames.forEach((O,_)=>{const[N,,b]=Z(O),L=n[N];if(null!=L.outputs){const X=L.outputs.indexOf(b);-1!==X&&(h.inputNames[_]=`${N}:${X}`)}h.inputs.push(L),L.children.push(h)})});const d=e.ret;e.signature.outputArg.forEach(c=>{const[h,O]=Z(d[c.name]),_=n[h];null!=_&&(_.defaultOutput=O,m.push(_))});const l=this.mapArgsToSignature(e);return{nodes:n,inputs:p,outputs:m,weights:i,placeholders:[],signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a),t),{}),outputs:e.signature.outputArg.reduce((t,a)=>(t[a.name]=this.mapArgToTensorInfo(a,e.ret),t),{})}}mapArgToTensorInfo(e,t){let a=e.name;return null!=t&&(a=t[a]),{name:a,dtype:e.type}}}function Ie(s,e){const t=Array.isArray(s)?String.fromCharCode.apply(null,s):function rt(s){const e=(0,y.env)().global;if(typeof e.atob<"u")return e.atob(s);if(typeof Buffer<"u")return new Buffer(s,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(s);return e?t:t.toLowerCase()}function ue(s,e,t,a=!1){const i=s[e];return null!=i?Ie(i.s,a):t}function oe(s,e,t){const a=s[e];return a?a.b:t}function le(s,e,t){const a=s[e]||{},i=null!=a.i?a.i:null!=a.f?a.f:t;return"number"==typeof i?i:parseInt(i,10)}function ce(s){switch("string"==typeof s&&(s=o[s]),s){case o.DT_FLOAT:case o.DT_HALF:return"float32";case o.DT_INT32:case o.DT_INT64:case o.DT_INT8:case o.DT_UINT8:return"int32";case o.DT_BOOL:return"bool";case o.DT_DOUBLE:return"float32";case o.DT_STRING:return"string";default:return null}}function Ae(s,e,t){const a=s[e];return a&&a.func?a.func.name:t}function de(s,e,t){const a=s[e];return a&&a.type?ce(a.type):t}function ye(s,e,t){const a=s[e];return a&&a.list&&a.list.type?a.list.type.map(i=>ce(i)):t}function De(s){if(!s.unknownRank)return null!=s.dim?s.dim.map(e=>"number"==typeof e.size?e.size:parseInt(e.size,10)):[]}function he(s,e,t){const a=s[e];return a&&a.shape?De(a.shape):t}function fe(s,e,t){const a=s[e];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map(i=>"number"==typeof i?i:parseInt(i,10)):t}function ge(s,e,t,a=!1){const i=s[e];return i&&i.list&&i.list.s?i.list.s.map(n=>Ie(n,a)):t}function Ne(s,e,t){const a=s[e];return a&&a.list&&a.list.shape?a.list.shape.map(i=>De(i)):t}function Te(s,e,t){const a=s[e];return a&&a.list&&a.list.b?a.list.b:t}class nt{constructor(e,t,a){this.node=e,this.tensorMap=t,this.context=a,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,n)=>(i[n]=this.getAttr(n),i),{}))}getInput(e){return P(e,this.tensorMap,this.context)}getAttr(e,t){const a=this.node.rawAttrs[e];if(null!=a.tensor)return P(e,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return le(this.node.rawAttrs,e,t);if(null!=a.s)return ue(this.node.rawAttrs,e,t);if(null!=a.b)return oe(this.node.rawAttrs,e,t);if(null!=a.shape)return he(this.node.rawAttrs,e,t);if(null!=a.type)return de(this.node.rawAttrs,e,t);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return fe(this.node.rawAttrs,e,t);if(null!=a.list.s)return ge(this.node.rawAttrs,e,t);if(null!=a.list.shape)return Ne(this.node.rawAttrs,e,t);if(null!=a.list.b)return Te(this.node.rawAttrs,e,t);if(null!=a.list.type)return ye(this.node.rawAttrs,e,t)}return t}}var F=f(1357);function Q(s,e,t=""){if("number"!=typeof s&&"number"!=typeof e){y.util.assert(s.length===e.length,()=>t+` Shapes ${s} and ${e} must match`);for(let a=0;a<s.length;a++){const i=s[a],n=e[a];y.util.assert(i<0||n<0||i===n,()=>t+` Shapes ${s} and ${e} must match`)}}}function ke(s){return!("number"==typeof s||s.some(e=>e<0))}function ae(s,e,t){let a=be(s,t);const i=!ke(a);if(i&&0===e.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${a}`);if(i&&e.forEach(n=>{a=be(n.shape,a)}),!ke(a))throw new Error(`Non-fully-defined elementShape: ${a}`);return a}function be(s,e){if("number"==typeof s)return e;if("number"==typeof e)return s;if(s.length!==e.length)throw new Error(`Incompatible ranks during merge: ${s} vs. ${e}`);const t=[];for(let a=0;a<s.length;++a){const i=s[a],n=e[a];if(i>=0&&n>=0&&i!==n)throw new Error(`Incompatible shape during merge: ${s} vs. ${e}`);t[a]=i>=0?i:n}return t}class pt{constructor(e,t,a,i,n,p,m){this.name=e,this.dtype=t,this.maxSize=a,this.elementShape=i,this.identicalElementShapes=n,this.dynamicSize=p,this.clearAfterRead=m,this.tensors=[],this.closed_=!1,this.idTensor=(0,y.scalar)(0),(0,y.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(null==e||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=t.shape),Q(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);a.tensor=t,(0,y.keep)(t),a.written=!0,this.tensors[e]=a}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((a,i)=>this.write(a,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(0===e.length)return(0,y.tensor)([],[0].concat(this.elementShape));const a=this.readMany(e);return Q(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),(0,y.stack)(a,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return(0,y.tensor)([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const a=this.readMany(t);return Q(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),(0,y.concat)(a,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const a=Math.max(...e);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(e,(0,y.unstack)(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let a=0;const i=e.map(u=>(a+=u,a));if(a!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const n=0===a?0:t.size/a,p=[];(0,y.tidy)(()=>{t=(0,y.reshape)(t,[1,a,n]);for(let u=0;u<e.length;++u)p[u]=(0,y.reshape)((0,y.slice)(t,[0,0===u?0:i[u-1],0],[1,e[u],n]),this.elementShape);return p});const m=[];for(let u=0;u<e.length;u++)m[u]=u;this.writeMany(m,p)}}class M{constructor(e,t,a,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=a,e?.forEach(n=>{if(a!==n.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${n.dtype}`);Q(t,n.shape,"TensorList shape mismatch: "),(0,y.keep)(n)}),this.idTensor=(0,y.scalar)(0),this.maxNumElements=i,(0,y.keep)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new M([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(null==e||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,a=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);Q(e,this.elementShape,"TensorList shape mismatch: ");const i=ae(this.elementShape,this.tensors,e);return(0,y.tidy)(()=>{const n=this.tensors.map(p=>(0,y.reshape)(p,i));return(0,y.stack)(n,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=ae(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,Q(i.shape,e,"TensorList shape mismatch: "),(0,y.reshape)(i,a)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Q(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,y.keep)(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new M([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let a=0;a<Math.min(this.tensors.length,e);++a)t.tensors[a]=this.tensors[a];return t}getItem(e,t,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Q(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=ae(this.elementShape,this.tensors,t);return(0,y.reshape)(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Q(this.elementShape,t.shape,"TensorList shape mismatch: "),(0,y.keep)(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,a){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Q(this.elementShape,a,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=ae(this.elementShape,this.tensors,a);return 0===e.length?(0,y.tensor)([],[0].concat(i)):(0,y.tidy)(()=>{const n=e.map(p=>(0,y.reshape)(this.tensors[p],i));return(0,y.stack)(n,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Q(this.elementShape,t,"TensorList shape mismatch: ");const a=ae(this.elementShape,this.tensors,t);return 0===this.size()?(0,y.tensor)([],[0].concat(a)):(0,y.tidy)(()=>{const i=this.tensors.map(n=>(0,y.reshape)(n,a));return(0,y.concat)(i,0)})}}const dt=function(){var s=(0,w.Z)(function*(e,t,a){switch(e.op){case"If":case"StatelessIf":{const i=r("thenBranch",e,t,a),n=r("elseBranch",e,t,a),p=r("cond",e,t,a),m=r("args",e,t,a);return(yield p.data())[0]?a.functionMap[i].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap):a.functionMap[n].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const i=r("body",e,t,a),n=r("cond",e,t,a),p=r("args",e,t,a),m=yield a.functionMap[n].executeFunctionAsync(p,a.tensorArrayMap,a.tensorListMap),u=p.map(c=>c.id);let d=yield m[0].data();m.forEach(c=>{!c.kept&&-1===u.indexOf(c.id)&&c.dispose()});let l=p;for(;d[0];){const c=l;l=yield a.functionMap[i].executeFunctionAsync(l,a.tensorArrayMap,a.tensorListMap);const h=l.map(_=>_.id);c.forEach(_=>{!_.kept&&-1===u.indexOf(_.id)&&-1===h.indexOf(_.id)&&_.dispose()});const O=yield a.functionMap[n].executeFunctionAsync(l,a.tensorArrayMap,a.tensorListMap);d=yield O[0].data(),O.forEach(_=>{!_.kept&&-1===u.indexOf(_.id)&&-1===h.indexOf(_.id)&&_.dispose()})}return l}case"LoopCond":return[q(r("pred",e,t,a))];case"Switch":{const i=r("pred",e,t,a);let n=r("data",e,t,a);return n.kept||(n=q(n)),(yield i.data())[0]?[void 0,n]:[n,void 0]}case"Merge":{const i=e.inputNames.find(n=>void 0!==P(n,t,a));return i?[q(P(i,t,a))]:void 0}case"Enter":{const i=r("frameName",e,t,a),n=r("tensor",e,t,a);return a.enterFrame(i),[q(n)]}case"Exit":{const i=r("tensor",e,t,a);return a.exitFrame(),[q(i)]}case"NextIteration":{const i=r("tensor",e,t,a);return a.nextIteration(),[q(i)]}case"TensorArrayV3":{const i=r("size",e,t,a),n=r("dtype",e,t,a),p=r("elementShape",e,t,a),m=r("dynamicSize",e,t,a),u=r("clearAfterRead",e,t,a),d=r("identicalElementShapes",e,t,a),l=r("name",e,t,a),c=new pt(l,n,i,p,d,m,u);return a.addTensorArray(c),[c.idTensor,(0,y.scalar)(1)]}case"TensorArrayWriteV3":{const i=r("tensorArrayId",e,t,a),n=r("index",e,t,a),p=r("tensor",e,t,a),m=a.getTensorArray(i.id);return m.write(n,p),[m.idTensor]}case"TensorArrayReadV3":{const i=r("tensorArrayId",e,t,a),n=r("index",e,t,a);return[a.getTensorArray(i.id).read(n)]}case"TensorArrayGatherV3":{const i=r("tensorArrayId",e,t,a),n=r("indices",e,t,a),p=r("dtype",e,t,a);return[a.getTensorArray(i.id).gather(n,p)]}case"TensorArrayScatterV3":{const i=r("tensorArrayId",e,t,a),n=r("indices",e,t,a),p=r("tensor",e,t,a),m=a.getTensorArray(i.id);return m.scatter(n,p),[m.idTensor]}case"TensorArrayConcatV3":{const i=r("tensorArrayId",e,t,a),n=a.getTensorArray(i.id),p=r("dtype",e,t,a);return[n.concat(p)]}case"TensorArraySplitV3":{const i=r("tensorArrayId",e,t,a),n=r("tensor",e,t,a),p=r("lengths",e,t,a),m=a.getTensorArray(i.id);return m.split(p,n),[m.idTensor]}case"TensorArraySizeV3":{const i=r("tensorArrayId",e,t,a),n=a.getTensorArray(i.id);return[(0,y.scalar)(n.size(),"int32")]}case"TensorArrayCloseV3":{const i=r("tensorArrayId",e,t,a),n=a.getTensorArray(i.id);return n.clearAndClose(),[n.idTensor]}case"TensorListSetItem":{const i=r("tensorListId",e,t,a),n=r("index",e,t,a),p=r("tensor",e,t,a),m=a.getTensorList(i.id);return m.setItem(n,p),[m.idTensor]}case"TensorListGetItem":{const i=r("tensorListId",e,t,a),n=r("index",e,t,a),p=r("elementShape",e,t,a),m=r("elementDType",e,t,a);return[a.getTensorList(i.id).getItem(n,p,m)]}case"TensorListScatterV2":case"TensorListScatter":{const i=r("indices",e,t,a),u=function lt(s,e,t,a){if(e.length!==s.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${s.shape[0]}`);const i=Math.max(...e);if(null!=a&&-1!==a&&i>=a)throw new Error(`Max index must be < array size (${i}  vs. ${a})`);const n=new M([],t,s.dtype,a),p=(0,y.unstack)(s,0);return e.forEach((m,u)=>{n.setItem(m,p[u])}),n}(r("tensor",e,t,a),i,r("elementShape",e,t,a),r("numElements",e,t,a));return a.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const i=r("elementShape",e,t,a),n=r("elementDType",e,t,a);let p;p="TensorListReserve"===e.op?"numElements":"maxNumElements";const m=r(p,e,t,a),d=function ot(s,e,t,a){return new M([],s,e,a)}(i,n,0,"TensorListReserve"===e.op?-1:m);return a.addTensorList(d),[d.idTensor]}case"TensorListGather":{const i=r("tensorListId",e,t,a),n=r("indices",e,t,a),p=r("elementShape",e,t,a),m=r("elementDType",e,t,a);return[a.getTensorList(i.id).gather(n,m,p)]}case"TensorListStack":{const i=r("tensorListId",e,t,a),n=r("elementShape",e,t,a),p=r("elementDType",e,t,a),m=r("numElements",e,t,a);return[a.getTensorList(i.id).stack(n,p,m)]}case"TensorListFromTensor":{const m=function ut(s,e,t){const a=s.dtype;if(s.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${s.shape}`);if(s.dtype!==t)throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${t}`);Q(s.shape.slice(1),e,"TensorList shape mismatch: ");const n=(0,y.unstack)(s);return new M(n,e,a)}(r("tensor",e,t,a),r("elementShape",e,t,a),r("elementDType",e,t,a));return a.addTensorList(m),[m.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const i=r("tensorListId",e,t,a),n=a.getTensorList(i.id),p=r("dtype",e,t,a),m=r("elementShape",e,t,a);return[n.concat(p,m)]}case"TensorListPushBack":{const i=r("tensorListId",e,t,a),n=r("tensor",e,t,a),p=a.getTensorList(i.id);return p.pushBack(n),[p.idTensor]}case"TensorListPopBack":{const i=r("tensorListId",e,t,a),n=r("elementShape",e,t,a),p=r("elementDType",e,t,a);return[a.getTensorList(i.id).popBack(n,p)]}case"TensorListSplit":{const i=r("tensor",e,t,a),n=r("elementShape",e,t,a),m=function ct(s,e,t){let a=0;const i=e.map(l=>(a+=l,a));if(a!==s.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${s.shape}`);const p=be(s.shape.slice(1),t),m=0===a?0:s.size/a,u=(0,y.tidy)(()=>{const l=[];s=(0,y.reshape)(s,[1,a,m]);for(let c=0;c<e.length;++c)l[c]=(0,y.reshape)((0,y.slice)(s,[0,0===c?0:i[c-1],0],[1,e[c],m]),p);return s.dispose(),l}),d=new M([],t,s.dtype,e.length);for(let l=0;l<u.length;l++)d.setItem(l,u[l]);return d}(i,r("lengths",e,t,a),n);return a.addTensorList(m),[m.idTensor]}case"TensorListLength":{const i=r("tensorListId",e,t,a),n=a.getTensorList(i.id);return[(0,y.scalar)(n.size(),"int32")]}case"TensorListResize":{const i=r("tensorListId",e,t,a),n=r("size",e,t,a),m=a.getTensorList(i.id).resize(n);return a.addTensorList(m),[m.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,a,i){return s.apply(this,arguments)}}();function Le(s,e,t){const[a,i]=r("fusedOps",s,e,t),n="biasadd"===a,p=!n,m="prelu"===i,u="fusedbatchnorm"===a,d=r("numArgs",s,e,t);if(n){if(m&&2!==d)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!m&&n&&1!==d)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const l=r("strides",s,e,t),c=re(s,e,t),h=r("dataFormat",s,e,t).toUpperCase(),O=r("dilations",s,e,t);let[_,N]=r("args",s,e,t);return p&&(N=_,_=void 0),{stride:l,pad:c,dataFormat:h,dilations:O,biasArg:_,preluArg:N,activationFunc:i,leakyreluAlpha:r("leakyreluAlpha",s,e,t)}}function Se(s,e,t){return{boxes:r("boxes",s,e,t),scores:r("scores",s,e,t),maxOutputSize:r("maxOutputSize",s,e,t),iouThreshold:r("iouThreshold",s,e,t),scoreThreshold:r("scoreThreshold",s,e,t),softNmsSigma:r("softNmsSigma",s,e,t)}}const ft=function(){var s=(0,w.Z)(function*(e,t,a,i,n=F){switch(e.op){case"NonMaxSuppressionV5":{const{boxes:p,scores:m,maxOutputSize:u,iouThreshold:d,scoreThreshold:l,softNmsSigma:c}=Se(e,t,a),h=yield n.image.nonMaxSuppressionWithScoreAsync(p,m,u,d,l,c);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:p,scores:m,maxOutputSize:u,iouThreshold:d,scoreThreshold:l}=Se(e,t,a),c=r("padToMaxOutputSize",e,t,a),h=yield n.image.nonMaxSuppressionPaddedAsync(p,m,u,d,l,c);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:p,scores:m,maxOutputSize:u,iouThreshold:d,scoreThreshold:l}=Se(e,t,a);return[yield n.image.nonMaxSuppressionAsync(p,m,u,d,l)]}case"Where":{const p=n.cast(r("condition",e,t,a),"bool"),m=[yield n.whereAsync(p)];return p.dispose(),m}case"ListDiff":return n.setdiff1dAsync(r("x",e,t,a),r("y",e,t,a));default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,a,i,n){return s.apply(this,arguments)}}();var Tt=f(8153);class bt{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=(0,y.scalar)(0),this.tensorMap=new Map,(0,y.keep)(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Tt.i(this.size(),"int32")}import(e,t){var a=this;return(0,w.Z)(function*(){a.checkKeyAndValueTensor(e,t);const i=yield e.data();return a.tensorMap.forEach(n=>n.dispose()),a.tensorMap.clear(),(0,y.tidy)(()=>{const n=(0,y.unstack)(t),p=i.length,m=n.length;y.util.assert(p===m,()=>`The number of elements doesn't match, keys has ${p} elements, the values has ${m} elements.`);for(let u=0;u<p;u++){const d=i[u],l=n[u];(0,y.keep)(l),a.tensorMap.set(d,l)}return a.handle})})()}find(e,t){var a=this;return(0,w.Z)(function*(){a.checkKeyAndValueTensor(e,t);const i=yield e.data();return(0,y.tidy)(()=>{const n=[];for(let p=0;p<i.length;p++){const u=a.findWithDefault(i[p],t);n.push(u)}return(0,y.stack)(n)})})()}findWithDefault(e,t){return this.tensorMap.get(e)??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const St=function(){var s=(0,w.Z)(function*(e,t,a,i){switch(e.op){case"HashTable":case"HashTableV2":{const n=r("keyDType",e,t,a),p=r("valueDType",e,t,a),m=new bt(n,p);return i.addHashTable(e.name,m),[m.handle]}case"LookupTableImport":case"LookupTableImportV2":{const n=r("tableHandle",e,t,a,i),p=r("keys",e,t,a),m=r("values",e,t,a);return[yield i.getHashTableById(n.id).import(p,m)]}case"LookupTableFind":case"LookupTableFindV2":{const n=r("tableHandle",e,t,a,i),p=r("keys",e,t,a),m=r("defaultValue",e,t,a);return[yield i.getHashTableById(n.id).find(p,m)]}case"LookupTableSize":case"LookupTableSizeV2":{const n=r("tableHandle",e,t,a,i);return[i.getHashTableById(n.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}});return function(t,a,i,n){return s.apply(this,arguments)}}();function Ce(s,e,t,a,i=y.tidy){const n=((p,m,u)=>{switch(p.category){case"arithmetic":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(r("a",s,e,t),r("b",s,e,t))];case"AddN":return[a.addN(r("tensors",s,e,t))];case"FloorMod":case"Mod":return[a.mod(r("a",s,e,t),r("b",s,e,t))];case"Mul":return[a.mul(r("a",s,e,t),r("b",s,e,t))];case"RealDiv":case"Div":return[a.div(r("a",s,e,t),r("b",s,e,t))];case"DivNoNan":return[a.divNoNan(r("a",s,e,t),r("b",s,e,t))];case"FloorDiv":return[a.floorDiv(r("a",s,e,t),r("b",s,e,t))];case"Sub":return[a.sub(r("a",s,e,t),r("b",s,e,t))];case"Minimum":return[a.minimum(r("a",s,e,t),r("b",s,e,t))];case"Maximum":return[a.maximum(r("a",s,e,t),r("b",s,e,t))];case"Pow":return[a.pow(r("a",s,e,t),r("b",s,e,t))];case"SquaredDifference":return[a.squaredDifference(r("a",s,e,t),r("b",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"basic_math":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Abs":case"ComplexAbs":return[a.abs(r("x",s,e,t))];case"Acos":return[a.acos(r("x",s,e,t))];case"Acosh":return[a.acosh(r("x",s,e,t))];case"Asin":return[a.asin(r("x",s,e,t))];case"Asinh":return[a.asinh(r("x",s,e,t))];case"Atan":return[a.atan(r("x",s,e,t))];case"Atan2":return[a.atan2(r("x",s,e,t),r("y",s,e,t))];case"Atanh":return[a.atanh(r("x",s,e,t))];case"Ceil":return[a.ceil(r("x",s,e,t))];case"Complex":return[a.complex(r("real",s,e,t),r("imag",s,e,t))];case"Cos":return[a.cos(r("x",s,e,t))];case"Cosh":return[a.cosh(r("x",s,e,t))];case"Elu":return[a.elu(r("x",s,e,t))];case"Erf":return[a.erf(r("x",s,e,t))];case"Exp":return[a.exp(r("x",s,e,t))];case"Expm1":return[a.expm1(r("x",s,e,t))];case"Floor":return[a.floor(r("x",s,e,t))];case"Log":return[a.log(r("x",s,e,t))];case"Log1p":return[a.log1p(r("x",s,e,t))];case"Imag":return[a.imag(r("x",s,e,t))];case"Neg":return[a.neg(r("x",s,e,t))];case"Reciprocal":return[a.reciprocal(r("x",s,e,t))];case"Real":return[a.real(r("x",s,e,t))];case"Relu":return[a.relu(r("x",s,e,t))];case"Round":return[a.round(r("x",s,e,t))];case"Selu":return[a.selu(r("x",s,e,t))];case"Sigmoid":return[a.sigmoid(r("x",s,e,t))];case"Sin":return[a.sin(r("x",s,e,t))];case"Sign":return[a.sign(r("x",s,e,t))];case"Sinh":return[a.sinh(r("x",s,e,t))];case"Softplus":return[a.softplus(r("x",s,e,t))];case"Sqrt":return[a.sqrt(r("x",s,e,t))];case"Square":return[a.square(r("x",s,e,t))];case"Tanh":return[a.tanh(r("x",s,e,t))];case"Tan":return[a.tan(r("x",s,e,t))];case"ClipByValue":return[a.clipByValue(r("x",s,e,t),r("clipValueMin",s,e,t),r("clipValueMax",s,e,t))];case"Relu6":return[a.relu6(r("x",s,e,t))];case"Rsqrt":return[a.rsqrt(P(s.inputNames[0],e,t))];case"Prod":return[a.prod(r("x",s,e,t),r("axes",s,e,t))];case"LeakyRelu":return[a.leakyRelu(r("x",s,e,t),r("alpha",s,e,t))];case"Prelu":return[a.prelu(r("x",s,e,t),r("alpha",s,e,t))];case"IsNan":return[a.isNaN(P(s.inputNames[0],e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"control":return dt(p,m,u);case"convolution":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Conv1D":{const i=r("stride",s,e,t),n=r("pad",s,e,t),p=r("dataFormat",s,e,t).toUpperCase(),m=r("dilation",s,e,t);return[a.conv1d(r("x",s,e,t),r("filter",s,e,t),i,n,p,m)]}case"Conv2D":{const i=r("strides",s,e,t),n=re(s,e,t),p=r("dataFormat",s,e,t).toUpperCase(),m=r("dilations",s,e,t);return[a.conv2d(r("x",s,e,t),r("filter",s,e,t),[i[1],i[2]],n,p,[m[1],m[2]])]}case"_FusedConv2D":{const{stride:i,pad:n,dataFormat:p,dilations:m,biasArg:u,preluArg:d,activationFunc:l,leakyreluAlpha:c}=Le(s,e,t);return[a.fused.conv2d({x:r("x",s,e,t),filter:r("filter",s,e,t),strides:[i[1],i[2]],pad:n,dataFormat:p,dilations:[m[1],m[2]],bias:u,activation:l,preluActivationWeights:d,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:n,dataFormat:p,dilations:m,biasArg:u,preluArg:d,activationFunc:l,leakyreluAlpha:c}=Le(s,e,t);return[a.fused.depthwiseConv2d({x:r("x",s,e,t),filter:r("filter",s,e,t),strides:[i[1],i[2]],pad:n,dataFormat:p,dilations:[m[1],m[2]],bias:u,activation:l,preluActivationWeights:d,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=r("outputShape",s,e,t),n=r("strides",s,e,t),p=re(s,e,t);return[a.conv2dTranspose(r("x",s,e,t),r("filter",s,e,t),i,[n[1],n[2]],p)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=r("strides",s,e,t),n=re(s,e,t),p=r("dilations",s,e,t),m=r("dataFormat",s,e,t).toUpperCase();return[a.depthwiseConv2d(r("input",s,e,t),r("filter",s,e,t),[i[1],i[2]],n,m,[p[1],p[2]])]}case"Conv3D":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("dataFormat",s,e,t).toUpperCase(),m=r("dilations",s,e,t);return[a.conv3d(r("x",s,e,t),r("filter",s,e,t),[i[1],i[2],i[3]],n,p,[m[1],m[2],m[3]])]}case"AvgPool":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("kernelSize",s,e,t);return[a.avgPool(r("x",s,e,t),[p[1],p[2]],[i[1],i[2]],n)]}case"MaxPool":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("kernelSize",s,e,t);return[a.maxPool(r("x",s,e,t),[p[1],p[2]],[i[1],i[2]],n)]}case"MaxPoolWithArgmax":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("kernelSize",s,e,t),m=r("includeBatchInIndex",s,e,t),{result:u,indexes:d}=a.maxPoolWithArgmax(r("x",s,e,t),[p[1],p[2]],[i[1],i[2]],n,m);return[u,d]}case"AvgPool3D":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("kernelSize",s,e,t);return[a.avgPool3d(r("x",s,e,t),[p[1],p[2],p[3]],[i[1],i[2],i[3]],n)]}case"MaxPool3D":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("kernelSize",s,e,t);return[a.maxPool3d(r("x",s,e,t),[p[1],p[2],p[3]],[i[1],i[2],i[3]],n)]}case"Dilation2D":{const i=r("strides",s,e,t),n=r("pad",s,e,t),p=r("dilations",s,e,t),m=i[1],u=i[2],d=p[1],l=p[2];return[a.dilation2d(r("x",s,e,t),r("filter",s,e,t),[m,u],n,[d,l],"NHWC")]}default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"creation":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Fill":{const i=r("shape",s,e,t),n=r("dtype",s,e,t),p=r("value",s,e,t);return[a.fill(i,p,n)]}case"LinSpace":{const i=r("start",s,e,t),n=r("stop",s,e,t),p=r("num",s,e,t);return[a.linspace(i,n,p)]}case"Multinomial":{const i=r("logits",s,e,t),n=r("numSamples",s,e,t),p=r("seed",s,e,t);return[a.multinomial(i,n,p)]}case"OneHot":{const i=r("indices",s,e,t),n=r("depth",s,e,t),p=r("onValue",s,e,t),m=r("offValue",s,e,t),u=r("dtype",s,e,t);return[a.oneHot(i,n,p,m,u)]}case"Ones":return[a.ones(r("shape",s,e,t),r("dtype",s,e,t))];case"OnesLike":return[a.onesLike(r("x",s,e,t))];case"RandomStandardNormal":return[a.randomStandardNormal(r("shape",s,e,t),r("dtype",s,e,t),r("seed",s,e,t))];case"RandomUniform":return[a.randomUniform(r("shape",s,e,t),r("minval",s,e,t),r("maxval",s,e,t),r("dtype",s,e,t))];case"Range":{const i=r("start",s,e,t),n=r("stop",s,e,t),p=r("step",s,e,t);return[a.range(i,n,p,r("dtype",s,e,t))]}case"TruncatedNormal":{const i=r("shape",s,e,t),n=r("mean",s,e,t),p=r("stdDev",s,e,t),m=r("seed",s,e,t);return[a.truncatedNormal(i,n,p,r("dtype",s,e,t),m)]}case"Zeros":return[a.zeros(r("shape",s,e,t),r("dtype",s,e,t))];case"ZerosLike":return[a.zerosLike(r("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"dynamic":return ft(p,m,u);case"evaluation":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"LowerBound":{const i=r("sortedSequence",s,e,t),n=r("values",s,e,t);return[a.lowerBound(i,n)]}case"TopKV2":{const i=r("x",s,e,t),n=r("k",s,e,t),p=r("sorted",s,e,t),m=a.topk(i,n,p);return[m.values,m.indices]}case"UpperBound":{const i=r("sortedSequence",s,e,t),n=r("values",s,e,t);return[a.upperBound(i,n)]}case"Unique":{const i=r("x",s,e,t),n=a.unique(i);return[n.values,n.indices]}case"UniqueV2":{const i=r("x",s,e,t),n=r("axis",s,e,t),p=a.unique(i,n);return[p.values,p.indices]}default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"image":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"ResizeBilinear":{const i=r("images",s,e,t),n=r("size",s,e,t),p=r("alignCorners",s,e,t),m=r("halfPixelCenters",s,e,t);return[a.image.resizeBilinear(i,[n[0],n[1]],p,m)]}case"ResizeNearestNeighbor":{const i=r("images",s,e,t),n=r("size",s,e,t),p=r("alignCorners",s,e,t),m=r("halfPixelCenters",s,e,t);return[a.image.resizeNearestNeighbor(i,[n[0],n[1]],p,m)]}case"CropAndResize":{const i=r("image",s,e,t),n=r("boxes",s,e,t),p=r("boxInd",s,e,t),m=r("cropSize",s,e,t),u=r("method",s,e,t),d=r("extrapolationValue",s,e,t);return[a.image.cropAndResize(i,n,p,m,u,d)]}case"ImageProjectiveTransformV3":{const i=r("images",s,e,t),n=r("transforms",s,e,t),p=r("outputShape",s,e,t),m=r("fillValue",s,e,t),u=r("interpolation",s,e,t),d=r("fillMode",s,e,t);return[a.image.transform(i,n,u.toLowerCase(),d.toLowerCase(),m,p)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"graph":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Const":return e[s.name];case"PlaceholderWithDefault":const i=r("default",s,e,t);return[P(s.name,e,t)||i];case"Placeholder":return[P(s.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[q(r("x",s,e,t))];case"IdentityN":return r("x",s,e,t).map(l=>q(l));case"Shape":return[a.tensor1d(r("x",s,e,t).shape,"int32")];case"ShapeN":return r("x",s,e,t).map(l=>a.tensor1d(l.shape));case"Size":return[a.scalar(r("x",s,e,t).size,"int32")];case"Rank":return[a.scalar(r("x",s,e,t).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const p=r("x",s,e,t),m=r("data",s,e,t),u=r("message",s,e,t),d=r("summarize",s,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<m.length;l++)console.log(Array.prototype.slice.call(m[l].dataSync()).slice(0,d));return[p];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"logical":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Equal":return[a.equal(r("a",s,e,t),r("b",s,e,t))];case"NotEqual":return[a.notEqual(r("a",s,e,t),r("b",s,e,t))];case"Greater":return[a.greater(r("a",s,e,t),r("b",s,e,t))];case"GreaterEqual":return[a.greaterEqual(r("a",s,e,t),r("b",s,e,t))];case"Less":return[a.less(r("a",s,e,t),r("b",s,e,t))];case"LessEqual":return[a.lessEqual(r("a",s,e,t),r("b",s,e,t))];case"LogicalAnd":return[a.logicalAnd(r("a",s,e,t),r("b",s,e,t))];case"LogicalNot":return[a.logicalNot(r("a",s,e,t))];case"LogicalOr":return[a.logicalOr(r("a",s,e,t),r("b",s,e,t))];case"Select":case"SelectV2":return[a.where(r("condition",s,e,t),r("a",s,e,t),r("b",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"matrices":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(r("a",s,e,t),r("b",s,e,t),r("transposeA",s,e,t),r("transposeB",s,e,t))];case"Einsum":return[a.einsum(r("equation",s,e,t),...r("tensors",s,e,t))];case"Transpose":return[a.transpose(r("x",s,e,t),r("perm",s,e,t))];case"_FusedMatMul":const[i,n]=r("fusedOps",s,e,t),p="biasadd"===i,m="prelu"===n,u=r("numArgs",s,e,t),d=r("leakyreluAlpha",s,e,t);if(p){if(m&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!m&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,c]=r("args",s,e,t);return[a.fused.matMul({a:r("a",s,e,t),b:r("b",s,e,t),transposeA:r("transposeA",s,e,t),transposeB:r("transposeB",s,e,t),bias:l,activation:n,preluActivationWeights:c,leakyreluAlpha:d})];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"normalization":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"EuclideanNorm":return[a.euclideanNorm(r("x",s,e,t),r("axis",s,e,t),r("keepDims",s,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(r("x",s,e,t),r("mean",s,e,t),r("variance",s,e,t),r("offset",s,e,t),r("scale",s,e,t),r("epsilon",s,e,t))];case"LRN":return[a.localResponseNormalization(r("x",s,e,t),r("radius",s,e,t),r("bias",s,e,t),r("alpha",s,e,t),r("beta",s,e,t))];case"Softmax":return[a.softmax(r("x",s,e,t))];case"LogSoftmax":return[a.logSoftmax(r("x",s,e,t))];case"SparseToDense":return[a.sparseToDense(r("sparseIndices",s,e,t),r("outputShape",s,e,t),r("sparseValues",s,e,t),r("defaultValue",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"reduction":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Max":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.max(r("x",s,e,t),m,u)]}case"Mean":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.mean(r("x",s,e,t),m,u)]}case"Min":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.min(r("x",s,e,t),m,u)]}case"Sum":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.sum(r("x",s,e,t),m,u)]}case"All":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.all(r("x",s,e,t),m,u)]}case"Any":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.any(r("x",s,e,t),m,u)]}case"ArgMax":{const m=r("axis",s,e,t);return[a.argMax(r("x",s,e,t),m)]}case"ArgMin":{const m=r("axis",s,e,t);return[a.argMin(r("x",s,e,t),m)]}case"Prod":{const m=r("axis",s,e,t),u=r("keepDims",s,e,t);return[a.prod(r("x",s,e,t),m,u)]}case"Cumprod":{const m=r("axis",s,e,t),u=r("exclusive",s,e,t),d=r("reverse",s,e,t);return[a.cumprod(r("x",s,e,t),m,u,d)]}case"Cumsum":{const m=r("axis",s,e,t),u=r("exclusive",s,e,t),d=r("reverse",s,e,t);return[a.cumsum(r("x",s,e,t),m,u,d)]}case"Bincount":const i=r("x",s,e,t),n=r("weights",s,e,t),p=r("size",s,e,t);return[a.bincount(i,n,p)];case"DenseBincount":{const m=r("x",s,e,t),u=r("weights",s,e,t),d=r("size",s,e,t),l=r("binaryOutput",s,e,t);return[a.denseBincount(m,u,d,l)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"slice_join":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"ConcatV2":case"Concat":{const i=r("n",s,e,t),n=r("axis",s,e,t);let p=r("tensors",s,e,t);return p=p.slice(0,i),[a.concat(p,n)]}case"Gather":{const i=r("x",s,e,t),n=r("indices",s,e,t);return[a.gather(i,a.cast(n,"int32"),0)]}case"GatherV2":{const i=r("axis",s,e,t),n=r("batchDims",s,e,t),p=r("x",s,e,t),m=r("indices",s,e,t);return[a.gather(p,a.cast(m,"int32"),i,n)]}case"Reverse":{const i=r("dims",s,e,t),n=[];for(let m=0;m<i.length;m++)i[m]&&n.push(m);const p=r("x",s,e,t);return[a.reverse(p,n)]}case"ReverseV2":{const i=r("axis",s,e,t),n=r("x",s,e,t);return[a.reverse(n,i)]}case"Slice":{const i=r("begin",s,e,t),n=r("size",s,e,t);return[a.slice(r("x",s,e,t),i,n)]}case"StridedSlice":{const i=r("begin",s,e,t),n=r("end",s,e,t),p=r("strides",s,e,t),m=r("beginMask",s,e,t),u=r("endMask",s,e,t),d=r("ellipsisMask",s,e,t),l=r("newAxisMask",s,e,t),c=r("shrinkAxisMask",s,e,t),h=r("x",s,e,t);return[a.stridedSlice(h,i,n,p,m,u,d,l,c)]}case"Pack":return(0,y.tidy)(()=>{const i=r("axis",s,e,t),n=r("tensors",s,e,t),p=n[0].shape,m=a.squeeze(n[0]).shape,u=n.map(d=>{const l=y.util.arraysEqual(d.shape,p);if(!l&&!y.util.arraysEqual(a.squeeze(d).shape,m))throw new Error("the input tensors shape does not match");return l?d:a.reshape(d,p)});return[a.stack(u,i)]});case"Unpack":{const i=r("axis",s,e,t),n=r("tensor",s,e,t);return a.unstack(n,i)}case"Tile":{const i=r("reps",s,e,t);return[a.tile(r("x",s,e,t),i)]}case"Split":case"SplitV":{const i=r("axis",s,e,t),n=r("numOrSizeSplits",s,e,t),p=r("x",s,e,t);return a.split(p,n,i)}case"ScatterNd":{const i=r("indices",s,e,t),n=r("values",s,e,t),p=r("shape",s,e,t);return[a.scatterND(i,n,p)]}case"GatherNd":{const i=r("x",s,e,t),n=r("indices",s,e,t);return[a.gatherND(i,n)]}case"SparseToDense":{const i=r("sparseIndices",s,e,t),n=r("outputShape",s,e,t),p=r("sparseValues",s,e,t),m=r("defaultValue",s,e,t);return[a.sparseToDense(i,p,n,p.dtype===m.dtype?m:a.cast(m,p.dtype))]}default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"sparse":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:n,emptyRowIndicator:p,reverseIndexMap:m}=a.sparse.sparseFillEmptyRows(r("indices",s,e,t),r("values",s,e,t),r("denseShape",s,e,t),r("defaultValue",s,e,t));return[i,n,p,m]}case"SparseReshape":{const{outputIndices:i,outputShape:n}=a.sparse.sparseReshape(r("inputIndices",s,e,t),r("inputShape",s,e,t),r("newShape",s,e,t));return[i,n]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(r("data",s,e,t),r("indices",s,e,t),r("segmentIds",s,e,t))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(r("data",s,e,t),r("indices",s,e,t),r("segmentIds",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"spectral":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"FFT":return[a.fft(r("x",s,e,t))];case"IFFT":return[a.ifft(r("x",s,e,t))];case"RFFT":return[a.rfft(r("x",s,e,t))];case"IRFFT":return[a.irfft(r("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"string":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"StringNGrams":{const{nGrams:i,nGramsSplits:n}=a.string.stringNGrams(r("data",s,e,t),r("dataSplits",s,e,t),r("separator",s,e,t),r("nGramWidths",s,e,t),r("leftPad",s,e,t),r("rightPad",s,e,t),r("padWidth",s,e,t),r("preserveShortSequences",s,e,t));return[i,n]}case"StringSplit":{const{indices:i,values:n,shape:p}=a.string.stringSplit(r("input",s,e,t),r("delimiter",s,e,t),r("skipEmpty",s,e,t));return[i,n,p]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(r("input",s,e,t),r("numBuckets",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"transformation":return i(()=>((s,e,t,a=F)=>{switch(s.op){case"Cast":return[a.cast(r("x",s,e,t),r("dtype",s,e,t))];case"ExpandDims":{const i=r("axis",s,e,t);return[a.expandDims(r("x",s,e,t),i)]}case"Squeeze":{const i=r("axis",s,e,t);return[a.squeeze(r("x",s,e,t),i)]}case"Reshape":return[a.reshape(r("x",s,e,t),r("shape",s,e,t))];case"MirrorPad":return[a.mirrorPad(r("x",s,e,t),r("padding",s,e,t),r("mode",s,e,t))];case"PadV2":case"Pad":return[a.pad(r("x",s,e,t),r("padding",s,e,t),r("constantValue",s,e,t))];case"SpaceToBatchND":{const i=r("blockShape",s,e,t),n=r("paddings",s,e,t);return[a.spaceToBatchND(r("x",s,e,t),i,n)]}case"BatchToSpaceND":{const i=r("blockShape",s,e,t),n=r("crops",s,e,t);return[a.batchToSpaceND(r("x",s,e,t),i,n)]}case"DepthToSpace":{const i=r("blockSize",s,e,t),n=r("dataFormat",s,e,t).toUpperCase();return[a.depthToSpace(r("x",s,e,t),i,n)]}case"BroadcastTo":return[a.broadcastTo(r("x",s,e,t),r("shape",s,e,t))];case"BroadcastArgs":return[a.broadcastArgs(r("s0",s,e,t),r("s1",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}})(p,m,u));case"hash_table":return St(p,m,u,a);case"custom":const d=Ee(p.op);if(d&&d.customExecutor)return d.customExecutor(new nt(p,m,u));throw TypeError(`Custom op ${p.op} is not registered.`);default:throw TypeError(`Unknown op '${p.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(s,e,t);return y.util.isPromise(n)?n.then(p=>[].concat(p)):[].concat(n)}class Ve{constructor(e={},t={},a={},i={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=a,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const a=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(a))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function ze(s,e,t,a){const i=new Set,n=[];let p=null,m=null;const u=new Set,d=Object.keys(s).map(h=>W(h)[0]);let l=[];null!=a&&(l=a.map(h=>W(h.name)[0]));const c=[...e];for(;c.length>0;){const h=c.pop();if((Fe(h)||xt(h)||Rt(h))&&null==p&&(p=h,m=p.children.map(O=>O.name).filter(O=>i.has(O))),i.add(h.name),null==t[h.name]&&-1===d.indexOf(h.name)&&-1===l.indexOf(h.name)){if(0===h.inputs.length){n.push(h.name);continue}h.inputs.forEach(O=>{u.has(O.name)||(u.add(O.name),c.push(O))})}}return{inputs:s,outputs:e,usedNodes:i,missingInputs:n,dynamicNode:p,syncInputs:m}}const Vt=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],zt=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Ft=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Fe(s){return Vt.indexOf(s.op)>=0}function xt(s){return zt.indexOf(s.op)>=0}function Rt(s){return Ft.indexOf(s.op)>=0}class ne{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach(a=>{this._functionExecutorMap[a]=new ne(e.functions[a],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(a=>e[a].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const a=e.map(n=>n.name).sort(),i=t.map(n=>n.name).sort();return a.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,t){const a=ze(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:n,syncInputs:p}=a;if(null!=n)throw new Error(`This execution contains the node '${n.name}', which has the dynamic op '${n.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${p}]`);if(i.length>0){const m=t.map(d=>d.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${m}] from the provided inputs [${u}]. Missing the following inputs: [${i}]`)}return function Ct(s,e,t){const{usedNodes:a,inputs:i}=t,n=[],p=Object.keys(i).map(l=>W(l)[0]).map(l=>s.nodes[l]),m=s.initNodes;p.forEach(l=>{a.has(l.name)&&n.push(l)}),s.weights.forEach(l=>{a.has(l.name)&&n.push(l)}),m?.forEach(l=>{a.has(l.name)&&n.push(l)});const u=new Set,d=[];for(;n.length>0;){const l=n.pop();u.add(l.name),e[l.name]||d.push(l),l.children.forEach(c=>{!u.has(c.name)&&a.has(c.name)&&c.inputs.every(h=>u.has(h.name))&&n.push(c)})}return d}(this.graph,this.weightMap,a)}execute(e,t){e=this.mapInputs(e);const a=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=a.map(c=>this.graph.nodes[W(c)[0]]),n=t.map(c=>W(c)[0]);let p=n.map(c=>this.graph.nodes[c]);this.resetIntermediateTensors(),0===p.length&&(p=this._outputs);const m=this.getCompilationKey(i,p);let u=this.compiledMap.get(m);null==u&&(u=this.compile(e,p),this.compiledMap.set(m,u));const d={},l={};return(0,y.tidy)(()=>{const c=new Ve(this.weightMap,d,l,this.functionExecutorMap),h=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[b,L]=W(N),X=[];X[L]=e[N],h[b]=X});const O=this.getFrozenTensorIds(h),_={};for(let N=0;N<u.length;N++){const b=u[N];if(!h[b.name]){const L=Ce(b,h,c,this._resourceManager);if(y.util.isPromise(L))throw new Error(`The execution of the op '${b.op}' returned a promise. Please use model.executeAsync() instead.`);h[b.name]=L,this.checkTensorForDisposal(b.name,b,h,c,O,n,_)}}return null==this.parent&&c.dispose(O),t.map(N=>P(N,h,c))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(a=>e[a]).map(a=>a.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,a,i,n,p,m){"control"===t.category||-1!==p.indexOf(e)||(a[e].forEach(u=>{null!=u&&(m[u.id]=(m[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if("control"!==u.category){const d=function Pe(s,e,t){return e[se(s,t.currentContextId)]}(u.name,a,i);d?.forEach(l=>{if(l&&!l.kept&&!n.has(l.id)){const c=m[l.id];if(1===c){if(this.keepTensorForDebug){const[h,O]=Z(t.name,i);this.intermediateTensors[h]||(this.intermediateTensors[h]=[]),this.intermediateTensors[h][O]=l}else l.dispose();delete m[l.id]}else null!=c&&m[l.id]--}})}}))}executeAsync(e,t){var a=this;return(0,w.Z)(function*(){return a._executeAsync(e,t)})()}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(a=>{a&&!a.kept&&!a.isDisposed&&!this.keepIds.has(a.id)&&a.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}_executeAsync(e,t,a=!1,i={},n={}){var p=this;return(0,w.Z)(function*(){a||(e=p.mapInputs(e),p.checkInputs(e),p.checkInputShapeAndType(e),t=p.mapOutputs(t),p.checkOutputs(t));try{p.keepTensorForDebug=(0,y.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){console.warn(c.message)}p.resetIntermediateTensors();const m=new Ve(p.weightMap,i,n,p.functionExecutorMap);p.tensorsMap=yield p.executeWithControlFlow(e,m,t,a);const u=t.map(c=>P(c,p.tensorsMap,m)),d=u.map(c=>c.id),l=Object.keys(e).map(c=>e[c].id);return p.keepIds=new Set([...d,...l,...p.weightIds]),p.keepTensorForDebug||p.disposeTensorsMap(),null==p.parent&&m.dispose(p.keepIds),u})()}executeFunctionAsync(e,t,a){var i=this;return(0,w.Z)(function*(){const n=e.reduce((p,m,u)=>(p[i.inputs[u].name]=m,p),{});return i._executeAsync(n,i.outputNodes,!0,t,a)})()}executeWithControlFlow(e,t,a,i){var n=this;return(0,w.Z)(function*(){const p=Object.keys(e),m=p.map(k=>n.graph.nodes[W(k)[0]]),u=a.map(k=>W(k)[0]);let d=u.map(k=>n.graph.nodes[k]);0===d.length&&(d=n._outputs);const{usedNodes:l,missingInputs:c,dynamicNode:h,syncInputs:O}=ze(e,d,n.weightMap,n._initNodes),_=[...m,...n.graph.weights,...n._initNodes||[]].map(k=>({node:k,contexts:t.currentContext})),N=Object.assign({},n.weightMap);Object.keys(e).forEach(k=>{const[te,ie]=W(k),me=[];me[ie]=e[k],N[te]=me});const b={},L=n.getFrozenTensorIds(N),X={};for(;_.length>0;){const k=n.processStack(m,_,t,N,X,L,u,b,l);yield Promise.all(k)}null==h&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const ee=d.filter(k=>!Fe(k)&&!P(k.name,N,t)).map(k=>k.name);if(ee.length>0){let k="";throw null!=h&&(k=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${O}]`),new Error(`Cannot compute the outputs [${ee}] from the provided inputs [${p}]. Consider providing the following inputs: [${c}]. ${k}`)}return N})()}processStack(e,t,a,i,n,p,m,u,d){const l=[];for(;t.length>0;){const c=t.pop();a.currentContext=c.contexts;let h="";if("Enter"===c.node.op&&r("isConstant",c.node,i,a)&&([h]=Z(c.node.name,a)),null==i[c.node.name]){const O=Ce(c.node,i,a,this._resourceManager);h||([h]=Z(c.node.name,a));const _=a.currentContext;y.util.isPromise(O)?l.push(O.then(N=>(i[h]=N,a.currentContext=_,this.checkTensorForDisposal(h,c.node,i,a,p,m,u),this.processChildNodes(c.node,t,a,i,n,d),N))):(i[h]=O,this.checkTensorForDisposal(h,c.node,i,a,p,m,u),this.processChildNodes(c.node,t,a,i,n,d))}else this.processChildNodes(c.node,t,a,i,n,d)}return l}processChildNodes(e,t,a,i,n,p){e.children.forEach(m=>{const[u]=Z(m.name,a);n[u]||!p.has(m.name)||("Merge"===m.op?m.inputNames.some(d=>!!P(d,i,a))&&(n[u]=!0,t.push({contexts:a.currentContext,node:m})):m.inputNames.every(d=>!!P(d,i,a))&&(n[u]=!0,t.push({contexts:a.currentContext,node:m})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const a=e[t],[i]=W(t),n=this.graph.nodes[i];if(n.attrParams.shape&&n.attrParams.shape.value){const p=n.attrParams.shape.value,m=p.length===a.shape.length&&a.shape.every((u,d)=>-1===p[d]||p[d]===u);y.util.assert(m,()=>`The shape of dict['${n.name}'] provided in model.execute(dict) must be [${p}], but was [${a.shape}]`)}n.attrParams.dtype&&n.attrParams.dtype.value&&y.util.assert(a.dtype===n.attrParams.dtype.value,()=>`The dtype of dict['${n.name}'] provided in model.execute(dict) must be ${n.attrParams.dtype.value}, but was ${a.dtype}`)})}mapInputs(e){const t={};for(const a in e)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]?t[this._signature.inputs[a].name]=e[a]:t[a]=e[a];return t}checkInputs(e){const t=Object.keys(e).filter(a=>{const[i]=W(a);return null==this.graph.nodes[i]});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[a]=W(t);if(!this.graph.nodes[a])throw new Error(`The output '${t}' is not found in the graph`)})}}class Pt{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const $t="?tfjs-format=file",jt="model.json";class Oe{constructor(e,t={},a=y.io){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=a,null==t&&(this.loadOptions={}),this.resourceManager=new Pt}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return y.util.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let a=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const n=this.artifacts.userDefinedMetadata;null!=n.signature&&(a=n.signature),null!=n.structuredOutputKeys&&(this.structuredOutputKeys=n.structuredOutputKeys)}this.signature=a,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new ne(ve.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const n=ve.Instance.transformGraph(e.modelInitializer);this.initializer=new ne(n),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}save(e,t){var a=this;return(0,w.Z)(function*(){if("string"==typeof e){const i=a.io.getSaveHandlers(e);if(0===i.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(i.length>1)throw new Error(`Found more than one (${i.length}) save handlers for URL '${e}'`);e=i[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(a.artifacts)})()}predict(e,t){const a=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const n={};return(a instanceof y.Tensor?[a]:a).forEach((p,m)=>n[this.structuredOutputKeys[m]]=p),n}return a}normalizeInputs(e){if(!(e instanceof y.Tensor||Array.isArray(e)))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,a,i)=>(t[a]=e[i],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const a=this.executor.execute(e,t);return a.length>1?a:a[0]}executeAsync(e,t){var a=this;return(0,w.Z)(function*(){e=a.normalizeInputs(e),t=a.normalizeOutputs(t);const i=yield a.executor.executeAsync(e,t);return i.length>1?i:i[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,a)=>(t[a]=[e[a]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}function Bt(s){return _e.apply(this,arguments)}function _e(){return(_e=(0,w.Z)(function*(s,e={},t=y.io){if(null==s)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&"string"==typeof s&&(s=function Ht(s){return s.endsWith("/")||(s+="/"),`${s}${jt}${$t}`}(s));const a=new Oe(s,e,t);return yield a.load(),a})).apply(this,arguments)}function Gt(s){if(null==s)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(s instanceof Array){const[a,i]=s;if(!a)throw new Error("modelJSON must be the first element of the array");if(!(i&&i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in a))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in a))throw new Error("Model JSON is missing 'weightsManifest'");const n=y.io.getWeightSpecs(a.weightsManifest),p=y.io.getModelArtifactsForJSONSync(a,n,i);e=y.io.fromMemorySync(p)}else if("load"in s)e=s;else{if(!("modelTopology"in s&&"weightSpecs"in s&&"weightData"in s))throw new Error("Unknown model format");e=y.io.fromMemorySync(s)}const t=new Oe(e);return t.load(),t}const Ut="3.21.0"},3991:(J,Y,f)=>{"use strict";f.r(Y),f.d(Y,{ObjectDetectedComponent:()=>z});var j=f(89),x=f(8207),B=f(4121),I=f(2147),K=f(3291),G=f(4399),g=f(5095);const E=["img"],A=["canvas"],C=["file"];let z=(()=>{class V{get srcImage(){return this._srcImage.getValue()}set srcImage(T){this._srcImage.getValue()!==T&&this._srcImage.next(T)}get position(){return this._position.getValue()}set position(T){this._position.getValue()!==T&&this._position.next(T)}constructor(){this.model=null,this.img=null,this.canvas=null,this.file=null,this._srcImage=new B.X(""),this.srcImage$=this._srcImage.asObservable().pipe((0,I.x)(),(0,K.d)({bufferSize:1,refCount:!0})),this._position=new B.X(null),this.position$=this._position.asObservable().pipe((0,I.x)(),(0,K.d)({bufferSize:1,refCount:!0})),G.load().then(T=>{this.model=T})}ngOnInit(){this._srcImage.subscribe(T=>{T&&this.predict(T)})}pictureUpload(T){const v=T.target.files[0],S=new FileReader;S.onloadend=D=>{(new Image).src=D.target.result,this._srcImage.next(D.target.result)},S.readAsDataURL(v)}predict(T){const v=this.model,S=new Image(600,400);S.onload=()=>{v&&this.model?.detect(S).then(D=>{if(this.canvas?.nativeElement){const U=this.canvas?.nativeElement,y=["red","green","blue"];U.width=S.width,U.height=S.height;const R=U.getContext("2d");if(R){R.drawImage(S,0,0,S.width,S.height),R.font="40px Arial";for(let w=0;w<D.length;w++)R.beginPath(),R.rect(...D[w].bbox),R.lineWidth=5,R.strokeStyle=y[w%3],R.fillStyle=y[w%3],R.stroke(),R.fillText(D[w].score.toFixed(3)+" "+D[w].class,D[w].bbox[0],D[w].bbox[1]-5)}this.position=D}})},S.src=T}clickFileUpload(){this.file?.nativeElement.click()}}return V.\u0275fac=function(T){return new(T||V)},V.\u0275cmp=g.Xpm({type:V,selectors:[["app-object-detected"]],viewQuery:function(T,v){if(1&T&&(g.Gf(E,7),g.Gf(A,7),g.Gf(C,7)),2&T){let S;g.iGM(S=g.CRH())&&(v.img=S.first),g.iGM(S=g.CRH())&&(v.canvas=S.first),g.iGM(S=g.CRH())&&(v.file=S.first)}},standalone:!0,features:[g._Bn([]),g.jDz],decls:12,vars:0,consts:[["id","container"],[2,"display","flex","flex-direction","column","align-items","center"],["img",""],["canvas",""],[1,"buttons"],["hidden","","accept",".jpg,.jpeg","type","file",3,"change"],["file",""],[3,"click"]],template:function(T,v){1&T&&(g.TgZ(0,"div",0)(1,"div",1),g._UZ(2,"img",null,2)(4,"canvas",null,3)(6,"div"),g.qZA(),g.TgZ(7,"div",4)(8,"input",5,6),g.NdJ("change",function(D){return v.pictureUpload(D)}),g.qZA(),g.TgZ(10,"ion-button",7),g.NdJ("click",function(){return v.clickFileUpload()}),g._uU(11,"Upload File "),g.qZA()()())},dependencies:[x.Pc,x.YG,j.ez],styles:["@media screen and (max-width: 660px){img[_ngcontent-%COMP%]{max-width:60%}ion-button[_ngcontent-%COMP%]{width:100%}}.buttons[_ngcontent-%COMP%]{bottom:0;position:absolute;width:100%;display:flex;align-items:center;flex-direction:column}img[_ngcontent-%COMP%]{max-height:224}"]}),V})()},7820:J=>{function Y(j,x,B,I,K,G,H){try{var g=j[G](H),E=g.value}catch(A){return void B(A)}g.done?x(E):Promise.resolve(E).then(I,K)}J.exports=function f(j){return function(){var x=this,B=arguments;return new Promise(function(I,K){var G=j.apply(x,B);function H(E){Y(G,I,K,H,g,"next",E)}function g(E){Y(G,I,K,H,g,"throw",E)}H(void 0)})}},J.exports.__esModule=!0,J.exports.default=J.exports}}]);