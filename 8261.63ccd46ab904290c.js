(self.webpackChunkapp=self.webpackChunkapp||[]).push([[8261],{3722:(Q,v,t)=>{"use strict";t.d(v,{JL:()=>f,Zu:()=>m});class f{constructor(d,o){this.backend=d,this.dataMover=o,this.data=new WeakMap,this.dataIdsCount=0}get(d){return this.data.has(d)||this.dataMover.moveData(this.backend,d),this.data.get(d)}set(d,o){this.dataIdsCount++,this.data.set(d,o)}has(d){return this.data.has(d)}delete(d){return this.dataIdsCount--,this.data.delete(d)}numDataIds(){return this.dataIdsCount}}class m{refCount(d){return p("refCount")}incRef(d){return p("incRef")}timerAvailable(){return!0}time(d){return p("time")}read(d){return p("read")}readSync(d){return p("readSync")}readToGPU(d,o){return p("readToGPU")}numDataIds(){return p("numDataIds")}disposeData(d,o){return p("disposeData")}write(d,o,n){return p("write")}move(d,o,n,a,c){return p("move")}createTensorFromGPUData(d,o,n){return p("createTensorFromGPUData")}memory(){return p("memory")}floatPrecision(){return p("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return p("dispose")}}function p(h){throw new Error(`'${h}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}},1831:(Q,v,t)=>{"use strict";function e(i,g,C){const I=function D(i,g,C){return function m(i,g,C){let I=0,S=i.length,K=0,z=!1;for(;I<S;){K=I+(S-I>>>1);const H=C(g,i[K]);H>0?I=K+1:(S=K,z=!H)}return z?I:-I-1}(i,g,C||f)}(i,g,C);i.splice(I<0?-(I+1):I,0,g)}function f(i,g){return i>g?1:i<g?-1:0}function p(i,g,C,I,S){return o(i,g,C,I,S,0)}function h(i,g,C,I,S,K){return o(i,g,C,I,S,0,!1,K,!0)}function d(i,g,C,I,S,K){return o(i,g,C,I,S,K,!0)}function o(i,g,C,I,S,K,z=!1,H=!1,ct=!1){const N=[];for(let x=0;x<g.length;x++)g[x]>S&&N.push({score:g[x],boxIndex:x,suppressBeginIndex:0});N.sort(c);const W=K>0?-.5/K:0,k=[],T=[];for(;k.length<C&&N.length>0;){const x=N.pop(),{score:w,boxIndex:V,suppressBeginIndex:et}=x;if(w<S)break;let U=!1;for(let F=k.length-1;F>=et;--F){const Y=n(i,V,k[F]);if(Y>=I){U=!0;break}if(x.score=x.score*a(I,W,Y),x.score<=S)break}x.suppressBeginIndex=k.length,U||(x.score===w?(k.push(V),T.push(x.score)):x.score>S&&e(N,x,c))}const _=k.length,r=C-_;H&&r>0&&(k.push(...new Array(r).fill(0)),T.push(...new Array(r).fill(0)));const y={selectedIndices:k};return z&&(y.selectedScores=T),ct&&(y.validOutputs=_),y}function n(i,g,C){const I=i.subarray(4*g,4*g+4),S=i.subarray(4*C,4*C+4),K=Math.min(I[0],I[2]),z=Math.min(I[1],I[3]),H=Math.max(I[0],I[2]),ct=Math.max(I[1],I[3]),N=Math.min(S[0],S[2]),W=Math.min(S[1],S[3]),k=Math.max(S[0],S[2]),T=Math.max(S[1],S[3]),_=(H-K)*(ct-z),r=(k-N)*(T-W);if(_<=0||r<=0)return 0;const y=Math.max(K,N),x=Math.max(z,W),w=Math.min(H,k),V=Math.min(ct,T),et=Math.max(w-y,0)*Math.max(V-x,0);return et/(_+r-et)}function a(i,g,C){const I=Math.exp(g*C*C);return C<=i?I:0}function c(i,g){return i.score-g.score||i.score===g.score&&g.boxIndex-i.boxIndex}t.d(v,{GP:()=>p,qP:()=>h,pA:()=>d})},4644:(Q,v,t)=>{"use strict";t.d(v,{Z:()=>D});var e=t(4062);function D(f,m){const p=[];for(let o=0;o<m.length;o++)m[o]&&p.push(o);const h=(0,e.f)(f,"int32"),d=(0,e.f)([p.length,f.length],"int32");for(let o=0;o<p.length;o++){const n=h.indexToLoc(p[o]);d.values.set(n,o*f.length)}return d.toTensor()}},2882:(Q,v,t)=>{"use strict";t.d(v,{BV:()=>W,wv:()=>N});var e=t(8239),D=t(3722),f=t(2433),m=t(3860),p=t(6338),h=t(8415),d=t(6030),o=t(1530),n=t(62);class a{constructor(_,r){this.backendTimer=_,this.logger=r,null==r&&(this.logger=new i)}profileKernel(_,r,y){let x;const w=()=>{x=y()};let V;const et=o.now();if(this.backendTimer.timerAvailable())V=this.backendTimer.time(w);else{w();for(const F of x)F.dataSync();V=Promise.resolve({kernelMs:o.now()-et})}if((0,f.OB)().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let F=0;F<x.length;F++){const Y=x[F];Y.data().then(tt=>{c(tt,Y.dtype,_)})}return{kernelName:_,outputs:x,inputs:r,timeMs:V.then(F=>F.kernelMs),extraInfo:V.then(F=>null!=F.getExtraProfileInfo?F.getExtraProfileInfo():"")}}logKernelProfile(_){const{kernelName:r,outputs:y,timeMs:x,inputs:w,extraInfo:V}=_;y.forEach(et=>{Promise.all([et.data(),x,V]).then(U=>{this.logger.logKernelProfile(r,et,U[0],U[1],w,U[2])})})}}function c(T,_,r){if("float32"!==_)return!1;for(let y=0;y<T.length;y++){const x=T[y];if(isNaN(x)||!isFinite(x))return console.warn(`Found ${x} in the result of '${r}'`),!0}return!1}class i{logKernelProfile(_,r,y,x,w,V){const et="number"==typeof x?n.oj(`${x}ms`,9):x.error,U=n.oj(_,25),F=r.rank,Y=r.size,tt=n.oj(r.shape.toString(),14);let ot="";for(const ft in w){const gt=w[ft];if(null!=gt){const pt=gt.shape||r.shape,Pt=pt.length;ot+=`${ft}: ${Pt}D ${Pt>0?pt:""} `}}console.log(`%c${U}\t%c${et}\t%c${F}D ${tt}\t%c${Y}\t%c${ot}\t%c${V}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}var I=t(8106),S=t(7073);function K(T){return null!=T.kernelName}class z{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(_=>_.name)))}}}dispose(){for(const _ in this.registeredVariables)this.registeredVariables[_].dispose()}}let H=(()=>{class T{constructor(r){this.ENV=r,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new z}ready(){var r=this;return(0,e.Z)(function*(){if(null!=r.pendingBackendInit)return r.pendingBackendInit.then(()=>{});if(null!=r.backendInstance)return;const y=r.getSortedBackends();for(let x=0;x<y.length;x++){const w=y[x];if(yield r.initializeBackend(w).success)return void(yield r.setBackend(w))}throw new Error("Could not initialize any backends, all backend initializations failed.")})()}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:r,asyncInit:y}=this.initializeBackendsAndReturnBest();if(y)throw new Error(`The highest priority backend '${r}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(r)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(r){if(!(r in this.registry)){if(!(r in this.registryFactory))return null;{const{asyncInit:y}=this.initializeBackend(r);if(y)return null}}return this.registry[r]}findBackendFactory(r){return r in this.registryFactory?this.registryFactory[r].factory:null}registerBackend(r,y,x=1){return r in this.registryFactory?(d.Z(`${r} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[r]={factory:y,priority:x},!0)}setBackend(r){var y=this;return(0,e.Z)(function*(){if(null==y.registryFactory[r])throw new Error(`Backend name '${r}' not found in registry`);if(y.backendName=r,null==y.registry[r]){y.backendInstance=null;const{success:x,asyncInit:w}=y.initializeBackend(r);if(!(w?yield x:x))return!1}return y.backendInstance=y.registry[r],y.setupRegisteredKernels(),y.profiler=new a(y.backendInstance),!0})()}setupRegisteredKernels(){(0,h.tr)(this.backendName).forEach(y=>{null!=y.setupFunc&&y.setupFunc(this.backendInstance)})}disposeRegisteredKernels(r){(0,h.tr)(r).forEach(x=>{null!=x.disposeFunc&&x.disposeFunc(this.registry[r])})}initializeBackend(r){const y=this.registryFactory[r];if(null==y)throw new Error(`Cannot initialize backend ${r}, no registration found.`);try{const x=y.factory();if(!x||x instanceof D.Zu||"function"!=typeof x.then)return this.registry[r]=x,{success:!0,asyncInit:!1};{const w=++this.pendingBackendInitId,V=x.then(et=>!(w<this.pendingBackendInitId||(this.registry[r]=et,this.pendingBackendInit=null,0))).catch(et=>(w<this.pendingBackendInitId||(this.pendingBackendInit=null,d.Z(`Initialization of backend ${r} failed`),d.Z(et.stack||et.message)),!1));return this.pendingBackendInit=V,{success:V,asyncInit:!0}}}catch(x){return d.Z(`Initialization of backend ${r} failed`),d.Z(x.stack||x.message),{success:!1,asyncInit:!1}}}removeBackend(r){if(!(r in this.registryFactory))throw new Error(`${r} backend not found in registry`);this.backendName===r&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,r in this.registry&&(this.disposeRegisteredKernels(r),this.registry[r].dispose(),delete this.registry[r]),delete this.registryFactory[r],this.backendName===r&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((r,y)=>this.registryFactory[y].priority-this.registryFactory[r].priority)}initializeBackendsAndReturnBest(){const r=this.getSortedBackends();for(let y=0;y<r.length;y++){const x=r[y],{success:w,asyncInit:V}=this.initializeBackend(x);if(V||w)return{name:x,asyncInit:V}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(r,y){const x=this.state.tensorInfo.get(y),w=x.backend,V=this.readSync(y),et=w.refCount(y);w.disposeData(y,!0),x.backend=r,r.move(y,V,x.shape,x.dtype,et),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(r,y){let w,x=null;if(null==y){if("function"!=typeof r)throw new Error("Please provide a function to tidy()");y=r}else{if("string"!=typeof r&&!(r instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!=typeof y)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");x=r}return this.scopedRun(()=>this.startScope(x),()=>this.endScope(w),()=>(w=y(),w instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),w))}scopedRun(r,y,x){r();try{const w=x();return y(),w}catch(w){throw y(),w}}nextTensorId(){return T.nextTensorId++}nextVariableId(){return T.nextVariableId++}clone(r){const y=W.runKernel(p.iJz,{x:r});return this.addTapeNode(this.state.activeScope.name,{x:r},[y],et=>({x:()=>W.runKernel(p.RFZ,{x:et},{dtype:"float32"})}),[],{}),y}runKernel(r,y,x){if(null==(0,h.pI)(r,this.backendName))throw new Error(`Kernel '${r}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:r,inputs:y,attrs:x})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(r,y,x){const w=this.backend.numDataIds();let V=0;x.forEach(F=>{V+="complex64"===F.dtype?3:1});const U=w-y-V-this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];if(U>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${U} data ids) after running '${r}'`)}runKernelFunc(r){let y,x=[];const w=this.isTapeOn(),V=this.state.numBytes,et=this.state.numTensors;let U,F;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);const Y=K(r)?r.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(K(r)){const{kernelName:pt,inputs:Pt,attrs:Et}=r,Ct=(0,h.pI)(pt,this.backendName);n.hu(null!=Ct,()=>`Cannot find registered kernel '${pt}' for backend '${this.backendName}'`),U=()=>{const At=this.backend.numDataIds();F=Ct.kernelFunc({inputs:Pt,attrs:Et,backend:this.backend});const Ft=Array.isArray(F)?F:[F];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(pt,At,Ft);const Rt=Ft.map(Xt=>null!=Xt.rank?Xt:this.makeTensorFromTensorInfo(Xt));if(w){const Xt=this.getTensorsForGradient(pt,Pt,Rt);x=this.saveTensorsForBackwardMode(Xt)}return Rt}}else{const{forwardFunc:pt}=r,Pt=Et=>{w&&(x=Et.map(Ct=>this.keep(this.clone(Ct))))};U=()=>{const Et=this.backend.numDataIds();F=this.tidy(()=>pt(this.backend,Pt));const Ct=Array.isArray(F)?F:[F];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(Y,Et,Ct),Ct}}const{inputs:tt,attrs:ot}=r,ft=K(r)?null:r.backwardsFunc;let gt;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(gt=this.profiler.profileKernel(Y,tt,()=>U()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(gt),y=gt.outputs):y=U()}),w&&this.addTapeNode(Y,tt,y,ft,x,ot),this.state.profiling&&this.state.activeProfile.kernels.push({name:Y,bytesAdded:this.state.numBytes-V,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-et,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(tt).map(pt=>null!=tt[pt]?tt[pt].shape:null),outputShapes:y.map(pt=>pt.shape),kernelTimeMs:gt.timeMs,extraInfo:gt.extraInfo}),Array.isArray(F)?y:y[0]}saveTensorsForBackwardMode(r){return r.map(x=>this.keep(this.clone(x)))}getTensorsForGradient(r,y,x){const w=(0,h.uk)(r);if(null!=w){const V=w.inputsToSave||[],et=w.outputsToSave||[];let U;w.saveAllInputs?(n.hu(Array.isArray(y),()=>"saveAllInputs is true, expected inputs to be an array."),U=Object.keys(y).map(Y=>y[Y])):U=V.map(Y=>y[Y]);const F=x.filter((Y,tt)=>et[tt]);return U.concat(F)}return[]}makeTensor(r,y,x,w){if(null==r)throw new Error("Values passed to engine.makeTensor() are null");w=w||this.backend;let V=r;"string"===(x=x||"float32")&&n.HD(r[0])&&(V=r.map(F=>o.encodeString(F)));const et=w.write(V,y,x),U=new I.es(y,x,et,this.nextTensorId());if(this.trackTensor(U,w),"string"===x){const F=this.state.tensorInfo.get(et),Y=(0,n.Ub)(V);this.state.numBytes+=Y-F.bytes,F.bytes=Y}return U}makeTensorFromDataId(r,y,x,w){return this.makeTensorFromTensorInfo({dataId:r,shape:y,dtype:x=x||"float32"},w)}makeTensorFromTensorInfo(r,y){const{dataId:x,shape:w,dtype:V}=r,et=new I.es(w,V,x,this.nextTensorId());return this.trackTensor(et,y),et}makeVariable(r,y=!0,x,w){x=x||this.nextVariableId().toString(),null!=w&&w!==r.dtype&&(r=r.cast(w));const V=new I._w(r,y,x,this.nextTensorId());if(null!=this.state.registeredVariables[V.name])throw new Error(`Variable with name ${V.name} was already registered`);return this.state.registeredVariables[V.name]=V,this.incRef(V,this.backend),V}trackTensor(r,y){this.state.numTensors++,"string"===r.dtype&&this.state.numStringTensors++;let x=0;"complex64"!==r.dtype&&"string"!==r.dtype&&(x=r.size*n.bT(r.dtype)),this.state.numBytes+=x,this.state.tensorInfo.has(r.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(r.dataId,{backend:y||this.backend,dtype:r.dtype,shape:r.shape,bytes:x})),r instanceof I._w||this.track(r)}incRef(r,y){this.trackTensor(r,y),this.backend.incRef(r.dataId)}removeDataId(r,y){this.state.tensorInfo.has(r)&&this.state.tensorInfo.get(r).backend===y&&(this.state.tensorInfo.delete(r),this.state.numDataBuffers--)}disposeTensor(r){if(!this.state.tensorInfo.has(r.dataId))return;const y=this.state.tensorInfo.get(r.dataId);if(this.state.numTensors--,"string"===r.dtype&&(this.state.numStringTensors--,this.state.numBytes-=y.bytes),"complex64"!==r.dtype&&"string"!==r.dtype){const x=r.size*n.bT(r.dtype);this.state.numBytes-=x}y.backend.disposeData(r.dataId)&&this.removeDataId(r.dataId,y.backend)}disposeVariables(){for(const r in this.state.registeredVariables)this.disposeVariable(this.state.registeredVariables[r])}disposeVariable(r){this.disposeTensor(r),null!=this.state.registeredVariables[r.name]&&delete this.state.registeredVariables[r.name]}memory(){const r=this.backend.memory();return r.numTensors=this.state.numTensors,r.numDataBuffers=this.state.numDataBuffers,r.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(r.unreliable=!0,null==r.reasons&&(r.reasons=[]),r.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),r}profile(r){var y=this;return(0,e.Z)(function*(){y.state.profiling=!0;const x=y.state.numBytes,w=y.state.numTensors;y.state.activeProfile.kernels=[],y.state.activeProfile.result=yield r(),y.state.profiling=!1,y.state.activeProfile.peakBytes=Math.max(...y.state.activeProfile.kernels.map(V=>V.totalBytesSnapshot)),y.state.activeProfile.newBytes=y.state.numBytes-x,y.state.activeProfile.newTensors=y.state.numTensors-w;for(const V of y.state.activeProfile.kernels)V.kernelTimeMs=yield V.kernelTimeMs,V.extraInfo=yield V.extraInfo;return y.state.activeProfile})()}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(r,y,x,w,V,et){const U={id:this.state.nextTapeNodeId++,kernelName:r,inputs:y,outputs:x,saved:V},F=(0,h.uk)(r);null!=F&&(w=F.gradFunc),null!=w&&(U.gradient=Y=>(Y=Y.map((tt,ot)=>{if(null==tt){const ft=x[ot],gt=n.wT(ft.size,ft.dtype);return this.makeTensor(gt,ft.shape,ft.dtype)}return tt}),w(Y.length>1?Y:Y[0],V,et))),this.state.activeTape.push(U)}keep(r){return r.kept=!0,r}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(r){const y={track:[],name:"unnamed scope",id:this.state.nextScopeId++};r&&(y.name=r),this.state.scopeStack.push(y),this.state.activeScope=y}endScope(r){const y=(0,S.getTensorsInContainer)(r),x=new Set(y.map(V=>V.id));for(let V=0;V<this.state.activeScope.track.length;V++){const et=this.state.activeScope.track[V];!et.kept&&!x.has(et.id)&&et.dispose()}const w=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],y.forEach(V=>{!V.kept&&V.scopeId===w.id&&this.track(V)})}gradients(r,y,x,w=!1){if(n.hu(y.length>0,()=>"gradients() received an empty list of xs."),null!=x&&"float32"!==x.dtype)throw new Error(`dy must have 'float32' dtype, but has '${x.dtype}'`);const V=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",r));n.hu(V instanceof I.es,()=>"The result y returned by f() must be a tensor.");const et=function g(T,_,r){const y={},x={};for(let U=0;U<_.length;U++)y[_[U].id]=!0;for(let U=0;U<T.length;U++){const F=T[U],Y=F.inputs;for(const tt in Y){const ot=Y[tt];let ft=!1;for(let gt=0;gt<_.length;gt++)if(y[ot.id]){F.outputs.forEach(pt=>y[pt.id]=!0),ft=!0,x[F.id]=!0;break}if(ft)break}}const w={};w[r.id]=!0;const V={};for(let U=T.length-1;U>=0;U--){const F=T[U],Y=F.inputs;for(let tt=0;tt<F.outputs.length;tt++)if(w[F.outputs[tt].id]){for(const ot in Y)w[Y[ot].id]=!0,V[F.id]=!0;break}}const et=[];for(let U=0;U<T.length;U++){const F=T[U];if(x[F.id]&&V[F.id]){const Y={};for(const ot in F.inputs){const ft=F.inputs[ot];y[ft.id]&&(Y[ot]=ft)}const tt=Object.assign({},F);tt.inputs=Y,tt.outputs=F.outputs,et.push(tt)}}return et}(this.state.activeTape,y,V);if(!w&&0===et.length&&y.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const U={};U[V.id]=x??function ct(T){const _=(0,n.p8)((0,n.NA)(T),"float32");return W.makeTensor(_,T,"float32")}(V.shape),function C(T,_,r,y){for(let x=_.length-1;x>=0;x--){const w=_[x],V=[];if(w.outputs.forEach(U=>{const F=T[U.id];V.push(null!=F?F:null)}),null==w.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${w.kernelName}.`);const et=w.gradient(V);for(const U in w.inputs){if(!(U in et))throw new Error(`Cannot backprop through input ${U}. Available gradients found: ${Object.keys(et)}.`);const F=r(()=>et[U]());if("float32"!==F.dtype)throw new Error(`Error in gradient for op ${w.kernelName}. The gradient of input ${U} must have 'float32' dtype, but has '${F.dtype}'`);const Y=w.inputs[U];if(!n.cO(F.shape,Y.shape))throw new Error(`Error in gradient for op ${w.kernelName}. The gradient of input '${U}' has shape '${F.shape}', which does not match the shape of the input '${Y.shape}'`);if(null==T[Y.id])T[Y.id]=F;else{const tt=T[Y.id];T[Y.id]=y(tt,F),tt.dispose()}}}}(U,et,Y=>this.tidy(Y),k);const F=y.map(Y=>U[Y.id]);return 0===this.state.gradientDepth&&(this.state.activeTape.forEach(Y=>{for(const tt of Y.saved)tt.dispose()}),this.state.activeTape=null),{value:V,grads:F}})}customGrad(r){return n.hu(n.mf(r),()=>"The f passed in customGrad(f) must be a function."),(...y)=>{let x;n.hu(y.every(U=>U instanceof I.es),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");const w={};return y.forEach((U,F)=>{w[F]=U}),this.runKernelFunc({forwardFunc:(U,F)=>(x=r(...y,F),n.hu(x.value instanceof I.es,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),n.hu(n.mf(x.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),x.value),backwardsFunc:(U,F)=>{const Y=x.gradFunc(U,F),tt=Array.isArray(Y)?Y:[Y];n.hu(tt.length===y.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),n.hu(tt.every(ft=>ft instanceof I.es),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const ot={};return tt.forEach((ft,gt)=>{ot[gt]=()=>ft}),ot},inputs:w})}}readSync(r){return this.state.tensorInfo.get(r).backend.readSync(r)}read(r){return this.state.tensorInfo.get(r).backend.read(r)}readToGPU(r,y){return this.state.tensorInfo.get(r).backend.readToGPU(r,y)}time(r){var y=this;return(0,e.Z)(function*(){const x=(0,o.now)(),w=yield y.backend.time(r);return w.wallMs=(0,o.now)()-x,w})()}track(r){return null!=this.state.activeScope&&(r.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(r)),r}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new z;for(const r in this.registry)this.disposeRegisteredKernels(r),this.registry[r].dispose(),delete this.registry[r];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}return T.nextTensorId=0,T.nextVariableId=0,T})();function N(){const T=(0,m.D)();if(null==T._tfengine){const _=new f.qA(T);T._tfengine=new H(_)}return(0,f.iG)(T._tfengine.ENV),(0,I.Vi)(()=>T._tfengine),T._tfengine}const W=N();function k(T,_){return W.runKernel(p.mm_,{a:T,b:_})}},2433:(Q,v,t)=>{"use strict";t.d(v,{OB:()=>o,Vi:()=>n,iG:()=>a,qA:()=>m});var e=t(8239),D=t(62);const f="tfjsflags";class m{constructor(i){this.global=i,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=p,this.populateURLFlags()}setPlatform(i,g){null!=this.platform&&(o().getBool("IS_TEST")||o().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${i}.`)),this.platformName=i,this.platform=g}registerFlag(i,g,C){if(this.flagRegistry[i]={evaluationFn:g,setHook:C},null!=this.urlFlags[i]){const I=this.urlFlags[i];o().getBool("IS_TEST")||o().getBool("PROD")||console.warn(`Setting feature override from URL ${i}: ${I}.`),this.set(i,I)}}getAsync(i){var g=this;return(0,e.Z)(function*(){return i in g.flags||(g.flags[i]=yield g.evaluateFlag(i)),g.flags[i]})()}get(i){if(i in this.flags)return this.flags[i];const g=this.evaluateFlag(i);if((0,D.tI)(g))throw new Error(`Flag ${i} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[i]=g,this.flags[i]}getNumber(i){return this.get(i)}getBool(i){return this.get(i)}getString(i){return this.get(i)}getFlags(){return this.flags}get features(){return this.flags}set(i,g){if(null==this.flagRegistry[i])throw new Error(`Cannot set flag ${i} as it has not been registered.`);this.flags[i]=g,null!=this.flagRegistry[i].setHook&&this.flagRegistry[i].setHook(g)}evaluateFlag(i){if(null==this.flagRegistry[i])throw new Error(`Cannot evaluate flag '${i}': no evaluation function found.`);return this.flagRegistry[i].evaluationFn()}setFlags(i){this.flags=Object.assign({},i)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const i=this.getQueryParams(this.global.location.search);f in i&&i[f].split(",").forEach(C=>{const[I,S]=C.split(":");this.urlFlags[I]=function d(c,i){const g=i.toLowerCase();return"true"===g||"false"===g?"true"===g:""+ +g===g?+g:i}(0,S)})}}function p(c){const i={};return c.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(g,...C)=>(function h(c,i,g){c[decodeURIComponent(i)]=decodeURIComponent(g||"")}(i,C[0],C[1]),C.join("="))),i}function o(){return n}let n=null;function a(c){n=c}},3860:(Q,v,t)=>{"use strict";let e;function D(){if(null==e){let p;if(typeof window<"u")p=window;else if(typeof global<"u")p=global;else if(typeof process<"u")p=process;else{if(!(typeof self<"u"))throw new Error("Could not find a global object");p=self}e=p}return e}function m(p,h){const d=function f(){const p=D();return null==p._tfGlobals&&(p._tfGlobals=new Map),p._tfGlobals}();if(d.has(p))return d.get(p);{const o=h();return d.set(p,o),d.get(p)}}t.d(v,{D:()=>D,R:()=>m})},2133:(Q,v,t)=>{"use strict";t.d(v,{B9:()=>C,CQ:()=>K,Cd:()=>z,Cn:()=>I,G4:()=>p,MX:()=>o,N5:()=>i,N8:()=>n,N_:()=>H,R:()=>h,SR:()=>a,VY:()=>_,XV:()=>S,cF:()=>d,cj:()=>ct,jq:()=>k,lu:()=>g,sq:()=>c,x3:()=>N,y3:()=>T,ze:()=>W});var e=t(2882),D=t(2433),f=t(8106),m=t(7073);function p(){(0,D.OB)().set("PROD",!0)}function h(){(0,D.OB)().set("DEBUG",!0)}function d(){(0,D.OB)().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function o(r){(0,D.OB)().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function n(){e.BV.disposeVariables()}function a(){return e.BV}function c(){return e.BV.memory()}function i(r){return e.BV.profile(r)}function g(r,y){return e.BV.tidy(r,y)}function C(r){(0,m.getTensorsInContainer)(r).forEach(x=>x.dispose())}function I(r){return e.BV.keep(r)}function S(r){return e.BV.time(r)}function K(r){return e.BV.setBackend(r)}function z(){return e.BV.ready()}function H(){return e.BV.backendName}function ct(r){e.BV.removeBackend(r)}function N(r){return e.BV.findBackend(r)}function W(r){return e.BV.findBackendFactory(r)}function k(r,y,x=1){return e.BV.registerBackend(r,y,x)}function T(){return e.BV.backend}function _(r,y){(0,D.OB)().setPlatform(r,y)}(0,f.FZ)(o)},6921:(Q,v,t)=>{"use strict";t.d(v,{UQ:()=>p,cb:()=>a,fN:()=>o,h7:()=>d,pn:()=>n,ti:()=>h});var e=t(2882),D=t(8106),f=t(4810),m=t(62);function p(i){return m.hu(m.mf(i),()=>"The f passed in grad(f) must be a function"),(g,C)=>{const I=(0,f._1)(g,"x","tf.grad","string_or_numeric"),S=null!=C?(0,f._1)(C,"dy","tf.grad"):null;return e.BV.tidy(()=>{const{value:K,grads:z}=e.BV.gradients(()=>i(I),[I],S);return null!=S&&m.k5(K.shape,S.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),c(z),z[0]})}}function h(i){return m.hu(m.mf(i),()=>"The f passed in grads(f) must be a function"),(g,C)=>{m.hu(Array.isArray(g),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const I=(0,f.sI)(g,"args","tf.grads","string_or_numeric"),S=null!=C?(0,f._1)(C,"dy","tf.grads"):null;return e.BV.tidy(()=>{const{value:K,grads:z}=e.BV.gradients(()=>i(...I),I,S);return null!=S&&m.k5(K.shape,S.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),c(z),z})}}function d(i){return m.hu(m.mf(i),()=>"The f passed in valueAndGrad(f) must be a function"),(g,C)=>{m.hu(g instanceof D.es,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),m.hu(null==C||C instanceof D.es,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:I,value:S}=e.BV.gradients(()=>i(g),[g],C);return c(I),{grad:I[0],value:S}}}function o(i){return m.hu(m.mf(i),()=>"The f passed in valueAndGrads(f) must be a function"),(g,C)=>{m.hu(Array.isArray(g)&&g.every(S=>S instanceof D.es),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),m.hu(null==C||C instanceof D.es,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const I=e.BV.gradients(()=>i(...g),g,C);return null!=C&&m.k5(I.value.shape,C.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),c(I.grads),I}}function n(i,g){m.hu(m.mf(i),()=>"The f passed in variableGrads(f) must be a function"),m.hu(null==g||Array.isArray(g)&&g.every(N=>N instanceof D._w),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const C=null!=g;if(!C){g=[];for(const N in e.BV.registeredVariables)g.push(e.BV.registeredVariables[N])}const I=C?g.filter(N=>!N.trainable):null,S=g.length;g=g.filter(N=>N.trainable),m.hu(g.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${S} variables is trainable.`);const{value:z,grads:H}=e.BV.gradients(i,g,null,!0);m.hu(H.some(N=>null!=N),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),m.hu(0===z.rank,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${z.rank} tensor`);const ct={};return g.forEach((N,W)=>{null!=H[W]&&(ct[N.name]=H[W])}),I?.forEach(N=>ct[N.name]=null),{value:z,grads:ct}}function a(i){return e.BV.customGrad(i)}function c(i){if(i.filter(C=>null==C).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}},7575:(Q,v,t)=>{"use strict";t.r(v),t.d(v,{Abs:()=>J.SYM,Acos:()=>J.VGw,Acosh:()=>J.SpW,AdadeltaOptimizer:()=>se,AdagradOptimizer:()=>Ee,AdamOptimizer:()=>kn,AdamaxOptimizer:()=>ge,Add:()=>J.mm_,AddN:()=>J.Xze,All:()=>J.oT6,Any:()=>J.IKK,ArgMax:()=>J.sJF,ArgMin:()=>J.aJk,Asin:()=>J.M2y,Asinh:()=>J.qw7,Atan:()=>J.jMg,Atan2:()=>J.QCc,Atanh:()=>J.Oyi,AvgPool:()=>J.JhU,AvgPool3D:()=>J._k9,AvgPool3DGrad:()=>J.IMb,AvgPoolGrad:()=>J.ROF,BatchMatMul:()=>J.XLW,BatchToSpaceND:()=>J.zws,Bincount:()=>J.zvY,BitwiseAnd:()=>J.hCO,BroadcastArgs:()=>J.eEB,BroadcastTo:()=>J.Ly9,Cast:()=>J.RFZ,Ceil:()=>J.gJX,ClipByValue:()=>J.xnO,Complex:()=>J.Zz9,ComplexAbs:()=>J.yj2,Concat:()=>J.Eh3,Conv2D:()=>J.mhS,Conv2DBackpropFilter:()=>J.wUP,Conv2DBackpropInput:()=>J.wm,Conv3D:()=>J.x12,Conv3DBackpropFilterV2:()=>J.o2y,Conv3DBackpropInputV2:()=>J.ik2,Cos:()=>J.mc4,Cosh:()=>J.TR1,CropAndResize:()=>J.VcC,Cumprod:()=>J.Byc,Cumsum:()=>J.iHb,DataStorage:()=>ss.JL,DenseBincount:()=>J.QRR,DepthToSpace:()=>J.T0n,DepthwiseConv2dNative:()=>J.cie,DepthwiseConv2dNativeBackpropFilter:()=>J.sL$,DepthwiseConv2dNativeBackpropInput:()=>J.y7R,Diag:()=>J.$w,Dilation2D:()=>J.p4S,Dilation2DBackpropFilter:()=>J.Vn9,Dilation2DBackpropInput:()=>J.ekb,ENV:()=>K.Vi,Einsum:()=>J.$g6,Elu:()=>J.SX0,EluGrad:()=>J.HEU,Environment:()=>K.qA,Equal:()=>J.hdR,Erf:()=>J.Omj,Exp:()=>J.NEP,ExpandDims:()=>J.YFo,Expm1:()=>J.Y0y,FFT:()=>J.vwp,Fill:()=>J.deh,FlipLeftRight:()=>J.Uyb,Floor:()=>J.OR,FloorDiv:()=>J.jeX,FromPixels:()=>J.eBW,FusedBatchNorm:()=>J.sHE,FusedConv2D:()=>J._V0,FusedDepthwiseConv2D:()=>J.luS,GatherNd:()=>J.q1x,GatherV2:()=>J.qi_,Greater:()=>J.iZT,GreaterEqual:()=>J.Acj,IFFT:()=>J.Qg5,Identity:()=>J.iJz,Imag:()=>J.J_u,IsFinite:()=>J.avt,IsInf:()=>J.iWB,IsNan:()=>J.r7n,KernelBackend:()=>ss.Zu,LRN:()=>J.eZ0,LRNGrad:()=>J.Hhh,LeakyRelu:()=>J.J$2,Less:()=>J.vtC,LessEqual:()=>J.CAk,LinSpace:()=>J.e7N,Log:()=>J.ZbH,Log1p:()=>J.kU,LogSoftmax:()=>J.qCd,LogicalAnd:()=>J.PYm,LogicalNot:()=>J.VfG,LogicalOr:()=>J.MZg,LogicalXor:()=>J.w6g,LowerBound:()=>J.qIC,MatrixBandPart:()=>J.J7O,Max:()=>J.YoZ,MaxPool:()=>J.mTV,MaxPool3D:()=>J.OAf,MaxPool3DGrad:()=>J.OU7,MaxPoolGrad:()=>J.OV7,MaxPoolWithArgmax:()=>J.vFR,Maximum:()=>J.BMI,Mean:()=>J.q2K,Min:()=>J.c17,Minimum:()=>J.q8u,MirrorPad:()=>J.jQs,Mod:()=>J.Vbg,MomentumOptimizer:()=>_e,Multinomial:()=>J.NZg,Multiply:()=>J.wYn,Neg:()=>J.kuV,NonMaxSuppressionV3:()=>J.uv1,NonMaxSuppressionV4:()=>J.cye,NonMaxSuppressionV5:()=>J.W0H,NotEqual:()=>J.yQU,OP_SCOPE_SUFFIX:()=>j.zvA,OneHot:()=>J.we_,OnesLike:()=>J.qWM,Optimizer:()=>yn,OptimizerConstructors:()=>pr,Pack:()=>J.QiL,PadV2:()=>J.lyA,Pool:()=>J.Kgp,Pow:()=>J.pe_,Prelu:()=>J.o0g,Prod:()=>J.DlI,RMSPropOptimizer:()=>De,RaggedGather:()=>J.dDz,RaggedRange:()=>J.CQl,RaggedTensorToTensor:()=>J.BiW,Range:()=>J.e6w,Rank:()=>ns.yw,Real:()=>J.xJR,RealDiv:()=>J.oHH,Reciprocal:()=>J.$HU,Reduction:()=>Ur.I,Relu:()=>J.qkr,Relu6:()=>J.SbG,Reshape:()=>J.HZH,ResizeBilinear:()=>J._Yw,ResizeBilinearGrad:()=>J.zbQ,ResizeNearestNeighbor:()=>J.dpD,ResizeNearestNeighborGrad:()=>J.Hmb,Reverse:()=>J.mKl,RotateWithOffset:()=>J.b9H,Round:()=>J.e07,Rsqrt:()=>J.bV0,SGDOptimizer:()=>re,ScatterNd:()=>J.xQA,SearchSorted:()=>J.nr8,Select:()=>J.PhF,Selu:()=>J.oFR,Sigmoid:()=>J.a5O,Sign:()=>J.i5y,Sin:()=>J.RQH,Sinh:()=>J.wYB,Slice:()=>J.p2w,Softmax:()=>J.Gcp,Softplus:()=>J.MRv,SpaceToBatchND:()=>J.TQc,SparseFillEmptyRows:()=>J.O3z,SparseReshape:()=>J.nhH,SparseSegmentMean:()=>J.w3H,SparseSegmentSum:()=>J.ZjV,SparseToDense:()=>J.D2d,SplitV:()=>J.L8s,Sqrt:()=>J.FKq,Square:()=>J.bK0,SquaredDifference:()=>J._tC,StaticRegexReplace:()=>J.e0R,Step:()=>J.h8e,StridedSlice:()=>J.jQk,StringNGrams:()=>J._JP,StringSplit:()=>J.s1s,StringToHashBucketFast:()=>J.XkS,Sub:()=>J.Tr8,Sum:()=>J.GBy,Tan:()=>J.sEM,Tanh:()=>J.MIZ,Tensor:()=>In.es,TensorBuffer:()=>In.YD,TensorScatterUpdate:()=>J.SIB,Tile:()=>J.n9L,TopK:()=>J.cWu,Transform:()=>J.wx7,Transpose:()=>J.G3Y,Unique:()=>J.kpP,Unpack:()=>J.ToN,UnsortedSegmentSum:()=>J.Qvg,UpperBound:()=>J.XDQ,Variable:()=>In._w,ZerosLike:()=>J.RuY,_FusedMatMul:()=>J.usg,abs:()=>j.WnP,acos:()=>j.Khb,acosh:()=>j.__u,add:()=>j.IHx,addN:()=>j.QBD,all:()=>j.$6P,any:()=>j.YjB,argMax:()=>j.NqF,argMin:()=>j.vHJ,asin:()=>j.ZRM,asinh:()=>j.VfV,atan:()=>j.z4N,atan2:()=>j.fvJ,atanh:()=>j.C80,avgPool:()=>j.wS1,avgPool3d:()=>j.uR5,backend:()=>Ot.y3,backend_util:()=>n,basicLSTMCell:()=>j.zEQ,batchNorm:()=>j.tgs,batchNorm2d:()=>j.Dxk,batchNorm3d:()=>j.JY5,batchNorm4d:()=>j.p3b,batchToSpaceND:()=>j.E4h,bincount:()=>j.yE8,bitwiseAnd:()=>j.ycw,booleanMaskAsync:()=>j.anm,broadcastArgs:()=>j.XsQ,broadcastTo:()=>j.UFq,broadcast_util:()=>ie,browser:()=>p,buffer:()=>j.f3b,cast:()=>j.pju,ceil:()=>j.mDi,clipByValue:()=>j.iUl,clone:()=>j.d9v,complex:()=>j.PYB,concat:()=>j.zoF,concat1d:()=>j.gME,concat2d:()=>j.Izb,concat3d:()=>j.MNy,concat4d:()=>j.ZaL,conv1d:()=>j.PAt,conv2d:()=>j.Tek,conv2dTranspose:()=>j.bc,conv3d:()=>j.pdZ,conv3dTranspose:()=>j.$QV,copyRegisteredKernels:()=>Mn.T3,cos:()=>j.mCk,cosh:()=>j.f9Y,cosineWindow:()=>j.mew,cumprod:()=>j.$Gn,cumsum:()=>j.zbp,customGrad:()=>Sn.cb,denseBincount:()=>j.ppE,deprecationWarn:()=>Ot.MX,depthToSpace:()=>j.nTT,depthwiseConv2d:()=>j.B10,device_util:()=>e,diag:()=>j.Ka3,dilation2d:()=>j.WmZ,disableDeprecationWarnings:()=>Ot.cF,dispose:()=>Ot.B9,disposeVariables:()=>Ot.N8,div:()=>j.hiC,divNoNan:()=>j.NTj,dot:()=>j.AKD,dropout:()=>j.rvX,einsum:()=>j.WYO,elu:()=>j.pyx,enableDebugMode:()=>Ot.R,enableProdMode:()=>Ot.G4,enclosingPowerOfTwo:()=>j.GRh,engine:()=>Ot.SR,ensureShape:()=>j.EDe,env:()=>K.OB,equal:()=>j.DgJ,erf:()=>j.qNN,euclideanNorm:()=>j.d2q,exp:()=>j.Qqt,expandDims:()=>j.dt4,expm1:()=>j.t$B,eye:()=>j.iyy,fft:()=>j.kp_,fill:()=>j.hlL,findBackend:()=>Ot.x3,findBackendFactory:()=>Ot.ze,floor:()=>j.GWj,floorDiv:()=>j.qPi,fused:()=>j.imm,gather:()=>j.Iqj,gatherND:()=>j.dbB,gather_util:()=>h,getBackend:()=>Ot.N_,getGradient:()=>Mn.uk,getKernel:()=>Mn.pI,getKernelsForBackend:()=>Mn.tr,grad:()=>Sn.UQ,grads:()=>Sn.ti,greater:()=>j.pjt,greaterEqual:()=>j.brS,ifft:()=>j.Sxn,imag:()=>j.asL,image:()=>j.BHj,inTopKAsync:()=>j.V3u,io:()=>f,irfft:()=>j.wx0,isFinite:()=>j.xVT,isInf:()=>j.UWc,isNaN:()=>j.i2d,keep:()=>Ot.Cn,kernel_impls:()=>a,leakyRelu:()=>j.hi7,less:()=>j.d9m,lessEqual:()=>j.zN1,linalg:()=>j.$r2,linspace:()=>j.SX3,localResponseNormalization:()=>j.G9k,log:()=>j.cM7,log1p:()=>j.Krr,logSigmoid:()=>j.e_t,logSoftmax:()=>j.CmS,logSumExp:()=>j.l_t,logicalAnd:()=>j.HvI,logicalNot:()=>j.hJK,logicalOr:()=>j.K5V,logicalXor:()=>j.egP,losses:()=>j.MB5,lowerBound:()=>j.eab,matMul:()=>j.OI3,math:()=>m,max:()=>j.Fp7,maxPool:()=>j._sB,maxPool3d:()=>j.YQQ,maxPoolWithArgmax:()=>j.Ip$,maximum:()=>j.gWQ,mean:()=>j.J69,memory:()=>Ot.sq,meshgrid:()=>j.ry_,min:()=>j.VV$,minimum:()=>j.LTh,mirrorPad:()=>j.VdP,mod:()=>j.wQq,moments:()=>j.Gi7,movingAverage:()=>j.p_,mul:()=>j.dC7,multiRNNCell:()=>j.rq4,multinomial:()=>j.SJ_,neg:()=>j.W76,nextFrame:()=>Er,norm:()=>j.KOy,notEqual:()=>j.Quu,oneHot:()=>j.lfX,ones:()=>j.iUs,onesLike:()=>j.JpU,op:()=>j.op,outerProduct:()=>j.N2O,pad:()=>j.vku,pad1d:()=>j.pNR,pad2d:()=>j.koy,pad3d:()=>j.t1L,pad4d:()=>j.lGY,pool:()=>j.d_R,pow:()=>j.sQ3,prelu:()=>j.AL3,print:()=>j.S0v,prod:()=>j.WVs,profile:()=>Ot.N5,raggedGather:()=>j.$gW,raggedRange:()=>j.VT$,raggedTensorToTensor:()=>j.N89,rand:()=>j.TN_,randomGamma:()=>j.wzB,randomNormal:()=>j.nGf,randomStandardNormal:()=>j.ruB,randomUniform:()=>j.LGj,randomUniformInt:()=>j.pe5,range:()=>j.w6H,ready:()=>Ot.Cd,real:()=>j.kwC,reciprocal:()=>j.M25,registerBackend:()=>Ot.jq,registerGradient:()=>Mn.Li,registerKernel:()=>Mn.wC,relu:()=>j.UYe,relu6:()=>j.btT,removeBackend:()=>Ot.cj,reshape:()=>j.XLQ,reverse:()=>j.GYS,reverse1d:()=>j.SDf,reverse2d:()=>j.diP,reverse3d:()=>j.sx7,reverse4d:()=>j.mG2,rfft:()=>j.QEs,round:()=>j.NMM,rsqrt:()=>j.bp0,scalar:()=>j.iD$,scatterND:()=>j.snQ,scatter_util:()=>qe,searchSorted:()=>j.zcT,selu:()=>j.U8D,separableConv2d:()=>j.U_I,serialization:()=>D,setBackend:()=>Ot.CQ,setPlatform:()=>Ot.VY,setdiff1dAsync:()=>j.ODp,sigmoid:()=>j.XD2,sign:()=>j.Xxe,signal:()=>j.tdS,sin:()=>j.O$l,sinh:()=>j.R_K,slice:()=>j.tPi,slice1d:()=>j.jZU,slice2d:()=>j.SmN,slice3d:()=>j.CnO,slice4d:()=>j.p0P,slice_util:()=>fr,softmax:()=>j.XAC,softplus:()=>j.Wvh,spaceToBatchND:()=>j.fBT,sparse:()=>j.rVs,sparseToDense:()=>j.ers,spectral:()=>j.uN7,split:()=>j.Vl2,sqrt:()=>j._b3,square:()=>j.h62,squaredDifference:()=>j.$i,squeeze:()=>j.L9e,stack:()=>j.knu,step:()=>j.Nbs,stridedSlice:()=>j.NXj,string:()=>j.Z_8,sub:()=>j.luU,sum:()=>j.Smz,sumOutType:()=>ns.z4,tan:()=>j.ORZ,tanh:()=>j.AEp,tensor:()=>j.XeE,tensor1d:()=>j.RRF,tensor2d:()=>j.odF,tensor3d:()=>j.wOQ,tensor4d:()=>j.yXz,tensor5d:()=>j.Bfx,tensor6d:()=>j.xZs,tensorScatterUpdate:()=>j.Pg0,tensor_util:()=>Ar,test_util:()=>d,tidy:()=>Ot.lu,tile:()=>j.Gg6,time:()=>Ot.XV,topk:()=>j.hg7,train:()=>Kr,transpose:()=>j.p4s,truncatedNormal:()=>j.Xu6,unique:()=>j.Two,unregisterGradient:()=>Mn.bt,unregisterKernel:()=>Mn.nE,unsortedSegmentSum:()=>j.pUJ,unstack:()=>j.HHK,upcastType:()=>ns.x8,upperBound:()=>j.GaM,util:()=>on,valueAndGrad:()=>Sn.h7,valueAndGrads:()=>Sn.fN,variable:()=>j.VD$,variableGrads:()=>Sn.pn,version_core:()=>Wr,where:()=>j.arb,whereAsync:()=>j.itS,zeros:()=>j.lls,zerosLike:()=>j.P84});var e={};t.r(e),t.d(e,{isBrowser:()=>S,isMobile:()=>I,mockIsMobile:()=>C});var D={};t.r(D),t.d(D,{Serializable:()=>ee,SerializationMap:()=>Dn,registerClass:()=>Ve});var f={};t.r(f),t.d(f,{browserFiles:()=>Ss,browserHTTPRequest:()=>Xn,concatenateArrayBuffers:()=>F,copyModel:()=>vs,decodeWeights:()=>y,encodeWeights:()=>_,fromMemory:()=>bs,fromMemorySync:()=>Qe,getLoadHandlers:()=>G,getModelArtifactsForJSON:()=>ft,getModelArtifactsForJSONSync:()=>ot,getModelArtifactsInfoForJSON:()=>pt,getSaveHandlers:()=>ln,getWeightSpecs:()=>Pt,http:()=>Ie,isHTTPScheme:()=>Te,listModels:()=>Ds,loadWeights:()=>Ls,moveModel:()=>Ps,registerLoadRouter:()=>en,registerSaveRouter:()=>Xt,removeModel:()=>Ms,weightsLoaderFactory:()=>Xe,withSaveHandler:()=>Ns,withSaveHandlerSync:()=>ws});var m={};t.r(m),t.d(m,{confusionMatrix:()=>Gs});var p={};t.r(p),t.d(p,{fromPixels:()=>yr,fromPixelsAsync:()=>Ir,toPixels:()=>yo});var h={};t.r(h),t.d(h,{prepareAndValidate:()=>dr});var d={};t.r(d),t.d(d,{TEST_EPSILON_FLOAT16:()=>Zs,createVideoElement:()=>Lr,encodeStrings:()=>ts,expectArrayBuffersEqual:()=>Sr,expectArraysClose:()=>Rr,expectArraysEqual:()=>Cr,expectNumbersClose:()=>xr,expectPromiseToFail:()=>Js,expectValuesInRange:()=>$r,play:()=>Re,testEpsilon:()=>Qs});var o={};t.r(o),t.d(o,{collectGatherOpShapeInfo:()=>Or,computeOutShape:()=>Pr,segOpComputeOptimalWindowSize:()=>ir});var n={};t.r(n),t.d(n,{ERF_A1:()=>Yr,ERF_A2:()=>Jr,ERF_A3:()=>gr,ERF_A4:()=>_r,ERF_A5:()=>Dr,ERF_P:()=>Qr,PARALLELIZE_THRESHOLD:()=>nr,RowPartitionType:()=>zt,SELU_SCALE:()=>mr.$,SELU_SCALEALPHA:()=>mr.y,applyActivation:()=>An.QH,assertAndGetBroadcastShape:()=>ie.assertAndGetBroadcastShape,assertAxesAreInnerMostDims:()=>zn.lB,assertParamsConsistent:()=>Jt,assignToTypedArray:()=>to,axesAreInnerMostDims:()=>zn.YB,calculateShapes:()=>qe.calculateShapes,checkEinsumDimSizes:()=>so,checkPadOnDimRoundingMode:()=>vn.m,combineLocations:()=>zn.Vh,combineRaggedTensorToTensorShapes:()=>tr,complexWithEvenIndex:()=>Mr,complexWithOddIndex:()=>sr,computeConv2DInfo:()=>vn.Ix,computeConv3DInfo:()=>vn.jw,computeDefaultPad:()=>vn.aO,computeDilation2DInfo:()=>vn.Rf,computeOptimalWindowSize:()=>kr,computeOutAndReduceShapes:()=>zn.kz,computeOutShape:()=>Nr,computePool2DInfo:()=>vn.Xw,computePool3DInfo:()=>vn.pl,convertConv2DDataFormat:()=>vn.sl,decodeEinsumEquation:()=>xe,eitherStridesOrDilationsAreOne:()=>vn.jT,expandShapeToKeepDim:()=>zn.rv,exponent:()=>sn,exponents:()=>no,fromStringArrayToUint8:()=>Do,fromUint8ToStringArray:()=>_o,getAxesPermutation:()=>zn.Q3,getBroadcastDims:()=>ie.getBroadcastDims,getComplexWithIndex:()=>Ce,getEinsumComputePath:()=>ro,getEinsumPermutation:()=>eo,getFusedBiasGradient:()=>An.pf,getFusedDyActivation:()=>An.Fr,getImageCenter:()=>Gr,getInnerMostAxes:()=>zn.sY,getPermuted:()=>Hr,getRaggedRank:()=>Fr,getReductionAxes:()=>ie.getReductionAxes,getReshaped:()=>zr,getReshapedPermuted:()=>Xr,getRowPartitionTypesHelper:()=>wr,getSliceBeginCoords:()=>jr,getSliceSize:()=>Zr,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>io,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>lo,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>uo,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>fo,getSparseReshapeInputOutputMismatchErrorMessage:()=>po,getSparseReshapeInputOutputMultipleErrorMessage:()=>ar,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>co,getSparseReshapeNegativeOutputDimErrorMessage:()=>ho,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>go,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Eo,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Qn,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>mo,getUndoAxesPermutation:()=>zn.LJ,isIdentityPermutation:()=>oo,log:()=>es.c,mergeRealAndImagArrays:()=>er,prepareAndValidate:()=>dr,prepareSplitSize:()=>ao,segment_util:()=>o,shouldFuse:()=>An.uy,slice_util:()=>fr,splitRealAndImagArrays:()=>qr,stridesOrDilationsArePositive:()=>vn.U3,tupleValuesAreOne:()=>vn.I0,upcastType:()=>ns.x8,validateDefaultValueShape:()=>Vr,validateInput:()=>qe.validateInput,validateUpdateShape:()=>qe.validateUpdateShape,warn:()=>es.Z});var a={};t.r(a),t.d(a,{nonMaxSuppressionV3Impl:()=>$e.GP,nonMaxSuppressionV4Impl:()=>$e.qP,nonMaxSuppressionV5Impl:()=>$e.pA,whereImpl:()=>Mo.Z});var c=t(2882);let g;function C(u){g=u}function I(u){if(void 0!==g)return g;if(u||function i(){return typeof navigator<"u"&&null!=navigator}()){if(u||(u=navigator),"ReactNative"===u.product)return!0;const s=u.userAgent||u.vendor||(typeof window<"u"?window.opera:"");return s?/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(s)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(s.substr(0,4)):u.userAgentData&&u.userAgentData.mobile}return!1}function S(){return typeof window<"u"&&null!=window.document||typeof WorkerGlobalScope<"u"}var K=t(2433);const z=(0,K.OB)();z.registerFlag("DEBUG",()=>!1,u=>{u&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),z.registerFlag("IS_BROWSER",()=>S()),z.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),z.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),z.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),z.registerFlag("PROD",()=>!1),z.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>z.getBool("DEBUG")),z.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),z.registerFlag("IS_TEST",()=>!1),z.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>z.getBool("DEBUG")),z.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),z.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),z.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);var H=t(8239),ct=t(7401),N=t(5186),W=t(62);const k={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},T=4;function _(u,s){return r.apply(this,arguments)}function r(){return r=(0,H.Z)(function*(u,s){const l=[],E=[],A=Array.isArray(u)?u.map(Z=>Z.name):Object.keys(u);for(let Z=0;Z<A.length;++Z){const q=A[Z],at=Array.isArray(u)?u[Z].tensor:u[q];if("float32"!==at.dtype&&"int32"!==at.dtype&&"bool"!==at.dtype&&"string"!==at.dtype&&"complex64"!==at.dtype)throw new Error(`Unsupported dtype in weight '${q}': ${at.dtype}`);const lt={name:q,shape:at.shape,dtype:at.dtype};if("string"===at.dtype){const mt=new Promise(function(){var ut=(0,H.Z)(function*(Dt){const Mt=yield at.bytes(),Tt=Mt.reduce((kt,mn)=>kt+mn.length,0)+T*Mt.length,It=new Uint8Array(Tt);let Wt=0;for(let kt=0;kt<Mt.length;kt++){const mn=Mt[kt],gn=new Uint8Array(new Uint32Array([mn.length]).buffer);It.set(gn,Wt),Wt+=T,It.set(mn,Wt),Wt+=mn.length}Dt(It)});return function(Dt){return ut.apply(this,arguments)}}());E.push(mt)}else E.push(at.data());null!=s&&(lt.group=s),l.push(lt)}return{data:x(yield Promise.all(E)),specs:l}}),r.apply(this,arguments)}function y(u,s){const l={};let E,A=0;for(const b of s){const Z=b.name,q=b.dtype,at=b.shape,lt=(0,W.NA)(at);let mt;if("quantization"in b){const ut=b.quantization;if("uint8"===ut.dtype||"uint16"===ut.dtype){if(!("min"in ut)||!("scale"in ut))throw new Error(`Weight ${b.name} with quantization ${ut.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==ut.dtype)throw new Error(`Weight ${b.name} has unknown quantization dtype ${ut.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==q)throw new Error(`Weight ${b.name} is quantized with ${ut.dtype} which only supports weights of type float32 not ${q}.`)}const Dt=k[ut.dtype],Mt=u.slice(A,A+lt*Dt),Tt="uint8"===ut.dtype?new Uint8Array(Mt):new Uint16Array(Mt);if("float32"===q)if("uint8"===ut.dtype||"uint16"===ut.dtype){mt=new Float32Array(Tt.length);for(let It=0;It<Tt.length;It++)mt[It]=Tt[It]*ut.scale+ut.min}else{if("float16"!==ut.dtype)throw new Error(`Unsupported quantization type ${ut.dtype} for weight type float32.`);void 0===E&&(E=Ft()),mt=E(Tt)}else{if("int32"!==q)throw new Error(`Unsupported dtype in weight '${Z}': ${q}`);if("uint8"!==ut.dtype&&"uint16"!==ut.dtype)throw new Error(`Unsupported quantization type ${ut.dtype} for weight type int32.`);mt=new Int32Array(Tt.length);for(let It=0;It<Tt.length;It++)mt[It]=Math.round(Tt[It]*ut.scale+ut.min)}A+=lt*Dt}else if("string"===q){const ut=(0,W.NA)(b.shape);mt=[];for(let Dt=0;Dt<ut;Dt++){const Mt=new Uint32Array(u.slice(A,A+T))[0];A+=T;const Tt=new Uint8Array(u.slice(A,A+Mt));mt.push(Tt),A+=Mt}}else{const ut=k[q],Dt=u.slice(A,A+lt*ut);if("float32"===q)mt=new Float32Array(Dt);else if("int32"===q)mt=new Int32Array(Dt);else if("bool"===q)mt=new Uint8Array(Dt);else{if("complex64"!==q)throw new Error(`Unsupported dtype in weight '${Z}': ${q}`);{mt=new Float32Array(Dt);const Mt=new Float32Array(mt.length/2),Tt=new Float32Array(mt.length/2);for(let kt=0;kt<Mt.length;kt++)Mt[kt]=mt[2*kt],Tt[kt]=mt[2*kt+1];const It=(0,N.X)(Mt,at,"float32"),Wt=(0,N.X)(Tt,at,"float32");l[Z]=(0,ct.P)(It,Wt),It.dispose(),Wt.dispose()}}A+=lt*ut}"complex64"!==q&&(l[Z]=(0,N.X)(mt,at,q))}return l}function x(u){if(null===u)throw new Error(`Invalid input value: ${JSON.stringify(u)}`);let s=0;const l=[];u.forEach(b=>{if(s+=b.byteLength,l.push(b.byteLength===b.buffer.byteLength?b:new b.constructor(b)),!(b instanceof Float32Array||b instanceof Int32Array||b instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${b.constructor.name}`)});const E=new Uint8Array(s);let A=0;return l.forEach(b=>{E.set(new Uint8Array(b.buffer),A),A+=b.byteLength}),E.buffer}const w=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function V(u){return w?Buffer.byteLength(u):new Blob([u]).size}function F(u){if(1===u.length)return u[0];let s=0;u.forEach(A=>{s+=A.byteLength});const l=new Uint8Array(s);let E=0;return u.forEach(A=>{l.set(new Uint8Array(A),E),E+=A.byteLength}),l.buffer}function Y(u){for(u=u.trim();u.endsWith("/");)u=u.slice(0,u.length-1);const l=u.split("/");return l[l.length-1]}function tt(u,s){const l={modelTopology:u.modelTopology,format:u.format,generatedBy:u.generatedBy,convertedBy:u.convertedBy,weightsManifest:s};return null!=u.signature&&(l.signature=u.signature),null!=u.userDefinedMetadata&&(l.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(l.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(l.initializerSignature=u.initializerSignature),null!=u.trainingConfig&&(l.trainingConfig=u.trainingConfig),l}function ot(u,s,l){const E={modelTopology:u.modelTopology,format:u.format,generatedBy:u.generatedBy,convertedBy:u.convertedBy};if(null!=u.trainingConfig&&(E.trainingConfig=u.trainingConfig),null!=u.weightsManifest){if(!s)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!l)throw new Error("modelJSON has weightsManifest but weightData is null");E.weightSpecs=s,E.weightData=l}return null!=u.signature&&(E.signature=u.signature),null!=u.userDefinedMetadata&&(E.userDefinedMetadata=u.userDefinedMetadata),null!=u.modelInitializer&&(E.modelInitializer=u.modelInitializer),null!=u.initializerSignature&&(E.initializerSignature=u.initializerSignature),E}function ft(u,s){return gt.apply(this,arguments)}function gt(){return(gt=(0,H.Z)(function*(u,s){let l,E;return null!=u.weightsManifest&&([l,E]=yield s(u.weightsManifest)),ot(u,l,E)})).apply(this,arguments)}function pt(u){if(u.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==u.modelTopology?0:V(JSON.stringify(u.modelTopology)),weightSpecsBytes:null==u.weightSpecs?0:V(JSON.stringify(u.weightSpecs)),weightDataBytes:null==u.weightData?0:u.weightData.byteLength}}function Pt(u){const s=[];for(const l of u)s.push(...l.weights);return s}function Ft(){const u=function Et(){const u=l=>{let E=l<<13,A=0;for(;!(8388608&E);)A-=8388608,E<<=1;return E&=-8388609,A+=947912704,E|A},s=new Uint32Array(2048);s[0]=0;for(let l=1;l<1024;l++)s[l]=u(l);for(let l=1024;l<2048;l++)s[l]=939524096+(l-1024<<13);return s}(),s=function Ct(){const u=new Uint32Array(64);u[0]=0,u[31]=1199570944,u[32]=2147483648,u[63]=3347054592;for(let s=1;s<31;s++)u[s]=s<<23;for(let s=33;s<63;s++)u[s]=2147483648+(s-32<<23);return u}(),l=function At(){const u=new Uint32Array(64);for(let s=0;s<64;s++)u[s]=1024;return u[0]=u[32]=0,u}();return E=>{const A=new ArrayBuffer(4*E.length),b=new Uint32Array(A);for(let Z=0;Z<E.length;Z++){const q=E[Z];b[Z]=u[l[q>>10]+(1023&q)]+s[q>>10]}return new Float32Array(A)}}class Rt{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Rt.instance&&(Rt.instance=new Rt),Rt.instance}static registerSaveRouter(s){Rt.getInstance().saveRouters.push(s)}static registerLoadRouter(s){Rt.getInstance().loadRouters.push(s)}static getSaveHandlers(s){return Rt.getHandlers(s,"save")}static getLoadHandlers(s,l){return Rt.getHandlers(s,"load",l)}static getHandlers(s,l,E){const A=[];return("load"===l?Rt.getInstance().loadRouters:Rt.getInstance().saveRouters).forEach(Z=>{const q=Z(s,E);null!==q&&A.push(q)}),A}}const Xt=u=>Rt.registerSaveRouter(u),en=u=>Rt.registerLoadRouter(u),ln=u=>Rt.getSaveHandlers(u),G=(u,s)=>Rt.getLoadHandlers(u,s),st="tensorflowjs",_t="models_store",Bt="model_info_store";function Vt(){if(!(0,K.OB)().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const u=typeof window>"u"?self:window,s=u.indexedDB||u.mozIndexedDB||u.webkitIndexedDB||u.msIndexedDB||u.shimIndexedDB;if(null==s)throw new Error("The current browser does not appear to support IndexedDB.");return s}function rn(u){const s=u.result;s.createObjectStore(_t,{keyPath:"modelPath"}),s.createObjectStore(Bt,{keyPath:"modelPath"})}let Tn=(()=>{class u{constructor(l){if(this.indexedDB=Vt(),null==l||!l)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=l}save(l){var E=this;return(0,H.Z)(function*(){if(l.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return E.databaseAction(E.modelPath,l)})()}load(){var l=this;return(0,H.Z)(function*(){return l.databaseAction(l.modelPath)})()}databaseAction(l,E){return new Promise((A,b)=>{const Z=this.indexedDB.open(st,1);Z.onupgradeneeded=()=>rn(Z),Z.onsuccess=()=>{const q=Z.result;if(null==E){const at=q.transaction(_t,"readonly"),mt=at.objectStore(_t).get(this.modelPath);mt.onsuccess=()=>{if(null==mt.result)return q.close(),b(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));A(mt.result.modelArtifacts)},mt.onerror=ut=>(q.close(),b(mt.error)),at.oncomplete=()=>q.close()}else{const at=pt(E),lt=q.transaction(Bt,"readwrite");let ut,Dt,mt=lt.objectStore(Bt);try{ut=mt.put({modelPath:this.modelPath,modelArtifactsInfo:at})}catch(Mt){return b(Mt)}ut.onsuccess=()=>{Dt=q.transaction(_t,"readwrite");const Mt=Dt.objectStore(_t);let Tt;try{Tt=Mt.put({modelPath:this.modelPath,modelArtifacts:E,modelArtifactsInfo:at})}catch(It){return b(It)}Tt.onsuccess=()=>A({modelArtifactsInfo:at}),Tt.onerror=It=>{mt=lt.objectStore(Bt);const Wt=mt.delete(this.modelPath);Wt.onsuccess=()=>(q.close(),b(Tt.error)),Wt.onerror=kt=>(q.close(),b(Tt.error))}},ut.onerror=Mt=>(q.close(),b(ut.error)),lt.oncomplete=()=>{null==Dt?q.close():Dt.oncomplete=()=>q.close()}}},Z.onerror=q=>b(Z.error)})}}return u.URL_SCHEME="indexeddb://",u})();const Se=u=>(0,K.OB)().getBool("IS_BROWSER")&&!Array.isArray(u)&&u.startsWith(Tn.URL_SCHEME)?function us(u){return new Tn(u)}(u.slice(Tn.URL_SCHEME.length)):null;Rt.registerSaveRouter(Se),Rt.registerLoadRouter(Se);class hs{constructor(){this.indexedDB=Vt()}listModels(){var s=this;return(0,H.Z)(function*(){return new Promise((l,E)=>{const A=s.indexedDB.open(st,1);A.onupgradeneeded=()=>rn(A),A.onsuccess=()=>{const b=A.result,Z=b.transaction(Bt,"readonly"),at=Z.objectStore(Bt).getAll();at.onsuccess=()=>{const lt={};for(const mt of at.result)lt[mt.modelPath]=mt.modelArtifactsInfo;l(lt)},at.onerror=lt=>(b.close(),E(at.error)),Z.oncomplete=()=>b.close()},A.onerror=b=>E(A.error)})})()}removeModel(s){var l=this;return(0,H.Z)(function*(){return s=function cs(u){return u.startsWith(Tn.URL_SCHEME)?u.slice(Tn.URL_SCHEME.length):u}(s),new Promise((E,A)=>{const b=l.indexedDB.open(st,1);b.onupgradeneeded=()=>rn(b),b.onsuccess=()=>{const Z=b.result,q=Z.transaction(Bt,"readwrite"),at=q.objectStore(Bt),lt=at.get(s);let mt;lt.onsuccess=()=>{if(null==lt.result)return Z.close(),A(new Error(`Cannot find model with path '${s}' in IndexedDB.`));{const ut=at.delete(s),Dt=()=>{mt=Z.transaction(_t,"readwrite");const Tt=mt.objectStore(_t).delete(s);Tt.onsuccess=()=>E(lt.result.modelArtifactsInfo),Tt.onerror=It=>A(lt.error)};ut.onsuccess=Dt,ut.onerror=Mt=>(Dt(),Z.close(),A(lt.error))}},lt.onerror=ut=>(Z.close(),A(lt.error)),q.oncomplete=()=>{null==mt?Z.close():mt.oncomplete=()=>Z.close()}},b.onerror=Z=>A(b.error)})})()}}const fn="/",xn="tensorflowjs_models",ue="info",ds="model_topology",fs="weight_specs",ps="weight_data",Es="model_metadata";function Le(u){return{info:[xn,u,ue].join(fn),topology:[xn,u,ds].join(fn),weightSpecs:[xn,u,fs].join(fn),weightData:[xn,u,ps].join(fn),modelMetadata:[xn,u,Es].join(fn)}}function We(u){for(const s of Object.values(u))window.localStorage.removeItem(s)}function Ue(u){const s=u.split(fn);if(s.length<3)throw new Error(`Invalid key format: ${u}`);return s.slice(1,s.length-1).join(fn)}let Nn=(()=>{class u{constructor(l){if(!(0,K.OB)().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==l||!l)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=l,this.keys=Le(this.modelPath)}save(l){var E=this;return(0,H.Z)(function*(){if(l.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const A=JSON.stringify(l.modelTopology),b=JSON.stringify(l.weightSpecs),Z=pt(l);try{return E.LS.setItem(E.keys.info,JSON.stringify(Z)),E.LS.setItem(E.keys.topology,A),E.LS.setItem(E.keys.weightSpecs,b),E.LS.setItem(E.keys.weightData,function et(u){if(w)return Buffer.from(u).toString("base64");const s=new Uint8Array(u);let l="";for(let E=0,A=s.length;E<A;E++)l+=String.fromCharCode(s[E]);return btoa(l)}(l.weightData)),E.LS.setItem(E.keys.modelMetadata,JSON.stringify({format:l.format,generatedBy:l.generatedBy,convertedBy:l.convertedBy,signature:null!=l.signature?l.signature:void 0,userDefinedMetadata:null!=l.userDefinedMetadata?l.userDefinedMetadata:void 0,modelInitializer:null!=l.modelInitializer?l.modelInitializer:void 0,initializerSignature:null!=l.initializerSignature?l.initializerSignature:void 0,trainingConfig:null!=l.trainingConfig?l.trainingConfig:void 0})),{modelArtifactsInfo:Z}}catch{throw We(E.keys),new Error(`Failed to save model '${E.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${Z.modelTopologyBytes}, weightSpecsBytes=${Z.weightSpecsBytes}, weightDataBytes=${Z.weightDataBytes}.`)}}})()}load(){var l=this;return(0,H.Z)(function*(){const E=JSON.parse(l.LS.getItem(l.keys.info));if(null==E)throw new Error(`In local storage, there is no model with name '${l.modelPath}'`);if("JSON"!==E.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const A={},b=JSON.parse(l.LS.getItem(l.keys.topology));if(null==b)throw new Error(`In local storage, the topology of model '${l.modelPath}' is missing.`);A.modelTopology=b;const Z=JSON.parse(l.LS.getItem(l.keys.weightSpecs));if(null==Z)throw new Error(`In local storage, the weight specs of model '${l.modelPath}' are missing.`);A.weightSpecs=Z;const q=l.LS.getItem(l.keys.modelMetadata);if(null!=q){const lt=JSON.parse(q);A.format=lt.format,A.generatedBy=lt.generatedBy,A.convertedBy=lt.convertedBy,null!=lt.signature&&(A.signature=lt.signature),null!=lt.userDefinedMetadata&&(A.userDefinedMetadata=lt.userDefinedMetadata),null!=lt.modelInitializer&&(A.modelInitializer=lt.modelInitializer),null!=lt.initializerSignature&&(A.initializerSignature=lt.initializerSignature),null!=lt.trainingConfig&&(A.trainingConfig=lt.trainingConfig)}const at=l.LS.getItem(l.keys.weightData);if(null==at)throw new Error(`In local storage, the binary weight values of model '${l.modelPath}' are missing.`);return A.weightData=function U(u){if(w){const E=Buffer.from(u,"base64");return E.buffer.slice(E.byteOffset,E.byteOffset+E.byteLength)}const s=atob(u),l=new Uint8Array(s.length);for(let E=0;E<s.length;++E)l.set([s.charCodeAt(E)],E);return l.buffer}(at),A})()}}return u.URL_SCHEME="localstorage://",u})();const Ke=u=>(0,K.OB)().getBool("IS_BROWSER")&&!Array.isArray(u)&&u.startsWith(Nn.URL_SCHEME)?function gs(u){return new Nn(u)}(u.slice(Nn.URL_SCHEME.length)):null;Rt.registerSaveRouter(Ke),Rt.registerLoadRouter(Ke);class _s{constructor(){(0,W.hu)((0,K.OB)().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),(0,W.hu)(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}listModels(){var s=this;return(0,H.Z)(function*(){const l={},E=xn+fn,A=fn+ue;for(let b=0;b<s.LS.length;++b){const Z=s.LS.key(b);Z.startsWith(E)&&Z.endsWith(A)&&(l[Ue(Z)]=JSON.parse(s.LS.getItem(Z)))}return l})()}removeModel(s){var l=this;return(0,H.Z)(function*(){const E=Le(s=function ms(u){return u.startsWith(Nn.URL_SCHEME)?u.slice(Nn.URL_SCHEME.length):u}(s));if(null==l.LS.getItem(E.info))throw new Error(`Cannot find model at path '${s}'`);const A=JSON.parse(l.LS.getItem(E.info));return We(E),A})()}}const $n="://";class tn{constructor(){this.managers={}}static getInstance(){return null==tn.instance&&(tn.instance=new tn),tn.instance}static registerManager(s,l){(0,W.hu)(null!=s,()=>"scheme must not be undefined or null."),s.endsWith($n)&&(s=s.slice(0,s.indexOf($n))),(0,W.hu)(s.length>0,()=>"scheme must not be an empty string.");const E=tn.getInstance();(0,W.hu)(null==E.managers[s],()=>`A model store manager is already registered for scheme '${s}'.`),E.managers[s]=l}static getManager(s){const l=tn.getInstance().managers[s];if(null==l)throw new Error(`Cannot find model manager for scheme '${s}'`);return l}static getSchemes(){return Object.keys(tn.getInstance().managers)}}function qn(u){if(-1===u.indexOf($n))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${tn.getSchemes().join(",")}`);return{scheme:u.split($n)[0],path:u.split($n)[1]}}function be(u,s){return Yt.apply(this,arguments)}function Yt(){return(Yt=(0,H.Z)(function*(u,s,l=!1){(0,W.hu)(u!==s,()=>`Old path and new path are the same: '${u}'`);const E=Rt.getLoadHandlers(u);(0,W.hu)(E.length>0,()=>`Copying failed because no load handler is found for source URL ${u}.`),(0,W.hu)(E.length<2,()=>`Copying failed because more than one (${E.length}) load handlers for source URL ${u}.`);const A=E[0],b=Rt.getSaveHandlers(s);(0,W.hu)(b.length>0,()=>`Copying failed because no save handler is found for destination URL ${s}.`),(0,W.hu)(b.length<2,()=>`Copying failed because more than one (${E.length}) save handlers for destination URL ${s}.`);const Z=b[0],q=qn(u).scheme,at=qn(u).path,lt=q===qn(u).scheme,mt=yield A.load();l&&lt&&(yield tn.getManager(q).removeModel(at));const ut=yield Z.save(mt);return l&&!lt&&(yield tn.getManager(q).removeModel(at)),ut.modelArtifactsInfo})).apply(this,arguments)}function Ds(){return ce.apply(this,arguments)}function ce(){return(ce=(0,H.Z)(function*(){const u=tn.getSchemes(),s={};for(const l of u){const E=yield tn.getManager(l).listModels();for(const A in E)s[l+$n+A]=E[A]}return s})).apply(this,arguments)}function Ms(u){return he.apply(this,arguments)}function he(){return(he=(0,H.Z)(function*(u){const s=qn(u);return tn.getManager(s.scheme).removeModel(s.path)})).apply(this,arguments)}function vs(u,s){return de.apply(this,arguments)}function de(){return(de=(0,H.Z)(function*(u,s){return be(u,s,!1)})).apply(this,arguments)}function Ps(u,s){return fe.apply(this,arguments)}function fe(){return(fe=(0,H.Z)(function*(u,s){return be(u,s,!0)})).apply(this,arguments)}var Os=t(7517);class Ts{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(s,l){return fetch(s,l)}now(){return performance.now()}encode(s,l){if("utf-8"!==l&&"utf8"!==l)throw new Error(`Browser's encoder only supports utf-8, but got ${l}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(s)}decode(s,l){return new TextDecoder(l).decode(s)}setTimeoutCustom(s,l){typeof window>"u"||!(0,K.OB)().getBool("USE_SETTIMEOUTCUSTOM")?setTimeout(s,l):(this.functionRefs.push(s),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},l),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",E=>{E.source===window&&E.data.name===this.messageName&&(E.stopPropagation(),(0,this.functionRefs[E.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0))},!0)))}isTypedArray(s){return(0,Os.j)(s)}}if((0,K.OB)().get("IS_BROWSER")){(0,K.OB)().setPlatform("browser",new Ts);try{tn.registerManager(Nn.URL_SCHEME,new _s)}catch{}try{tn.registerManager(Tn.URL_SCHEME,new hs)}catch{}}let un;(0,K.OB)().get("IS_NODE")&&!(0,K.OB)().get("IS_BROWSER")&&(0,K.OB)().setPlatform("node",new class Ne{constructor(){this.util=t(8628),this.textEncoder=new this.util.TextEncoder}fetch(s,l){return null!=(0,K.OB)().global.fetch?(0,K.OB)().global.fetch(s,l):(null==un&&(un=t(5410)),un(s,l))}now(){const s=process.hrtime();return 1e3*s[0]+s[1]/1e6}encode(s,l){if("utf-8"!==l&&"utf8"!==l)throw new Error(`Node built-in encoder only supports utf-8, but got ${l}`);return this.textEncoder.encode(s)}decode(s,l){return 0===s.length?"":new this.util.TextDecoder(l).decode(s)}isTypedArray(s){return this.util.types.isFloat32Array(s)||this.util.types.isInt32Array(s)||this.util.types.isUint8Array(s)||this.util.types.isUint8ClampedArray(s)}});var pe=t(4062),wn=t(4879),Is=t(7871),we=t(5514),In=t(8106);(0,c.wv)(),(0,In.Vp)({buffer:pe.f,cast:wn.p,clone:Is.d,print:we.S});var Ot=t(2133),bt=t(319),pn=t(8366),xt=t(1300),Fn=t(6900),_n=t(4463),cn=t(9314),Sn=t(6921),Ln=t(8153);class ee{getClassName(){return this.constructor.className}static fromConfig(s,l){return new s(l)}}class Dn{constructor(){this.classNameMap={}}static getMap(){return null==Dn.instance&&(Dn.instance=new Dn),Dn.instance}static register(s){Dn.getMap().classNameMap[s.className]=[s,s.fromConfig]}}function Ve(u){(0,W.hu)(null!=u.className,()=>"Class being registered does not have the static className property defined."),(0,W.hu)("string"==typeof u.className,()=>"className is required to be a string, but got type "+typeof u.className),(0,W.hu)(u.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Dn.register(u)}class yn extends ee{minimize(s,l=!1,E){const{value:A,grads:b}=this.computeGradients(s,E);if(null!=E){const Z=E.map(q=>({name:q.name,tensor:b[q.name]}));this.applyGradients(Z)}else this.applyGradients(b);return(0,Ot.B9)(b),l?A:(A.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(s,l){return(0,Sn.pn)(s,l)}dispose(){null!=this.iterations_&&(0,Ot.B9)(this.iterations_)}saveIterations(){var s=this;return(0,H.Z)(function*(){return null==s.iterations_&&(s.iterations_=0),{name:"iter",tensor:(0,Ln.i)(s.iterations_,"int32")}})()}getWeights(){return(0,H.Z)(function*(){throw new Error("getWeights() is not implemented for this optimizer yet.")})()}setWeights(s){var l=this;return(0,H.Z)(function*(){throw new Error(`setWeights() is not implemented for this optimizer class ${l.getClassName()}`)})()}extractIterations(s){var l=this;return(0,H.Z)(function*(){return l.iterations_=(yield s[0].tensor.data())[0],s.slice(1)})()}}Object.defineProperty(yn,Symbol.hasInstance,{value:u=>null!=u.minimize&&null!=u.computeGradients&&null!=u.applyGradients});class se extends yn{static get className(){return"Adadelta"}constructor(s,l,E=null){super(),this.learningRate=s,this.rho=l,this.epsilon=E,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==E&&(this.epsilon=c.BV.backend.epsilon())}applyGradients(s){(Array.isArray(s)?s.map(E=>E.name):Object.keys(s)).forEach((E,A)=>{const b=c.BV.registeredVariables[E];null==this.accumulatedGrads[A]&&(this.accumulatedGrads[A]={originalName:`${E}/accum_grad`,variable:(0,Ot.lu)(()=>(0,cn.P)(b).variable(!1))}),null==this.accumulatedUpdates[A]&&(this.accumulatedUpdates[A]={originalName:`${E}/accum_var`,variable:(0,Ot.lu)(()=>(0,cn.P)(b).variable(!1))});const q=Array.isArray(s)?s[A].tensor:s[E];if(null==q)return;const at=this.accumulatedGrads[A].variable,lt=this.accumulatedUpdates[A].variable;(0,Ot.lu)(()=>{const mt=(0,bt.I)((0,xt.d)(at,this.rho),(0,xt.d)((0,_n.h)(q),1-this.rho)),ut=(0,xt.d)((0,pn.h)((0,Fn._)((0,bt.I)(lt,this.epsilon)),(0,Fn._)((0,bt.I)(at,this.epsilon))),q),Dt=(0,bt.I)((0,xt.d)(lt,this.rho),(0,xt.d)((0,_n.h)(ut),1-this.rho));at.assign(mt),lt.assign(Dt);const Mt=(0,bt.I)((0,xt.d)(ut,-this.learningRate),b);b.assign(Mt)})}),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&((0,Ot.B9)(this.accumulatedGrads.map(s=>s.variable)),(0,Ot.B9)(this.accumulatedUpdates.map(s=>s.variable)))}getWeights(){var s=this;return(0,H.Z)(function*(){const l=[...s.accumulatedGrads,...s.accumulatedUpdates];return[yield s.saveIterations()].concat(l.map(E=>({name:E.originalName,tensor:E.variable})))})()}setWeights(s){var l=this;return(0,H.Z)(function*(){const E=(s=yield l.extractIterations(s)).length/2;l.accumulatedGrads=s.slice(0,E).map(b=>({originalName:b.name,variable:b.tensor.variable(!1)})),l.accumulatedUpdates=s.slice(E,2*E).map(b=>({originalName:b.name,variable:b.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(s,l){return new s(l.learningRate,l.rho,l.epsilon)}}var ke=t(7237);class Ee extends yn{static get className(){return"Adagrad"}constructor(s,l=.1){super(),this.learningRate=s,this.initialAccumulatorValue=l,this.accumulatedGrads=[]}applyGradients(s){(Array.isArray(s)?s.map(E=>E.name):Object.keys(s)).forEach((E,A)=>{const b=c.BV.registeredVariables[E];null==this.accumulatedGrads[A]&&(this.accumulatedGrads[A]={originalName:`${E}/accumulator`,variable:(0,Ot.lu)(()=>(0,ke.h)(b.shape,this.initialAccumulatorValue).variable(!1))});const Z=Array.isArray(s)?s[A].tensor:s[E];if(null==Z)return;const q=this.accumulatedGrads[A].variable;(0,Ot.lu)(()=>{const at=(0,bt.I)(q,(0,_n.h)(Z));q.assign(at);const lt=(0,bt.I)((0,xt.d)((0,pn.h)(Z,(0,Fn._)((0,bt.I)(at,c.BV.backend.epsilon()))),-this.learningRate),b);b.assign(lt)})}),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&(0,Ot.B9)(this.accumulatedGrads.map(s=>s.variable))}getWeights(){var s=this;return(0,H.Z)(function*(){return[yield s.saveIterations()].concat(s.accumulatedGrads.map(l=>({name:l.originalName,tensor:l.variable})))})()}setWeights(s){var l=this;return(0,H.Z)(function*(){s=yield l.extractIterations(s),l.accumulatedGrads=s.map(A=>({originalName:A.name,variable:A.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(s,l){return new s(l.learningRate,l.initialAccumulatorValue)}}var Ge=t(2293),Vn=t(3217);class kn extends yn{static get className(){return"Adam"}constructor(s,l,E,A=null){super(),this.learningRate=s,this.beta1=l,this.beta2=E,this.epsilon=A,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],(0,Ot.lu)(()=>{this.accBeta1=(0,Ln.i)(l).variable(),this.accBeta2=(0,Ln.i)(E).variable()}),null==A&&(this.epsilon=c.BV.backend.epsilon())}applyGradients(s){const l=Array.isArray(s)?s.map(E=>E.name):Object.keys(s);(0,Ot.lu)(()=>{const E=(0,Vn.l)(1,this.accBeta1),A=(0,Vn.l)(1,this.accBeta2);l.forEach((b,Z)=>{const q=c.BV.registeredVariables[b];null==this.accumulatedFirstMoment[Z]&&(this.accumulatedFirstMoment[Z]={originalName:`${b}/m`,variable:(0,Ot.lu)(()=>(0,cn.P)(q).variable(!1))}),null==this.accumulatedSecondMoment[Z]&&(this.accumulatedSecondMoment[Z]={originalName:`${b}/v`,variable:(0,Ot.lu)(()=>(0,cn.P)(q).variable(!1))});const lt=Array.isArray(s)?s[Z].tensor:s[b];if(null==lt)return;const mt=this.accumulatedFirstMoment[Z].variable,ut=this.accumulatedSecondMoment[Z].variable,Dt=(0,bt.I)((0,xt.d)(mt,this.beta1),(0,xt.d)(lt,1-this.beta1)),Mt=(0,bt.I)((0,xt.d)(ut,this.beta2),(0,xt.d)((0,_n.h)(lt),1-this.beta2)),Tt=(0,pn.h)(Dt,E),It=(0,pn.h)(Mt,A);mt.assign(Dt),ut.assign(Mt);const Wt=(0,bt.I)((0,xt.d)((0,pn.h)(Tt,(0,bt.I)((0,Fn._)(It),this.epsilon)),-this.learningRate),q);q.assign(Wt)}),this.accBeta1.assign((0,xt.d)(this.accBeta1,this.beta1)),this.accBeta2.assign((0,xt.d)(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&(0,Ot.B9)(this.accumulatedFirstMoment.map(s=>s.variable)),null!=this.accumulatedSecondMoment&&(0,Ot.B9)(this.accumulatedSecondMoment.map(s=>s.variable))}getWeights(){var s=this;return(0,H.Z)(function*(){const l=[...s.accumulatedFirstMoment,...s.accumulatedSecondMoment];return[yield s.saveIterations()].concat(l.map(E=>({name:E.originalName,tensor:E.variable})))})()}setWeights(s){var l=this;return(0,H.Z)(function*(){s=yield l.extractIterations(s),(0,Ot.lu)(()=>{l.accBeta1.assign((0,Ge.s)(l.beta1,l.iterations_+1)),l.accBeta2.assign((0,Ge.s)(l.beta2,l.iterations_+1))});const E=s.length/2;l.accumulatedFirstMoment=s.slice(0,E).map(b=>({originalName:b.name,variable:b.tensor.variable(!1)})),l.accumulatedSecondMoment=s.slice(E,2*E).map(b=>({originalName:b.name,variable:b.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(s,l){return new s(l.learningRate,l.beta1,l.beta2,l.epsilon)}}var ys=t(2992),me=t(8060);class ge extends yn{static get className(){return"Adamax"}constructor(s,l,E,A=null,b=0){super(),this.learningRate=s,this.beta1=l,this.beta2=E,this.epsilon=A,this.decay=b,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],(0,Ot.lu)(()=>{this.iteration=(0,Ln.i)(0).variable(),this.accBeta1=(0,Ln.i)(l).variable()}),null==A&&(this.epsilon=c.BV.backend.epsilon())}applyGradients(s){const l=Array.isArray(s)?s.map(E=>E.name):Object.keys(s);(0,Ot.lu)(()=>{const E=(0,Vn.l)(1,this.accBeta1),A=(0,pn.h)(-this.learningRate,(0,bt.I)((0,xt.d)(this.iteration,this.decay),1));l.forEach((b,Z)=>{const q=c.BV.registeredVariables[b];null==this.accumulatedFirstMoment[Z]&&(this.accumulatedFirstMoment[Z]={originalName:`${b}/m`,variable:(0,cn.P)(q).variable(!1)}),null==this.accumulatedWeightedInfNorm[Z]&&(this.accumulatedWeightedInfNorm[Z]={originalName:`${b}/v`,variable:(0,cn.P)(q).variable(!1)});const lt=Array.isArray(s)?s[Z].tensor:s[b];if(null==lt)return;const mt=this.accumulatedFirstMoment[Z].variable,ut=this.accumulatedWeightedInfNorm[Z].variable,Dt=(0,bt.I)((0,xt.d)(mt,this.beta1),(0,xt.d)(lt,1-this.beta1)),Mt=(0,xt.d)(ut,this.beta2),Tt=(0,ys.W)(lt),It=(0,me.g)(Mt,Tt);mt.assign(Dt),ut.assign(It);const Wt=(0,bt.I)((0,xt.d)((0,pn.h)(A,E),(0,pn.h)(Dt,(0,bt.I)(It,this.epsilon))),q);q.assign(Wt)}),this.iteration.assign((0,bt.I)(this.iteration,1)),this.accBeta1.assign((0,xt.d)(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&(0,Ot.B9)(this.accumulatedFirstMoment.map(s=>s.variable)),null!=this.accumulatedWeightedInfNorm&&(0,Ot.B9)(this.accumulatedWeightedInfNorm.map(s=>s.variable))}getWeights(){return(0,H.Z)(function*(){throw new Error("getWeights() is not implemented for Adamax yet.")})()}setWeights(s){return(0,H.Z)(function*(){throw new Error("setWeights() is not implemented for Adamax yet.")})()}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(s,l){return new s(l.learningRate,l.beta1,l.beta2,l.epsilon,l.decay)}}class re extends yn{static get className(){return"SGD"}constructor(s){super(),this.learningRate=s,this.setLearningRate(s)}applyGradients(s){(Array.isArray(s)?s.map(E=>E.name):Object.keys(s)).forEach((E,A)=>{const b=Array.isArray(s)?s[A].tensor:s[E];if(null==b)return;const Z=c.BV.registeredVariables[E];(0,Ot.lu)(()=>{const q=(0,bt.I)((0,xt.d)(this.c,b),Z);Z.assign(q)})}),this.incrementIterations()}setLearningRate(s){this.learningRate=s,null!=this.c&&this.c.dispose(),this.c=(0,Ot.Cn)((0,Ln.i)(-s))}dispose(){this.c.dispose()}getWeights(){var s=this;return(0,H.Z)(function*(){return[yield s.saveIterations()]})()}setWeights(s){var l=this;return(0,H.Z)(function*(){if(0!==(s=yield l.extractIterations(s)).length)throw new Error("SGD optimizer does not have settable weights.")})()}getConfig(){return{learningRate:this.learningRate}}static fromConfig(s,l){return new s(l.learningRate)}}class _e extends re{static get className(){return"Momentum"}constructor(s,l,E=!1){super(s),this.learningRate=s,this.momentum=l,this.useNesterov=E,this.accumulations=[],this.m=(0,Ln.i)(this.momentum)}applyGradients(s){(Array.isArray(s)?s.map(E=>E.name):Object.keys(s)).forEach((E,A)=>{const b=c.BV.registeredVariables[E];null==this.accumulations[A]&&(this.accumulations[A]={originalName:`${E}/momentum`,variable:(0,Ot.lu)(()=>(0,cn.P)(b).variable(!1))});const Z=this.accumulations[A].variable,q=Array.isArray(s)?s[A].tensor:s[E];null!=q&&(0,Ot.lu)(()=>{let at;const lt=(0,bt.I)((0,xt.d)(this.m,Z),q);at=(0,bt.I)((0,xt.d)(this.c,this.useNesterov?(0,bt.I)(q,(0,xt.d)(lt,this.m)):lt),b),Z.assign(lt),b.assign(at)})}),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&(0,Ot.B9)(this.accumulations.map(s=>s.variable))}setMomentum(s){this.momentum=s}getWeights(){var s=this;return(0,H.Z)(function*(){return[yield s.saveIterations()].concat(s.accumulations.map(l=>({name:l.originalName,tensor:l.variable})))})()}setWeights(s){var l=this;return(0,H.Z)(function*(){s=yield l.extractIterations(s),l.accumulations=s.map(A=>({originalName:A.name,variable:A.tensor.variable(!1)}))})()}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(s,l){return new s(l.learningRate,l.momentum,l.useNesterov)}}class De extends yn{static get className(){return"RMSProp"}constructor(s,l=.9,E=0,A=null,b=!1){if(super(),this.learningRate=s,this.decay=l,this.momentum=E,this.epsilon=A,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=b,null==A&&(this.epsilon=c.BV.backend.epsilon()),null==s)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(s){(Array.isArray(s)?s.map(E=>E.name):Object.keys(s)).forEach((E,A)=>{const b=c.BV.registeredVariables[E],Z=!1;null==this.accumulatedMeanSquares[A]&&(this.accumulatedMeanSquares[A]={originalName:`${E}/rms`,variable:(0,Ot.lu)(()=>(0,cn.P)(b).variable(Z))}),null==this.accumulatedMoments[A]&&(this.accumulatedMoments[A]={originalName:`${E}/momentum`,variable:(0,Ot.lu)(()=>(0,cn.P)(b).variable(Z))}),null==this.accumulatedMeanGrads[A]&&this.centered&&(this.accumulatedMeanGrads[A]={originalName:`${E}/mg`,variable:(0,Ot.lu)(()=>(0,cn.P)(b).variable(Z))});const q=Array.isArray(s)?s[A].tensor:s[E];if(null==q)return;const at=this.accumulatedMeanSquares[A].variable,lt=this.accumulatedMoments[A].variable;(0,Ot.lu)(()=>{const mt=(0,bt.I)((0,xt.d)(at,this.decay),(0,xt.d)((0,_n.h)(q),1-this.decay));if(this.centered){const ut=this.accumulatedMeanGrads[A].variable,Dt=(0,bt.I)((0,xt.d)(ut,this.decay),(0,xt.d)(q,1-this.decay)),Mt=(0,pn.h)((0,xt.d)(q,this.learningRate),(0,Fn._)((0,Vn.l)(mt,(0,bt.I)((0,_n.h)(Dt),this.epsilon)))),Tt=(0,bt.I)((0,xt.d)(lt,this.momentum),Mt);at.assign(mt),ut.assign(Dt),lt.assign(Tt);const It=(0,Vn.l)(b,Tt);b.assign(It)}else{const ut=(0,bt.I)((0,xt.d)(at,this.decay),(0,xt.d)((0,_n.h)(q),1-this.decay)),Dt=(0,bt.I)((0,xt.d)(lt,this.momentum),(0,pn.h)((0,xt.d)(q,this.learningRate),(0,Fn._)((0,bt.I)(ut,this.epsilon))));at.assign(ut),lt.assign(Dt);const Mt=(0,Vn.l)(b,Dt);b.assign(Mt)}})}),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&(0,Ot.B9)(this.accumulatedMeanSquares.map(s=>s.variable)),null!=this.accumulatedMeanGrads&&this.centered&&(0,Ot.B9)(this.accumulatedMeanGrads.map(s=>s.variable)),null!=this.accumulatedMoments&&(0,Ot.B9)(this.accumulatedMoments.map(s=>s.variable))}getWeights(){var s=this;return(0,H.Z)(function*(){const l=[...s.accumulatedMeanSquares,...s.accumulatedMoments];return s.centered&&l.push(...s.accumulatedMeanGrads),[yield s.saveIterations()].concat(l.map(E=>({name:E.originalName,tensor:E.variable})))})()}setWeights(s){var l=this;return(0,H.Z)(function*(){s=yield l.extractIterations(s);const E=l.centered?s.length/3:s.length/2,A=!1;l.accumulatedMeanSquares=s.slice(0,E).map(b=>({originalName:b.name,variable:b.tensor.variable(A)})),l.accumulatedMoments=s.slice(E,2*E).map(b=>({originalName:b.name,variable:b.tensor.variable(A)})),l.centered&&(l.accumulatedMeanGrads=s.slice(2*E,3*E).map(b=>({originalName:b.name,variable:b.tensor.variable(A)})))})()}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(s,l){return new s(l.learningRate,l.decay,l.momentum,l.epsilon,l.centered)}}const As=[se,Ee,kn,ge,_e,De,re];function Wn(u){return new Promise(s=>setTimeout(s)).then(u)}let Un=(()=>{class u{constructor(l){if(!(0,K.OB)().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");l.startsWith(u.URL_SCHEME)&&(l=l.slice(u.URL_SCHEME.length)),(null==l||0===l.length)&&(l="model"),this.modelJsonFileName=l+".json",this.weightDataFileName=l+".weights.bin"}save(l){var E=this;return(0,H.Z)(function*(){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const A=window.URL.createObjectURL(new Blob([l.weightData],{type:"application/octet-stream"}));if(l.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const Z=tt(l,[{paths:["./"+E.weightDataFileName],weights:l.weightSpecs}]),q=window.URL.createObjectURL(new Blob([JSON.stringify(Z)],{type:"application/json"})),at=null==E.modelJsonAnchor?document.createElement("a"):E.modelJsonAnchor;if(at.download=E.modelJsonFileName,at.href=q,yield Wn(()=>at.dispatchEvent(new MouseEvent("click"))),null!=l.weightData){const lt=null==E.weightDataAnchor?document.createElement("a"):E.weightDataAnchor;lt.download=E.weightDataFileName,lt.href=A,yield Wn(()=>lt.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:pt(l)}}})()}}return u.URL_SCHEME="downloads://",u})();class xs{constructor(s){if(null==s||s.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${s}`);this.jsonFile=s[0],this.weightsFiles=s.slice(1)}load(){var s=this;return(0,H.Z)(function*(){return new Promise((l,E)=>{const A=new FileReader;A.onload=b=>{const Z=JSON.parse(b.target.result),q=Z.modelTopology;if(null==q)return void E(new Error(`modelTopology field is missing from file ${s.jsonFile.name}`));if(null==Z.weightsManifest)return void E(new Error(`weightManifest field is missing from file ${s.jsonFile.name}`));if(0===s.weightsFiles.length)return void l({modelTopology:q});const lt=ft(Z,mt=>s.loadWeights(mt));l(lt)},A.onerror=b=>E(`Failed to read model topology and weights manifest JSON from file '${s.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),A.readAsText(s.jsonFile)})})()}loadWeights(s){const l=[],E=[];for(const Z of s)l.push(...Z.weights),E.push(...Z.paths);const A=this.checkManifestAndWeightFiles(s),b=E.map(Z=>this.loadWeightsFile(Z,A[Z]));return Promise.all(b).then(Z=>[l,F(Z)])}loadWeightsFile(s,l){return new Promise((E,A)=>{const b=new FileReader;b.onload=Z=>{E(Z.target.result)},b.onerror=Z=>A(`Failed to weights data from file of path '${s}'.`),b.readAsArrayBuffer(l)})}checkManifestAndWeightFiles(s){const l=[],E=this.weightsFiles.map(b=>Y(b.name)),A={};for(const b of s)b.paths.forEach(Z=>{const q=Y(Z);if(-1!==l.indexOf(q))throw new Error(`Duplicate file basename found in weights manifest: '${q}'`);if(l.push(q),-1===E.indexOf(q))throw new Error(`Weight file with basename '${q}' is not provided.`);A[Z]=this.weightsFiles[E.indexOf(q)]});if(l.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${l.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return A}}function Ss(u){return new xs(u)}Rt.registerSaveRouter(u=>(0,K.OB)().getBool("IS_BROWSER")&&!Array.isArray(u)&&u.startsWith(Un.URL_SCHEME)?function ae(u="model"){return new Un(u)}(u.slice(Un.URL_SCHEME.length)):null);var on=t(1530);class ze{constructor(s){if(this.shards=[],this.previousShardIndex=0,s instanceof Array||(s=[s]),0===(s=s.map(E=>on.isTypedArray(E)?E.buffer:E)).length)return;this.bufferUniformSize=s[0].byteLength;let l=0;for(let E=0;E<s.length;E++){const A=s[E];E!==s.length-1&&A.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const b=l+A.byteLength;this.shards.push({buffer:A,start:l,end:b}),l=b}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(s=0,l=this.byteLength){if(s=isNaN(Number(s))?0:s,l=isNaN(Number(l))?0:l,s=Math.max(0,s),(l=Math.min(this.byteLength,l))<=s)return new ArrayBuffer(0);const E=this.findShardForByte(s);if(-1===E)throw new Error(`Could not find start shard for byte ${s}`);const b=new ArrayBuffer(l-s),Z=new Uint8Array(b);let q=0;for(let at=E;at<this.shards.length;at++){const lt=this.shards[at],ut=s+q-lt.start,Dt=q,Tt=Math.min(l,lt.end)-lt.start,It=new Uint8Array(lt.buffer.slice(ut,Tt));if(Z.set(It,Dt),q+=It.length,l<lt.end)break}return b}findShardForByte(s){if(0===this.shards.length||s<0||s>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(s/this.bufferUniformSize),this.previousShardIndex;function l(A){return s<A.start?-1:s>=A.end?1:0}if(0===l(this.shards[this.previousShardIndex]))return this.previousShardIndex;const E=function Me(u,s){let l=0,E=u.length;for(;l<=E;){const A=Math.floor((E-l)/2)+l,b=s(u[A]);if(0===b)return A;b<0?E=A:l=A+1}return-1}(this.shards,l);return-1===E?-1:(this.previousShardIndex=E,this.previousShardIndex)}}function Ut(u,s,l,E){(function Z(at){(0,W.hu)(null!=at&&Array.isArray(at)&&at.length>0,()=>"promises must be a none empty array")})(u),function q(at,lt){(0,W.hu)(at>=0&&at<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${at}`),(0,W.hu)(lt>=0&&lt<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${lt}`),(0,W.hu)(lt>=at,()=>`startFraction must be no more than endFraction, but got startFraction ${at} and endFraction ${lt}`)}(l=l??0,E=E??1);let A=0;return Promise.all(u.map(at=>(at.then(lt=>{const mt=l+ ++A/u.length*(E-l);return s(mt),lt}),at)))}function He(u,s){return ve.apply(this,arguments)}function ve(){return(ve=(0,H.Z)(function*(u,s){null==s&&(s={});const l=null==s.fetchFunc?(0,K.OB)().platform.fetch:s.fetchFunc,E=u.map(ut=>l(ut,s.requestInit,{isBinary:!0})),q=(null==s.onProgress?yield Promise.all(E):yield Ut(E,s.onProgress,0,.5)).map(ut=>ut.arrayBuffer());return null==s.onProgress?yield Promise.all(q):yield Ut(q,s.onProgress,.5,1)})).apply(this,arguments)}function Ls(u){return Pe.apply(this,arguments)}function Pe(){return(Pe=(0,H.Z)(function*(u,s="",l,E){return Xe(Z=>He(Z,{requestInit:E}))(u,s,l)})).apply(this,arguments)}function Xe(u){return function(){var s=(0,H.Z)(function*(l,E="",A){const b=l.map(()=>!1),Z={},q=null!=A?A.map(()=>!1):[],at=[];if(l.forEach((Tt,It)=>{let Wt=0;Tt.weights.forEach(kt=>{const gn=k["quantization"in kt?kt.quantization.dtype:kt.dtype]*W.NA(kt.shape),bn=()=>{b[It]=!0,null==Z[It]&&(Z[It]=[]),Z[It].push({manifestEntry:kt,groupOffset:Wt,sizeBytes:gn})};null!=A?A.forEach((rs,vo)=>{rs===kt.name&&(bn(),q[vo]=!0)}):bn(),at.push(kt.name),Wt+=gn})}),!q.every(Tt=>Tt)){const Tt=A.filter((It,Wt)=>!q[Wt]);throw new Error(`Could not find weights in manifest with names: ${Tt.join(", ")}. \nManifest JSON has weights with names: ${at.join(", ")}.`)}const lt=b.reduce((Tt,It,Wt)=>(It&&Tt.push(Wt),Tt),[]),mt=[];lt.forEach(Tt=>{l[Tt].paths.forEach(It=>{const Wt=E+(E.endsWith("/")?"":"/")+It;mt.push(Wt)})});const ut=yield u(mt),Dt={};let Mt=0;return lt.forEach(Tt=>{const It=l[Tt].paths.length,Wt=new ze(ut.slice(Mt,Mt+It));Z[Tt].forEach(mn=>{const bn=y(Wt.slice(mn.groupOffset,mn.groupOffset+mn.sizeBytes),[mn.manifestEntry]);for(const rs in bn)Dt[rs]=bn[rs]}),Mt+=It}),Dt});return function(l){return s.apply(this,arguments)}}()}let Oe=(()=>{class u{constructor(l,E){if(this.DEFAULT_METHOD="POST",null==E&&(E={}),this.weightPathPrefix=E.weightPathPrefix,this.onProgress=E.onProgress,this.weightUrlConverter=E.weightUrlConverter,null!=E.fetchFunc?((0,W.hu)("function"==typeof E.fetchFunc,()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=E.fetchFunc):this.fetch=(0,K.OB)().platform.fetch,(0,W.hu)(null!=l&&l.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(l)&&(0,W.hu)(2===l.length,()=>`URL paths for http must have a length of 2, (actual length is ${l.length}).`),this.path=l,null!=E.requestInit&&null!=E.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=E.requestInit||{}}save(l){var E=this;return(0,H.Z)(function*(){if(l.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const A=Object.assign({method:E.DEFAULT_METHOD},E.requestInit);A.body=new FormData;const Z=tt(l,[{paths:["./model.weights.bin"],weights:l.weightSpecs}]);A.body.append("model.json",new Blob([JSON.stringify(Z)],{type:"application/json"}),"model.json"),null!=l.weightData&&A.body.append("model.weights.bin",new Blob([l.weightData],{type:"application/octet-stream"}),"model.weights.bin");const q=yield E.fetch(E.path,A);if(q.ok)return{modelArtifactsInfo:pt(l),responses:[q]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${q.status}.`)})()}load(){var l=this;return(0,H.Z)(function*(){const E=yield l.fetch(l.path,l.requestInit);if(!E.ok)throw new Error(`Request to ${l.path} failed with status code ${E.status}. Please verify this URL points to the model JSON of the model to load.`);let A;try{A=yield E.json()}catch{let at=`Failed to parse model JSON of response from ${l.path}.`;throw l.path.endsWith(".pb")?at+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":at+=" Please make sure the server is serving valid JSON for this request.",new Error(at)}if(null==A.modelTopology&&null==A.weightsManifest)throw new Error(`The JSON from HTTP path ${l.path} contains neither model topology or manifest for weights.`);return ft(A,q=>l.loadWeights(q))})()}loadWeights(l){var E=this;return(0,H.Z)(function*(){const A=Array.isArray(E.path)?E.path[1]:E.path,[b,Z]=function Us(u){const s=u.lastIndexOf("/"),l=u.lastIndexOf("?");return[u.substring(0,s)+"/",l>s?u.substring(l):""]}(A),q=E.weightPathPrefix||b,at=Pt(l),lt=[],mt=[];for(const Dt of l)for(const Mt of Dt.paths)null!=E.weightUrlConverter?mt.push(E.weightUrlConverter(Mt)):lt.push(q+Mt+Z);return E.weightUrlConverter&&lt.push(...yield Promise.all(mt)),[at,F(yield He(lt,{requestInit:E.requestInit,fetchFunc:E.fetch,onProgress:E.onProgress}))]})()}}return u.URL_SCHEME_REGEX=/^https?:\/\//,u})();function Te(u){return null!=u.match(Oe.URL_SCHEME_REGEX)}const je=(u,s)=>{if(typeof fetch>"u"&&(null==s||null==s.fetchFunc))return null;{let l=!0;if(l=Array.isArray(u)?u.every(E=>Te(E)):Te(u),l)return Ie(u,s)}return null};function Ie(u,s){return new Oe(u,s)}function Xn(u,s){return Ie(u,s)}Rt.registerSaveRouter(je),Rt.registerLoadRouter(je);class ye{constructor(s){this.modelArtifacts=s}load(){return this.modelArtifacts}}class Ze{constructor(s){this.saveHandler=s}save(s){return this.saveHandler(s)}}class Ks{constructor(s){s.load&&(this.load=()=>Promise.resolve(s.load())),s.save&&(this.save=l=>Promise.resolve(s.save(l)))}}function bs(u,s,l,E){return new Ks(Qe(...arguments))}function Qe(u,s,l,E){return 1===arguments.length?null!=u.modelTopology||null!=u.weightSpecs?new ye(u):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ye({modelTopology:u})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ye({modelTopology:u,weightSpecs:s,weightData:l,trainingConfig:E}))}function Ns(u){return new Ze(u)}function ws(u){return new Ze(u)}var jn=t(4810),Fs=t(4291),Ae=t(8598),Ye=t(5948),Vs=t(3111);const Gs=(0,Ye.op)({confusionMatrix_:function ks(u,s,l){const E=(0,jn._1)(u,"labels","confusionMatrix"),A=(0,jn._1)(s,"predictions","confusionMatrix");W.hu(null==l||l>0&&Number.isInteger(l),()=>`If provided, numClasses must be a positive integer, but got ${l}`),W.hu(1===E.rank,()=>`Expected the rank of labels to be 1, but got ${E.rank}`),W.hu(1===A.rank,()=>`Expected the rank of predictions to be 1, but got ${A.rank}`),W.hu(E.shape[0]===A.shape[0],()=>`Mismatch in the number of examples: ${E.shape[0]} vs. ${A.shape[0]}. Labels and predictions should have the same number of elements.`),W.hu(l>0&&Number.isInteger(l),()=>`numClasses is required to be a positive integer, but got ${l}`);const b=(0,Ae.l)((0,wn.p)(E,"int32"),l),Z=(0,Ae.l)((0,wn.p)(A,"int32"),l),q=(0,Vs.p)(b),at=(0,Fs.O)(q,Z);return(0,wn.p)(at,"int32")}});var ie=t(3469),J=t(6338),Mn=t(8415),zs=t(3221);let Kn;function Je(u,s=3){if(s>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==u)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let l=!1,E=!1,A=!1,b=!1,Z=!1,q=!1;if(u.data instanceof Uint8Array)l=!0;else if(typeof ImageData<"u"&&u instanceof ImageData)E=!0;else if(typeof HTMLVideoElement<"u"&&u instanceof HTMLVideoElement)A=!0;else if(typeof HTMLImageElement<"u"&&u instanceof HTMLImageElement)b=!0;else if(null!=u.getContext)Z=!0;else{if(!(typeof ImageBitmap<"u"&&u instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${u.constructor.name}`);q=!0}if(null!=(0,Mn.pI)(J.eBW,c.BV.backendName))return c.BV.runKernel(J.eBW,{pixels:u},{numChannels:s});const[lt,mt]=A?[u.videoWidth,u.videoHeight]:[u.width,u.height];let ut,Dt;if(Z)ut=u.getContext("2d").getImageData(0,0,lt,mt).data;else if(E||l)ut=u.data;else if(b||A||q){if(null==Kn)if(typeof document>"u"){if(!(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u"))throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");Kn=new OffscreenCanvas(1,1).getContext("2d")}else Kn=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Kn.canvas.width=lt,Kn.canvas.height=mt,Kn.drawImage(u,0,0,lt,mt),ut=Kn.getImageData(0,0,lt,mt).data}if(4===s)Dt=new Int32Array(ut);else{const Tt=lt*mt;Dt=new Int32Array(Tt*s);for(let It=0;It<Tt;It++)for(let Wt=0;Wt<s;++Wt)Dt[It*s+Wt]=ut[4*It+Wt]}return(0,zs.w)(Dt,[mt,lt,s],"int32")}function Ir(u){return hr.apply(this,arguments)}function hr(){return(hr=(0,H.Z)(function*(u,s=3){let l=null;if((0,K.OB)().getBool("WRAP_TO_IMAGEBITMAP")&&function Tr(u){return function Xs(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}()&&!(u instanceof ImageBitmap)&&function js(u){return null!=u&&0!==u.width&&0!==u.height}(u)&&!function Hs(u){return null!=u&&u.data instanceof Uint8Array}(u)}(u)){let E;try{E=yield createImageBitmap(u,{premultiplyAlpha:"none"})}catch{E=null}l=null!=E&&E.width===u.width&&E.height===u.height?E:u}else l=u;return Je(l,s)})).apply(this,arguments)}function yo(u,s){return Be.apply(this,arguments)}function Be(){return(Be=(0,H.Z)(function*(u,s){let l=(0,jn._1)(u,"img","toPixels");if(!(u instanceof In.es)){const lt=l;l=(0,wn.p)(lt,"int32"),lt.dispose()}if(2!==l.rank&&3!==l.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${l.rank}.`);const[E,A]=l.shape.slice(0,2),b=2===l.rank?1:l.shape[2];if(b>4||2===b)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${b}`);if("float32"!==l.dtype&&"int32"!==l.dtype)throw new Error(`Unsupported type for toPixels: ${l.dtype}. Please use float32 or int32 tensors.`);const Z=yield l.data(),q="float32"===l.dtype?255:1,at=new Uint8ClampedArray(A*E*4);for(let lt=0;lt<E*A;++lt){const mt=[0,0,0,255];for(let Dt=0;Dt<b;Dt++){const Mt=Z[lt*b+Dt];if("float32"===l.dtype){if(Mt<0||Mt>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${Mt}.`)}else if("int32"===l.dtype&&(Mt<0||Mt>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${Mt}.`);1===b?(mt[0]=Mt*q,mt[1]=Mt*q,mt[2]=Mt*q):mt[Dt]=Mt*q}const ut=4*lt;at[ut+0]=Math.round(mt[0]),at[ut+1]=Math.round(mt[1]),at[ut+2]=Math.round(mt[2]),at[ut+3]=Math.round(mt[3])}if(null!=s){s.width=A,s.height=E;const lt=s.getContext("2d"),mt=new ImageData(at,A,E);lt.putImageData(mt,0,0)}return l!==u&&l.dispose(),at})).apply(this,arguments)}const yr=(0,Ye.op)({fromPixels_:Je});function dr(u,s){const l=u.shape.length,E=s.shape.length;if(l<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${l}.`);if(E<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${E}.`);if("int32"!==s.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${s.dtype}.`);if(s.shape[E-1]>l)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${s.shape[E-1]} vs. ${l}`);if(0===(0,W.NA)(u.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${u.shape}.`);const A=s.shape,b=A[A.length-1];let Z=1;for(let ut=0;ut<A.length-1;++ut)Z*=A[ut];const q=u.shape,at=A.slice();at.pop();let lt=1;for(let ut=b;ut<l;++ut)lt*=q[ut],at.push(q[ut]);const mt=[...(0,W.e3)(u.shape).map(ut=>ut/lt),1].slice(0,b);return[at,Z,lt,mt]}var qe=t(7169),fr=t(4361),Ar=t(7073);const Br=.001,Zs=.1;function Rr(u,s,l){return null==l&&(l=Qs()),Ys(u,s,(E,A)=>Zn(E,A,l))}function Qs(){return 32===c.BV.backend.floatPrecision()?Br:Zs}function Ys(u,s,l){let E=!0;if(((0,on.isTypedArray)(u)||(0,on.isTypedArray)(s))&&(E=!1),(0,on.isTypedArray)(u)&&(0,on.isTypedArray)(s)&&(E=!0),E){const Z=u.constructor.name,q=s.constructor.name;if(Z!==q)throw new Error(`Arrays are of different type. Actual: ${Z}. Expected: ${q}`)}if(Array.isArray(u)&&Array.isArray(s)){const Z=(0,jn.C)(u),q=(0,jn.C)(s);if(!(0,W.cO)(Z,q))throw new Error(`Arrays have different shapes. Actual: [${Z}]. Expected: [${q}]`)}const A=(0,on.isTypedArray)(u)?u:(0,on.flatten)(u),b=(0,on.isTypedArray)(s)?s:(0,on.flatten)(s);if(A.length!==b.length)throw new Error(`Arrays have different lengths actual: ${A.length} vs expected: ${b.length}.\nActual:   ${A}.\nExpected: ${b}.`);for(let Z=0;Z<b.length;++Z){const q=A[Z],at=b[Z];if(!l(q,at))throw new Error(`Arrays differ: actual[${Z}] = ${q}, expected[${Z}] = ${at}.\nActual:   ${A}.\nExpected: ${b}.`)}typeof expect<"u"&&expect().nothing()}function Js(u,s){u().then(()=>s.fail(),()=>s()),typeof expect<"u"&&expect().nothing()}function Cr(u,s){const l="string"==typeof s||"number"==typeof s||"boolean"==typeof s?[s]:s;return(0,W.HD)(u)||(0,W.HD)(u[0])||(0,W.HD)(s)||(0,W.HD)(s[0])?Ys(u,l,(E,A)=>E==A):Ys(u,s,(E,A)=>Zn(E,A,0))}function xr(u,s,l){if(null==l&&(l=Qs()),!Zn(u,s,l))throw new Error(`Numbers differ: actual === ${u}, expected === ${s}`);typeof expect<"u"&&expect().nothing()}function Zn(u,s,l){return!isFinite(u)&&!isFinite(s)||!(isNaN(u)||isNaN(s)||Math.abs(u-s)>l)}function $r(u,s,l){for(let E=0;E<u.length;E++)if(u[E]<s||u[E]>l)throw new Error(`Value out of range:${u[E]} low: ${s}, high: ${l}`)}function Sr(u,s){const l=new Float32Array(u),E=new Float32Array(s);if(l.length!==E.length)throw new Error(`Expected ArrayBuffer to be of length ${E.length}, but it was ${l.length}`);for(let A=0;A<E.length;A++)if(l[A]!==E[A])throw new Error(`Expected ArrayBuffer value at ${A} to be ${E[A]} but got ${l[A]} instead`)}function ts(u){for(let s=0;s<u.length;s++){const l=u[s];Array.isArray(l)?ts(l):u[s]=(0,on.encodeString)(l)}return u}function Lr(u){const s=document.createElement("video");return"playsInline"in s&&(s.playsInline=!0),s.muted=!0,s.loop=!0,s.style.position="fixed",s.style.left="0px",s.style.top="0px",s.preload="auto",s.appendChild(u),new Promise(l=>{s.addEventListener("loadeddata",E=>l(s)),s.load()})}function Re(u){return qs.apply(this,arguments)}function qs(){return(qs=(0,H.Z)(function*(u){yield u.play(),"requestVideoFrameCallback"in u&&(yield new Promise(s=>{u.requestVideoFrameCallback(s)}))})).apply(this,arguments)}const Wr="4.5.0";class pr{static sgd(s){return new re(s)}static momentum(s,l,E=!1){return new _e(s,l,E)}static rmsprop(s,l=.9,E=0,A=null,b=!1){return new De(s,l,E,A,b)}static adam(s=.001,l=.9,E=.999,A=null){return new kn(s,l,E,A)}static adadelta(s=.001,l=.95,E=null){return new se(s,l,E)}static adamax(s=.002,l=.9,E=.999,A=null,b=0){return new ge(s,l,E,A,b)}static adagrad(s,l=.1){return new Ee(s,l)}}var ns=t(6209),j=t(9587),Ur=t(1976);const Kr=pr,br=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:u=>u();function Er(){return new Promise(u=>br(()=>u()))}var zn=t(2745);function Jt(u,s){const l=u[0].length;u.forEach((A,b)=>{W.hu(A.length===l,()=>`Error in concat${l}D: rank of tensors[${b}] must be the same as the rank of the rest (${l})`)}),W.hu(s>=0&&s<l,()=>`Error in concat${l}D: axis must be between 0 and ${l-1}.`);const E=u[0];u.forEach((A,b)=>{for(let Z=0;Z<l;Z++)W.hu(Z===s||A[Z]===E[Z],()=>`Error in concat${l}D: Shape of tensors[${b}] (${A}) does not match the shape of the rest (${E}) along the non-concatenated axis ${b}.`)})}function Nr(u,s){const l=u[0].slice();for(let E=1;E<u.length;E++)l[s]+=u[E][s];return l}var vn=t(7202),An=t(4708),zt=(()=>((zt=zt||{})[zt.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",zt[zt.VALUE_ROWIDS=1]="VALUE_ROWIDS",zt[zt.ROW_LENGTHS=2]="ROW_LENGTHS",zt[zt.ROW_SPLITS=3]="ROW_SPLITS",zt[zt.ROW_LIMITS=4]="ROW_LIMITS",zt[zt.ROW_STARTS=5]="ROW_STARTS",zt))();function tr(u,s,l){let E=new Array;if(null==l&&null==s)return E;if(null==s)for(;E.length<u+l.length;)E.push(-1);else E=s.slice();if(null==l)return E;if(u+l.length!==E.length)throw new Error(`rt input.shape and shape=${s} are incompatible: rt input.rank = ${u+l.length}, but shape.rank = ${E.length}`);for(let A=1;A<l.length;++A){const b=l[A],Z=E[E.length-l.length+A],q=E[Z];if(b>=0)if(q>=0){if(q!==b)throw new Error(`rt input.shape and shape=${s} are incompatible: rt input.shape[${A+u}] = ${b} but shape[${A+u}] = ${q}`)}else E[Z]=b}return E}function wr(u){const s={FIRST_DIM_SIZE:zt.FIRST_DIM_SIZE,VALUE_ROWIDS:zt.VALUE_ROWIDS,ROW_LENGTHS:zt.ROW_LENGTHS,ROW_SPLITS:zt.ROW_SPLITS,ROW_LIMITS:zt.ROW_LIMITS,ROW_STARTS:zt.ROW_STARTS},l=[];for(const E of u){if(!(E in s))break;l.push(s[E])}return l}function Fr(u){return 0===u.length?0:u[0]===zt.FIRST_DIM_SIZE?u.length-1:u.length}function Vr(u,s){if(null==u||null==s)return;const l=u.length,E=s.length;if(l>=E)throw new Error(`defaultValue.shape=${u} and ragged tensor flatValues.shape=${s}, are incompatible: defaultValue.rank = ${l} must be less than ragged tensor input flatValues.rank = ${E})`);for(let A=0;A<Math.min(l,E-1);++A){const b=u[A],Z=s[A+1];if(b>=0&&Z>=0&&1!==b&&b!==Z)throw new Error(`defaultValue.shape=${u}, and ragged tensor input flatValues.shape=${s} are incompatible: defaultValue.shape[${A-u.length}] = ${b} but ragged tensor input.flatValues.shape[${A-u.length}] = ${Z}`)}}const nr=30;function kr(u){return u<=nr?u:(0,W.jP)(u,Math.floor(Math.sqrt(u)))}function Gr(u,s,l){return[l*("number"==typeof u?u:u[0]),s*("number"==typeof u?u:u[1])]}function zr(u,s,l,E=!0){let A=[];if(E)A=A.concat(s.slice(0)),A.push(u[0]/l),A=A.concat(u.slice(1));else{A=A.concat(u[0]);const b=s.length;for(let Z=0;Z<b;++Z)A=A.concat([u[Z+1]/s[Z],s[Z]]);A=A.concat(u.slice(b+1))}return A}function Hr(u,s,l=!0){const E=[];if(l){E.push(s);for(let A=s+1;A<u;++A)A<=2*s?(E.push(A),E.push(A-(s+1))):E.push(A)}else{const A=[],b=[];for(let Z=1;Z<u;++Z)Z>=2*s+1||Z%2==1?b.push(Z):A.push(Z);E.push(...A),E.push(0),E.push(...b)}return E}function Xr(u,s,l,E=!0){const A=[];A.push(E?u[0]/l:u[0]*l);for(let b=1;b<u.length;++b)A.push(b<=s.length?E?s[b-1]*u[b]:u[b]/s[b-1]:u[b]);return A}function jr(u,s){const l=[0];for(let E=0;E<s;++E)l.push(u[E][0]);return l}function Zr(u,s,l){const E=u.slice(0,1);for(let A=0;A<l;++A)E.push(u[A+1]-s[A][0]-s[A][1]);return E}var mr=t(287);const Qr=.3275911,Yr=.254829592,Jr=-.284496736,gr=1.421413741,_r=-1.453152027,Dr=1.061405429;var es=t(6030);function er(u,s){if(u.length!==s.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${u.length}, imag: ${s.length}.`);const l=new Float32Array(2*u.length);for(let E=0;E<l.length;E+=2)l[E]=u[E/2],l[E+1]=s[E/2];return l}function qr(u){const s=new Float32Array(u.length/2),l=new Float32Array(u.length/2);for(let E=0;E<u.length;E+=2)s[E/2]=u[E],l[E/2]=u[E+1];return{real:s,imag:l}}function Mr(u){const s=Math.ceil(u.length/4),l=new Float32Array(s),E=new Float32Array(s);for(let A=0;A<u.length;A+=4)l[Math.floor(A/4)]=u[A],E[Math.floor(A/4)]=u[A+1];return{real:l,imag:E}}function sr(u){const s=Math.floor(u.length/4),l=new Float32Array(s),E=new Float32Array(s);for(let A=2;A<u.length;A+=4)l[Math.floor(A/4)]=u[A],E[Math.floor(A/4)]=u[A+1];return{real:l,imag:E}}function Ce(u,s){return{real:u[2*s],imag:u[2*s+1]}}function to(u,s,l,E){u[2*E]=s,u[2*E+1]=l}function no(u,s){const l=new Float32Array(u/2),E=new Float32Array(u/2);for(let A=0;A<Math.ceil(u/2);A++){const b=(s?2:-2)*Math.PI*(A/u);l[A]=Math.cos(b),E[A]=Math.sin(b)}return{real:l,imag:E}}function sn(u,s,l){const E=(l?2:-2)*Math.PI*(u/s);return{real:Math.cos(E),imag:Math.sin(E)}}const rr="->",or=/->/g,le=",",En="...";function xe(u,s){const l=((u=u.replace(/\s/g,"")).length-u.replace(or,"").length)/rr.length;if(l<1)throw new Error("Equations without an arrow are not supported.");if(l>1)throw new Error(`Equation must contain exactly one arrow ("${rr}").`);const[E,A]=u.split(rr);(0,W.hu)(-1===E.indexOf(En),()=>`The ellipsis notation ("${En}") is not supported yet.`);const b=E.split(le),Z=b.length;if(s!==Z)throw new Error(`Expected ${Z} input tensors, received ${s}`);if(Z>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const q=[];for(let Dt=0;Dt<A.length;++Dt){const Mt=A[Dt];if(!b.some(Tt=>-1!==Tt.indexOf(Mt)))throw new Error(`Output subscripts contain the label ${Mt} not present in the input subscripts.`);-1===q.indexOf(Mt)&&q.push(Mt)}for(let Dt=0;Dt<E.length;++Dt){const Mt=E[Dt];-1===q.indexOf(Mt)&&Mt!==le&&q.push(Mt)}const at=new Array(b.length);for(let Dt=0;Dt<Z;++Dt){if(new Set(b[Dt].split("")).size!==b[Dt].length)throw new Error(`Found duplicate axes in input component ${b[Dt]}. Support for duplicate axes in input is not implemented yet.`);at[Dt]=[];for(let Mt=0;Mt<b[Dt].length;++Mt)at[Dt].push(q.indexOf(b[Dt][Mt]))}const lt=q.length,ut=[];for(let Dt=A.length;Dt<lt;++Dt)ut.push(Dt);return{allDims:q,summedDims:ut,idDims:at}}function eo(u,s){let l=new Array(u);l.fill(-1);for(let A=0;A<s.length;++A)l[s[A]]=A;const E=[];for(let A=0;A<u;++A)-1===l[A]&&E.push(A);return l=l.filter(A=>-1!==A),{permutationIndices:l,expandDims:E}}function so(u,s,l){const E=new Array(u);for(let A=0;A<l.length;++A){const b=l[A].shape;for(let Z=0;Z<s[A].length;++Z)void 0===E[s[A][Z]]?E[s[A][Z]]=b[Z]:(0,W.hu)(E[s[A][Z]]===b[Z],()=>`Expected dimension ${E[s[A][Z]]} at axis ${Z} of input shaped ${JSON.stringify(b)}, but got dimension ${b[Z]}`)}}function ro(u,s){const l=u,E=[];let A=0;0===u.length&&l.push(-1),A=u.length+1;for(let Z=0;Z<A;++Z)E.push([]);const b=[];for(let Z=0;Z<l.length;++Z){const at=vr(s,l[Z]);for(const lt of at)-1===b.indexOf(lt)&&(E[Z].push(lt),b.push(lt))}return{path:l,steps:E}}function oo(u){return u.every((s,l)=>s===l)}function vr(u,s){const l=[];for(let E=0;E<u.length;++E)(0===u[E].length||-1!==u[E].indexOf(s)||-1===s)&&l.push(E);return l}function ao(u,s,l=0){let E=[];if("number"==typeof s)(0,W.hu)(u.shape[l]%s==0,()=>"Number of splits must evenly divide the axis."),E=new Array(s).fill(u.shape[l]/s);else{const A=s.reduce((Z,q)=>(-1===q&&(Z+=1),Z),0);(0,W.hu)(A<=1,()=>"There should be only one negative value in split array.");const b=s.indexOf(-1);if(-1!==b){const Z=s.reduce((q,at)=>at>0?q+at:q);s[b]=u.shape[l]-Z}(0,W.hu)(u.shape[l]===s.reduce((Z,q)=>Z+q),()=>"The sum of sizes must match the size of the axis dimension."),E=s}return E}function io(u){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${u}`}function lo(u,s){return`indices(${u}, 0) is invalid: ${s} < 0`}function uo(u,s,l){return`indices(${u}, 0) is invalid: ${s} >= ${l}`}function co(u,s){return`only one output dimension may be -1, not both ${u} and ${s}`}function ho(u,s){return`size ${u} must be non-negative, not ${s}`}function fo(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function ar(u,s){return`Input to reshape is a SparseTensor with ${(0,W.NA)(u)}\n  dense values, but the requested shape requires a multiple of ${(0,W.NA)(s)}. inputShape=${u} outputShape= ${s}`}function po(u,s){return`Input to reshape is a tensor with ${(0,W.NA)(u)} dense values, but the requested shape has ${(0,W.NA)(s)}. inputShape=${u} outputShape=${s}`}function Eo(){return"segment ids must be >= 0"}function Qn(){return"segment ids are not increasing"}function mo(u,s){return`Segment id ${u} out of range [0, ${s}), possibly because segmentIds input is not sorted.`}function go(u,s,l){return`Bad: indices[${u}] == ${s} out of range [0, ${l})`}function ir(u,s){let E,l=!1;for(u<=nr?(E=u,l=!0):E=(0,W.jP)(u,Math.floor(Math.sqrt(u)));!l;)E>s||E===u?l=!0:E=(0,W.jP)(u,E+1);return E}function Pr(u,s,l){const E=[],A=u.length;for(let b=0;b<A;b++)E.push(b!==s?u[b]:l);return E}function Or(u,s,l,E){const A=s.shape.length,b=u.shape.length;if(0!==E&&(E<-A||E>A))throw new Error(`Expect batchDims in the range of [-${A}, ${A}], but got ${E}`);if(E<0&&(E+=A),E>b)throw new Error(`batchDims (${E}) must be less than rank(x) (\n    ${b}).`);if(l<E)throw new Error(`batchDims (${E}) must be less than or equal to axis (${l}).`);for(let ut=0;ut<E;++ut)if(u.shape[ut]!==s.shape[ut])throw new Error(`x.shape[${ut}]: ${u.shape[ut]} should be equal to indices.shape[${ut}]: ${s.shape[ut]}.`);const Z=u.shape[l],q=[];let at=1,lt=1,mt=1;for(let ut=0;ut<E;++ut)q.push(u.shape[ut]),at*=u.shape[ut];for(let ut=E;ut<l;ut++)q.push(u.shape[ut]),lt*=u.shape[ut];for(let ut=E;ut<A;ut++)q.push(s.shape[ut]);for(let ut=l+1;ut<b;ut++)q.push(u.shape[ut]),mt*=u.shape[ut];return{batchSize:at,sliceSize:mt,outerSize:lt,dimSize:Z,outputShape:q}}function _o(u){try{return u.map(s=>(0,on.decodeString)(s))}catch(s){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${s}`)}}function Do(u){return u.map(s=>(0,on.encodeString)(s))}var $e=t(1831),Mo=t(4644),ss=t(3722);!function Bs(){for(const u of As)Ve(u)}()},6338:(Q,v,t)=>{"use strict";t.d(v,{$HU:()=>Vn,$g6:()=>_t,$w:()=>en,Acj:()=>Es,BMI:()=>Os,BiW:()=>ke,Byc:()=>pt,CAk:()=>_s,CQl:()=>se,D2d:()=>Us,DlI:()=>Ve,Eh3:()=>V,FKq:()=>Ut,G3Y:()=>Ae,GBy:()=>He,Gcp:()=>Pe,HEU:()=>wt,HZH:()=>ys,Hhh:()=>de,Hmb:()=>ge,IKK:()=>d,IMb:()=>z,J$2:()=>Ke,J7O:()=>Ps,J_u:()=>We,JhU:()=>I,Kgp:()=>Ln,L8s:()=>Ls,Ly9:()=>k,M2y:()=>a,MIZ:()=>Ns,MRv:()=>Me,MZg:()=>Ds,NEP:()=>rn,NZg:()=>we,O3z:()=>Xe,OAf:()=>un,OR:()=>fn,OU7:()=>ur,OV7:()=>te,Omj:()=>Gt,Oyi:()=>g,PYm:()=>be,PhF:()=>Un,QCc:()=>C,QRR:()=>Ct,Qg5:()=>Le,QiL:()=>cn,Qvg:()=>ks,RFZ:()=>_,ROF:()=>S,RQH:()=>ae,RuY:()=>ie,SIB:()=>oe,SX0:()=>Bt,SYM:()=>e,SbG:()=>De,SpW:()=>f,T0n:()=>At,TQc:()=>ve,TR1:()=>gt,ToN:()=>Vs,Tr8:()=>bs,Uyb:()=>hs,VGw:()=>D,Vbg:()=>Is,VcC:()=>Et,VfG:()=>Yt,Vn9:()=>st,W0H:()=>xt,XDQ:()=>Gs,XLW:()=>H,XkS:()=>Ks,Xze:()=>p,Y0y:()=>Se,YFo:()=>Tn,YoZ:()=>fe,ZbH:()=>tn,ZjV:()=>Oe,Zz9:()=>x,_JP:()=>ye,_V0:()=>Je,_Yw:()=>re,_k9:()=>K,_tC:()=>Te,a5O:()=>ze,aJk:()=>n,avt:()=>Ue,b9H:()=>zs,bK0:()=>je,bV0:()=>Rs,c17:()=>Ne,cWu:()=>jn,cie:()=>Ft,cye:()=>pn,dDz:()=>yn,deh:()=>cs,dpD:()=>me,e07:()=>Bs,e0R:()=>Ie,e6w:()=>Ee,e7N:()=>$n,eBW:()=>Mn,eEB:()=>T,eZ0:()=>vs,ekb:()=>G,gJX:()=>r,h8e:()=>J,hCO:()=>W,hdR:()=>Vt,i5y:()=>on,iHb:()=>Pt,iJz:()=>lr,iWB:()=>ms,iZT:()=>ps,ik2:()=>ot,jMg:()=>i,jQk:()=>Xn,jQs:()=>wn,jeX:()=>xn,kU:()=>qn,kpP:()=>Ye,kuV:()=>Fe,luS:()=>Hs,lyA:()=>Sn,mKl:()=>As,mTV:()=>Ts,mc4:()=>ft,mhS:()=>et,mm_:()=>m,n9L:()=>ws,nhH:()=>Ws,nr8:()=>Wn,o0g:()=>Dn,o2y:()=>tt,oFR:()=>xs,oHH:()=>it,oT6:()=>h,p2w:()=>$s,p4S:()=>ln,pe_:()=>ee,q1x:()=>fs,q2K:()=>cr,q8u:()=>pe,qCd:()=>Ms,qIC:()=>he,qWM:()=>Fn,qi_:()=>ds,qkr:()=>kn,qw7:()=>c,r7n:()=>Nn,s1s:()=>Ze,sEM:()=>Qe,sHE:()=>ue,sJF:()=>o,sL$:()=>Rt,usg:()=>Kn,uv1:()=>bt,vFR:()=>ne,vtC:()=>gs,vwp:()=>us,w3H:()=>Gn,w6g:()=>ce,wUP:()=>U,wYB:()=>Ss,wYn:()=>In,we_:()=>_n,wm:()=>F,wx7:()=>Fs,x12:()=>Y,xJR:()=>Ge,xQA:()=>Cs,xnO:()=>y,y7R:()=>Xt,yQU:()=>Ot,yj2:()=>w,zbQ:()=>_e,zvY:()=>N,zws:()=>ct});const e="Abs",D="Acos",f="Acosh",m="Add",p="AddN",h="All",d="Any",o="ArgMax",n="ArgMin",a="Asin",c="Asinh",i="Atan",g="Atanh",C="Atan2",I="AvgPool",S="AvgPoolGrad",K="AvgPool3D",z="AvgPool3DGrad",H="BatchMatMul",ct="BatchToSpaceND",N="Bincount",W="BitwiseAnd",k="BroadcastTo",T="BroadcastArgs",_="Cast",r="Ceil",y="ClipByValue",x="Complex",w="ComplexAbs",V="Concat",et="Conv2D",U="Conv2DBackpropFilter",F="Conv2DBackpropInput",Y="Conv3D",tt="Conv3DBackpropFilterV2",ot="Conv3DBackpropInputV2",ft="Cos",gt="Cosh",pt="Cumprod",Pt="Cumsum",Et="CropAndResize",Ct="DenseBincount",At="DepthToSpace",Ft="DepthwiseConv2dNative",Rt="DepthwiseConv2dNativeBackpropFilter",Xt="DepthwiseConv2dNativeBackpropInput",en="Diag",ln="Dilation2D",G="Dilation2DBackpropInput",st="Dilation2DBackpropFilter",it="RealDiv",_t="Einsum",Bt="Elu",wt="EluGrad",Gt="Erf",Vt="Equal",rn="Exp",Tn="ExpandDims",Se="Expm1",us="FFT",cs="Fill",hs="FlipLeftRight",fn="Floor",xn="FloorDiv",ue="FusedBatchNorm",ds="GatherV2",fs="GatherNd",ps="Greater",Es="GreaterEqual",lr="Identity",Le="IFFT",We="Imag",Ue="IsFinite",ms="IsInf",Nn="IsNan",Ke="LeakyRelu",gs="Less",_s="LessEqual",$n="LinSpace",tn="Log",qn="Log1p",be="LogicalAnd",Yt="LogicalNot",Ds="LogicalOr",ce="LogicalXor",Ms="LogSoftmax",he="LowerBound",vs="LRN",de="LRNGrad",Ps="MatrixBandPart",fe="Max",Os="Maximum",Ts="MaxPool",te="MaxPoolGrad",un="MaxPool3D",ur="MaxPool3DGrad",ne="MaxPoolWithArgmax",cr="Mean",Ne="Min",pe="Minimum",wn="MirrorPad",Is="Mod",we="Multinomial",In="Multiply",Fe="Neg",Ot="NotEqual",bt="NonMaxSuppressionV3",pn="NonMaxSuppressionV4",xt="NonMaxSuppressionV5",Fn="OnesLike",_n="OneHot",cn="Pack",Sn="PadV2",Ln="Pool",ee="Pow",Dn="Prelu",Ve="Prod",yn="RaggedGather",se="RaggedRange",ke="RaggedTensorToTensor",Ee="Range",Ge="Real",Vn="Reciprocal",kn="Relu",ys="Reshape",me="ResizeNearestNeighbor",ge="ResizeNearestNeighborGrad",re="ResizeBilinear",_e="ResizeBilinearGrad",De="Relu6",As="Reverse",Bs="Round",Rs="Rsqrt",Cs="ScatterNd",oe="TensorScatterUpdate",Wn="SearchSorted",Un="Select",xs="Selu",$s="Slice",ae="Sin",Ss="Sinh",on="Sign",ze="Sigmoid",Me="Softplus",Ut="Sqrt",He="Sum",ve="SpaceToBatchND",Ls="SplitV",Pe="Softmax",Xe="SparseFillEmptyRows",Ws="SparseReshape",Gn="SparseSegmentMean",Oe="SparseSegmentSum",Us="SparseToDense",Te="SquaredDifference",je="Square",Ie="StaticRegexReplace",Xn="StridedSlice",ye="StringNGrams",Ze="StringSplit",Ks="StringToHashBucketFast",bs="Sub",Qe="Tan",Ns="Tanh",ws="Tile",jn="TopK",Fs="Transform",Ae="Transpose",Ye="Unique",Vs="Unpack",ks="UnsortedSegmentSum",Gs="UpperBound",ie="ZerosLike",J="Step",Mn="FromPixels",zs="RotateWithOffset",Kn="_FusedMatMul",Je="FusedConv2D",Hs="FusedDepthwiseConv2D"},8415:(Q,v,t)=>{"use strict";t.d(v,{Li:()=>a,T3:()=>g,bt:()=>i,nE:()=>c,pI:()=>h,tr:()=>o,uk:()=>d,wC:()=>n});var e=t(2433),D=t(3860),f=t(6030);const m=(0,D.R)("kernelRegistry",()=>new Map),p=(0,D.R)("gradRegistry",()=>new Map);function h(I,S){const K=C(I,S);return m.get(K)}function d(I){return p.get(I)}function o(I){const S=m.entries(),K=[];for(;;){const{done:z,value:H}=S.next();if(z)break;const[ct,N]=H,[W]=ct.split("_");W===I&&K.push(N)}return K}function n(I){const{kernelName:S,backendName:K}=I,z=C(S,K);m.has(z)&&f.Z(`The kernel '${S}' for backend '${K}' is already registered`),m.set(z,I)}function a(I){const{kernelName:S}=I;p.has(S)&&(0,e.OB)().getBool("DEBUG")&&f.Z(`Overriding the gradient for '${S}'`),p.set(S,I)}function c(I,S){const K=C(I,S);if(!m.has(K))throw new Error(`The kernel '${I}' for backend '${S}' is not registered`);m.delete(K)}function i(I){if(!p.has(I))throw new Error(`The gradient '${I}' for backend is not registered`);p.delete(I)}function g(I,S){o(I).forEach(z=>{n(Object.assign({},z,{backendName:S}))})}function C(I,S){return`${S}_${I}`}},6030:(Q,v,t)=>{"use strict";t.d(v,{Z:()=>D,c:()=>f});var e=t(2433);function D(...m){(0,e.OB)().getBool("IS_TEST")||(0,e.OB)().getBool("PROD")||console.warn(...m)}function f(...m){(0,e.OB)().getBool("IS_TEST")||(0,e.OB)().getBool("PROD")||console.log(...m)}},2992:(Q,v,t)=>{"use strict";t.d(v,{W:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({abs_:function p(d){const o=(0,f._1)(d,"x","abs");return e.BV.runKernel("complex64"===o.dtype?D.yj2:D.SYM,{x:o})}})},2485:(Q,v,t)=>{"use strict";t.d(v,{K:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({acos_:function p(d){const n={x:(0,f._1)(d,"x","acos")};return e.BV.runKernel(D.VGw,n)}})},6725:(Q,v,t)=>{"use strict";t.d(v,{_:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({acosh_:function p(d){const n={x:(0,f._1)(d,"x","acosh")};return e.BV.runKernel(D.SpW,n)}})},319:(Q,v,t)=>{"use strict";t.d(v,{I:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({add_:function h(o,n){let a=(0,m._1)(o,"a","add"),c=(0,m._1)(n,"b","add");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.mm_,{a,b:c})}})},4187:(Q,v,t)=>{"use strict";t.d(v,{$:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({all_:function p(d,o=null,n=!1){const c={x:(0,f._1)(d,"x","all","bool")};return e.BV.runKernel(D.oT6,c,{axis:o,keepDims:n})}})},2247:(Q,v,t)=>{"use strict";t.d(v,{Y:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({any_:function p(d,o=null,n=!1){const c={x:(0,f._1)(d,"x","any","bool")};return e.BV.runKernel(D.IKK,c,{axis:o,keepDims:n})}})},1257:(Q,v,t)=>{"use strict";t.d(v,{N:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({argMax_:function p(d,o=0){const a={x:(0,f._1)(d,"x","argMax")};return e.BV.runKernel(D.sJF,a,{axis:o})}})},1019:(Q,v,t)=>{"use strict";t.d(v,{v:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({argMin_:function p(d,o=0){const a={x:(0,f._1)(d,"x","argMin")};return e.BV.runKernel(D.aJk,a,{axis:o})}})},7194:(Q,v,t)=>{"use strict";t.d(v,{Z:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({asin_:function p(d){const n={x:(0,f._1)(d,"x","asin")};return e.BV.runKernel(D.M2y,n)}})},231:(Q,v,t)=>{"use strict";t.d(v,{V:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({asinh_:function p(d){const n={x:(0,f._1)(d,"x","asinh")};return e.BV.runKernel(D.qw7,n)}})},1282:(Q,v,t)=>{"use strict";t.d(v,{z:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({atan_:function p(d){const n={x:(0,f._1)(d,"x","atan")};return e.BV.runKernel(D.jMg,n)}})},9851:(Q,v,t)=>{"use strict";t.d(v,{f:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({atan2_:function h(o,n){let a=(0,m._1)(o,"a","atan2"),c=(0,m._1)(n,"b","atan2");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.QCc,{a,b:c})}})},9776:(Q,v,t)=>{"use strict";t.d(v,{C:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({atanh_:function p(d){const n={x:(0,f._1)(d,"x","atanh")};return e.BV.runKernel(D.Oyi,n)}})},282:(Q,v,t)=>{"use strict";t.d(v,{w:()=>a});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(4879),h=t(7202),d=t(5948),o=t(3626);const a=(0,d.op)({avgPool_:function n(c,i,g,C,I){const S=(0,f._1)(c,"x","avgPool","float32");m.hu(h.jT(g,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${g} and dilations '1'`);let z=S,H=!1;3===S.rank&&(H=!0,z=(0,o.X)(S,[1,S.shape[0],S.shape[1],S.shape[2]])),m.hu(4===z.rank,()=>`Error in avgPool: x must be rank 4 but got rank ${z.rank}.`),h.m("avgPool",C,I);let W=e.BV.runKernel(D.JhU,{x:z},{filterSize:i,strides:g,pad:C,dimRoundingMode:I});return W=(0,p.p)(W,S.dtype),H?(0,o.X)(W,[W.shape[1],W.shape[2],W.shape[3]]):W}})},2745:(Q,v,t)=>{"use strict";t.d(v,{LJ:()=>o,Q3:()=>d,Vh:()=>f,YB:()=>D,kz:()=>m,lB:()=>h,rv:()=>p,sY:()=>n});var e=t(62);function D(a,c){for(let i=0;i<a.length;++i)if(a[a.length-i-1]!==c-1-i)return!1;return!0}function f(a,c,i){const g=a.length+c.length,C=[];let I=0,S=0;for(let K=0;K<g;K++)-1===i.indexOf(K)?C.push(a[I++]):C.push(c[S++]);return C}function m(a,c){const i=[],g=a.length;for(let I=0;I<g;I++)-1===c.indexOf(I)&&i.push(a[I]);return[i,c.map(I=>a[I])]}function p(a,c){return f(a,c.map(g=>1),c)}function h(a,c,i){e.hu(D(c,i),()=>`${a} supports only inner-most axes for now. Got axes ${c} and rank-${i} input.`)}function d(a,c){if(D(a,c))return null;const i=[];for(let g=0;g<c;++g)-1===a.indexOf(g)&&i.push(g);return a.forEach(g=>i.push(g)),i}function o(a){return a.map((c,i)=>[i,c]).sort((c,i)=>c[1]-i[1]).map(c=>c[0])}function n(a,c){const i=[];for(let g=c-a;g<c;++g)i.push(g);return i}},1601:(Q,v,t)=>{"use strict";t.d(v,{E:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({batchToSpaceND_:function h(o,n,a){const c=(0,f._1)(o,"x","batchToSpaceND"),i=n.reduce((I,S)=>I*S);return m.hu(c.rank>=1+n.length,()=>`input rank is ${c.rank} but should be > than blockShape.length ${n.length}`),m.hu(a.length===n.length,()=>`crops.length is ${a.length} but should be equal to blockShape.length  ${n.length}`),m.hu(c.shape[0]%i==0,()=>`input tensor batch is ${c.shape[0]} but is not divisible by the product of the elements of blockShape ${n.join(" * ")} === ${i}`),e.BV.runKernel(D.zws,{x:c},{blockShape:n,crops:a})}})},5707:(Q,v,t)=>{"use strict";t.d(v,{t:()=>n});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(3626);function h(a){let c;return c=0===a.rank||1===a.rank?(0,p.X)(a,[1,1,1,a.size]):2===a.rank?(0,p.X)(a,[1,1,a.shape[0],a.shape[1]]):3===a.rank?(0,p.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]]):a,c}const n=(0,t(5948).op)({batchNorm_:function o(a,c,i,g,C,I){null==I&&(I=.001);const S=(0,f._1)(a,"x","batchNorm"),K=(0,f._1)(c,"mean","batchNorm"),z=(0,f._1)(i,"variance","batchNorm");let H,ct;null!=C&&(H=(0,f._1)(C,"scale","batchNorm")),null!=g&&(ct=(0,f._1)(g,"offset","batchNorm")),m.hu(K.rank===z.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),m.hu(null==ct||K.rank===ct.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),m.hu(null==H||K.rank===H.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const W={x:h(S),scale:H,offset:ct,mean:K,variance:z},T=e.BV.runKernel(D.sHE,W,{varianceEpsilon:I});return(0,p.X)(T,S.shape)}})},6172:(Q,v,t)=>{"use strict";t.d(v,{U:()=>n});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(7871),h=t(5948),d=t(3626);const n=(0,h.op)({broadcastTo_:function o(a,c){let i=(0,f._1)(a,"broadcastTo","x");const g=i.shape;if((0,m.Mu)(c),c.length<i.rank)throw new Error(`broadcastTo(): shape.length=${c.length} < input.rank=${i.rank}.`);if(c.length>i.rank){const H=i.shape.slice();for(;H.length<c.length;)H.unshift(1);i=(0,d.X)(i,H)}const C=i.shape,I=Array.from(c);for(let H=c.length-1;H>=0;H--)if(C[H]===c[H])I[H]=1;else if(1!==i.shape[H])throw new Error(`broadcastTo(): [${g}] cannot be broadcast to [${c}].`);return 0===I.map((H,ct)=>H>1?ct:-1).filter(H=>H>=0).length?(0,p.d)(i):e.BV.runKernel(D.n9L,{x:i},{reps:I})}})},3469:(Q,v,t)=>{"use strict";function e(m,p){const h=m.length,d=[];for(let o=0;o<h;o++){const n=h-1-o;(p[p.length-1-o]||1)>1&&1===(m[n]||1)&&d.unshift(n)}return d}function D(m,p){const h=[];for(let d=0;d<p.length;d++){const o=m[m.length-d-1],n=p.length-d-1;(null==o||1===o&&p[n]>1)&&h.unshift(n)}return h}function f(m,p){const h=Math.max(m.length,p.length),d=new Array(h);for(let o=0;o<h;o++){let n=m[m.length-o-1];null==n&&(n=1);let a=p[p.length-o-1];if(null==a&&(a=1),1===n)d[h-o-1]=a;else if(1===a)d[h-o-1]=n;else{if(n!==a)throw Error(`Operands could not be broadcast together with shapes ${m} and ${p}.`);d[h-o-1]=n}}return d}t.r(v),t.d(v,{assertAndGetBroadcastShape:()=>f,getBroadcastDims:()=>e,getReductionAxes:()=>D})},4062:(Q,v,t)=>{"use strict";t.d(v,{f:()=>f});var e=t(8106),D=t(62);function f(m,p="float32",h){return p=p||"float32",D.Mu(m),new e.YD(m,p,h)}},4879:(Q,v,t)=>{"use strict";t.d(v,{p:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({cast_:function h(o,n){const a=(0,f._1)(o,"x","cast");if(!m.LP(n))throw new Error(`Failed to cast to unknown dtype ${n}`);if("string"===n&&"string"!==a.dtype||"string"!==n&&"string"===a.dtype)throw new Error("Only strings can be casted to strings");return e.BV.runKernel(D.RFZ,{x:a},{dtype:n})}})},9249:(Q,v,t)=>{"use strict";t.d(v,{m:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({ceil_:function p(d){const n={x:(0,f._1)(d,"x","ceil","float32")};return e.BV.runKernel(D.gJX,n)}})},1935:(Q,v,t)=>{"use strict";t.d(v,{i:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(7237);const o=(0,t(5948).op)({clipByValue_:function d(n,a,c){const i=(0,f._1)(n,"x","clipByValue");return m.hu(a<=c,()=>`Error in clip: min (${a}) must be less than or equal to max (${c}).`),a===c?(0,p.h)(i.shape,a,i.dtype):e.BV.runKernel(D.xnO,{x:i},{clipValueMin:a,clipValueMax:c})}})},7871:(Q,v,t)=>{"use strict";t.d(v,{d:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({clone_:function p(d){const n={x:(0,f._1)(d,"x","clone","string_or_numeric")};return e.BV.runKernel(D.iJz,n)}})},7401:(Q,v,t)=>{"use strict";t.d(v,{P:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({complex_:function h(o,n){const a=(0,f._1)(o,"real","complex"),c=(0,f._1)(n,"imag","complex");return m.k5(a.shape,c.shape,`real and imag shapes, ${a.shape} and ${c.shape}, must match in call to tf.complex().`),e.BV.runKernel(D.Zz9,{real:a,imag:c})}})},4664:(Q,v,t)=>{"use strict";t.d(v,{z:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(7871);const o=(0,t(5948).op)({concat_:function d(n,a=0){(0,m.hu)(n.length>=1,()=>"Pass at least one tensor to concat");const c=(0,f.sI)(n,"tensors","concat","string_or_numeric");return"complex64"===c[0].dtype&&c.forEach(C=>{if("complex64"!==C.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${C.dtype}. `)}),1===c.length?(0,p.d)(c[0]):e.BV.runKernel(D.Eh3,c,{axis:a})}})},7182:(Q,v,t)=>{"use strict";t.d(v,{P:()=>o});var e=t(4810),D=t(62),f=t(6509),m=t(7202),p=t(5948),h=t(3626);const o=(0,p.op)({conv1d_:function d(n,a,c,i,g="NWC",C=1,I){const S=(0,e._1)(n,"x","conv1d"),K=(0,e._1)(a,"filter","conv1d");let z=S,H=!1;2===S.rank&&(H=!0,z=(0,h.X)(S,[1,S.shape[0],S.shape[1]])),D.hu(3===z.rank,()=>`Error in conv1d: input must be rank 3, but got rank ${z.rank}.`),D.hu(3===K.rank,()=>`Error in conv1d: filter must be rank 3, but got rank ${K.rank}.`),m.m("conv1d",i,I),D.hu(z.shape[2]===K.shape[1],()=>`Error in conv1d: depth of input (${z.shape[2]}) must match input depth for filter ${K.shape[1]}.`),D.hu(m.jT(c,C),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${c} and dilation '${C}'`),D.hu(m.U3(C),()=>"Error in conv1D: Dilated rates should be larger than 0."),D.hu(m.U3(c),()=>"Error in conv1D: Stride should be larger than 0."),D.hu("NWC"===g,()=>`Error in conv1d: got dataFormat of ${g} but only NWC is currently supported.`);const ct=(0,h.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]]),N=(0,h.X)(z,[z.shape[0],1,z.shape[1],z.shape[2]]),_=(0,f.T)(N,ct,[1,c],i,"NHWC",[1,C],I);return(0,h.X)(_,H?[_.shape[2],_.shape[3]]:[_.shape[0],_.shape[2],_.shape[3]])}})},6509:(Q,v,t)=>{"use strict";t.d(v,{T:()=>n});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(7202),h=t(5948),d=t(3626);const n=(0,h.op)({conv2d_:function o(a,c,i,g,C="NHWC",I=[1,1],S){const K=(0,f._1)(a,"x","conv2d","float32"),z=(0,f._1)(c,"filter","conv2d","float32");let H=K,ct=!1;3===K.rank&&(ct=!0,H=(0,d.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),m.hu(4===H.rank,()=>`Error in conv2d: input must be rank 4, but got rank ${H.rank}.`),m.hu(4===z.rank,()=>`Error in conv2d: filter must be rank 4, but got rank ${z.rank}.`),p.m("conv2d",g,S);const N="NHWC"===C?H.shape[3]:H.shape[1];m.hu(N===z.shape[2],()=>`Error in conv2d: depth of input (${N}) must match input depth for filter ${z.shape[2]}.`),m.hu(p.jT(i,I),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${i} and dilations '${I}'`),m.hu(p.U3(I),()=>"Error in conv2D: Dilated rates should be larger than 0."),m.hu(p.U3(i),()=>"Error in conv2D: Strides should be larger than 0.");const T=e.BV.runKernel(D.mhS,{x:H,filter:z},{strides:i,pad:g,dataFormat:C,dilations:I,dimRoundingMode:S});return ct?(0,d.X)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}})},4867:(Q,v,t)=>{"use strict";t.d(v,{p:()=>o});var e=t(2882),D=t(6338),f=t(62),m=t(7202),p=t(5948),h=t(3626);const o=(0,p.op)({conv2DBackpropFilter_:function d(n,a,c,i,g,C="NHWC",I){let S=n;3===n.rank&&(S=(0,h.X)(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let K=a;3===K.rank&&(K=(0,h.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]])),f.hu(4===S.rank,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${S.shape}.`),f.hu(4===K.rank,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${K.shape}.`),f.hu(4===c.length,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${c}.`);const z="NHWC"===C?S.shape[3]:S.shape[1],H="NHWC"===C?K.shape[3]:K.shape[1];return f.hu(z===c[2],()=>`Error in conv2dDerFilter: depth of input ${z}) must match input depth in filter (${c[2]}.`),f.hu(H===c[3],()=>`Error in conv2dDerFilter: depth of dy (${H}) must match output depth for filter (${c[3]}).`),m.m("conv2dDerFilter",g,I),e.BV.runKernel(D.wUP,{x:S,dy:K},{strides:i,pad:g,dataFormat:C,dimRoundingMode:I,filterShape:c})}})},8445:(Q,v,t)=>{"use strict";t.d(v,{_:()=>o});var e=t(2882),D=t(6338),f=t(62),m=t(7202),p=t(5948),h=t(3626);const o=(0,p.op)({conv2DBackpropInput_:function d(n,a,c,i,g,C="NHWC",I){f.hu(n.length===a.rank,()=>`Length of inShape (${n.length}) and rank of dy (${a.rank}) must match`);let S=n,K=a,z=!1;3===a.rank&&(z=!0,K=(0,h.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]]),S=[1,n[0],n[1],n[2]]),f.hu(4===S.length,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${S.length}.`),f.hu(4===K.rank,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${K.rank}`),f.hu(4===c.rank,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${c.rank}`);const H="NHWC"===C?S[3]:S[1],ct="NHWC"===C?K.shape[3]:K.shape[1];f.hu(H===c.shape[2],()=>`Error in conv2dDerInput: depth of input (${H}) must match input depth for filter ${c.shape[2]}.`),f.hu(ct===c.shape[3],()=>`Error in conv2dDerInput: depth of output (${ct}) must match output depth for filter ${c.shape[3]}.`),m.m("conv2dDerInput",g,I);const k=e.BV.runKernel(D.wm,{dy:K,filter:c},{strides:i,pad:g,dataFormat:C,dimRoundingMode:I,inputShape:S});return z?(0,h.X)(k,[k.shape[1],k.shape[2],k.shape[3]]):k}})},9053:(Q,v,t)=>{"use strict";t.d(v,{b:()=>p});var e=t(4810),D=t(8445);const p=(0,t(5948).op)({conv2dTranspose_:function m(h,d,o,n,a,c){const i=(0,e._1)(h,"x","conv2dTranspose"),g=(0,e._1)(d,"filter","conv2dTranspose");return(0,D._)(o,i,g,n,a,"NHWC",c)}})},8921:(Q,v,t)=>{"use strict";t.d(v,{_:()=>d});var e=t(2882),D=t(6338),f=t(62),m=t(5948),p=t(3626);const d=(0,m.op)({conv3DBackpropInput_:function h(o,n,a,c,i){f.hu(o.length===n.rank,()=>`Length of inShape (${o.length}) and rank of dy (${n.rank}) must match`);let g=o,C=n,I=!1;4===n.rank&&(I=!0,C=(0,p.X)(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]),g=[1,o[0],o[1],o[2],o[3]]);const S=g[4],K=C.shape[4];f.hu(5===g.length,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${g.length}.`),f.hu(5===C.rank,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${C.rank}`),f.hu(5===a.rank,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${a.rank}`),f.hu(S===a.shape[3],()=>`Error in conv3dDerInput: depth of input (${S}) must match input depth for filter ${a.shape[3]}.`),f.hu(K===a.shape[4],()=>`Error in conv3dDerInput: depth of output (${K}) must match output depth for filter ${a.shape[4]}.`);const ct=e.BV.runKernel(D.ik2,{dy:C,filter:a},{pad:i,strides:c,inputShape:g});return I?(0,p.X)(ct,[ct.shape[1],ct.shape[2],ct.shape[3],ct.shape[4]]):ct}})},7202:(Q,v,t)=>{"use strict";t.d(v,{I0:()=>S,Ix:()=>p,Rf:()=>D,U3:()=>z,Xw:()=>f,aO:()=>n,jT:()=>K,jw:()=>h,m:()=>ct,pl:()=>m,sl:()=>H});var e=t(62);function D(N,W,k,T,_="NHWC",r){return p(N,[...W,N[3]],k,r,T,null,null,H(_))}function f(N,W,k,T,_,r,y="channelsLast"){const[x,w]=a(W);let V;if("channelsLast"===y)V=[x,w,N[3],N[3]];else{if("channelsFirst"!==y)throw new Error(`Unknown dataFormat ${y}`);V=[x,w,N[1],N[1]]}return p(N,V,k,T,_,r,!1,y)}function m(N,W,k,T,_,r,y="NDHWC"){const[x,w,V]=c(W);let et,U;if("NDHWC"===y)U="channelsLast",et=[x,w,V,N[4],N[4]];else{if("NCDHW"!==y)throw new Error(`Unknown dataFormat ${y}`);U="channelsFirst",et=[x,w,V,N[1],N[1]]}return h(N,et,k,T,_,!1,U,r)}function p(N,W,k,T,_,r,y=!1,x="channelsLast"){let[w,V,et,U]=[-1,-1,-1,-1];if("channelsLast"===x)[w,V,et,U]=N;else{if("channelsFirst"!==x)throw new Error(`Unknown dataFormat ${x}`);[w,U,V,et]=N}const[F,Y,,tt]=W,[ot,ft]=a(k),[gt,pt]=a(T),Pt=i(F,gt),Et=i(Y,pt),{padInfo:Ct,outHeight:At,outWidth:Ft}=function g(N,W,k,T,_,r,y,x,w){let V,et,U;if("number"==typeof N){V={top:N,bottom:N,left:N,right:N,type:0===N?"VALID":"NUMBER"};const Y=function d(N,W,k,T,_){null==T&&(T=n(N,W,k));const y=N[1];return[I((N[0]-W+2*T)/k+1,_),I((y-W+2*T)/k+1,_)]}([W,k],r,T,N,x);et=Y[0],U=Y[1]}else if("same"===N){et=Math.ceil(W/T),U=Math.ceil(k/_);const F=Math.max(0,(et-1)*T+r-W),Y=Math.max(0,(U-1)*_+y-k),tt=Math.floor(F/2),ot=F-tt,ft=Math.floor(Y/2);V={top:tt,bottom:ot,left:ft,right:Y-ft,type:"SAME"}}else if("valid"===N)V={top:0,bottom:0,left:0,right:0,type:"VALID"},et=Math.ceil((W-r+1)/T),U=Math.ceil((k-y+1)/_);else{if("object"!=typeof N)throw Error(`Unknown padding parameter: ${N}`);{const F="channelsLast"===w?N[1][0]:N[2][0],Y="channelsLast"===w?N[1][1]:N[2][1],tt="channelsLast"===w?N[2][0]:N[3][0],ot="channelsLast"===w?N[2][1]:N[3][1];V={top:F,bottom:Y,left:tt,right:ot,type:0===F&&0===Y&&0===tt&&0===ot?"VALID":"EXPLICIT"},et=I((W-r+F+Y)/T+1,x),U=I((k-y+tt+ot)/_+1,x)}}return{padInfo:V,outHeight:et,outWidth:U}}(_,V,et,ot,ft,Pt,Et,r,x),Rt=y?tt*U:tt;let Xt;return"channelsFirst"===x?Xt=[w,Rt,At,Ft]:"channelsLast"===x&&(Xt=[w,At,Ft,Rt]),{batchSize:w,dataFormat:x,inHeight:V,inWidth:et,inChannels:U,outHeight:At,outWidth:Ft,outChannels:Rt,padInfo:Ct,strideHeight:ot,strideWidth:ft,filterHeight:F,filterWidth:Y,effectiveFilterHeight:Pt,effectiveFilterWidth:Et,dilationHeight:gt,dilationWidth:pt,inShape:N,outShape:Xt,filterShape:W}}function h(N,W,k,T,_,r=!1,y="channelsLast",x){let[w,V,et,U,F]=[-1,-1,-1,-1,-1];if("channelsLast"===y)[w,V,et,U,F]=N;else{if("channelsFirst"!==y)throw new Error(`Unknown dataFormat ${y}`);[w,F,V,et,U]=N}const[Y,tt,ot,,ft]=W,[gt,pt,Pt]=c(k),[Et,Ct,At]=c(T),Ft=i(Y,Et),Rt=i(tt,Ct),Xt=i(ot,At),{padInfo:en,outDepth:ln,outHeight:G,outWidth:st}=function C(N,W,k,T,_,r,y,x,w,V,et){let U,F,Y,tt;if("valid"===N&&(N=0),"number"==typeof N){U={top:N,bottom:N,left:N,right:N,front:N,back:N,type:0===N?"VALID":"NUMBER"};const ft=function o(N,W,k,T,_,r){null==_&&(_=n(N,W[0],T[0]));const y=[0,0,0,k];for(let x=0;x<3;x++)N[x]+2*_>=W[x]&&(y[x]=I((N[x]-W[x]+2*_)/T[x]+1,r));return y}([W,k,T,1],[x,w,V],1,[_,r,y],N,et);F=ft[0],Y=ft[1],tt=ft[2]}else{if("same"!==N)throw Error(`Unknown padding parameter: ${N}`);{F=Math.ceil(W/_),Y=Math.ceil(k/r),tt=Math.ceil(T/y);const ot=(F-1)*_+x-W,ft=(Y-1)*r+w-k,gt=(tt-1)*y+V-T,pt=Math.floor(ot/2),Pt=ot-pt,Et=Math.floor(ft/2),Ct=ft-Et,At=Math.floor(gt/2);U={top:Et,bottom:Ct,left:At,right:gt-At,front:pt,back:Pt,type:"SAME"}}}return{padInfo:U,outDepth:F,outHeight:Y,outWidth:tt}}(_,V,et,U,gt,pt,Pt,Ft,Rt,Xt,x),it=r?ft*F:ft;let _t;return"channelsFirst"===y?_t=[w,it,ln,G,st]:"channelsLast"===y&&(_t=[w,ln,G,st,it]),{batchSize:w,dataFormat:y,inDepth:V,inHeight:et,inWidth:U,inChannels:F,outDepth:ln,outHeight:G,outWidth:st,outChannels:it,padInfo:en,strideDepth:gt,strideHeight:pt,strideWidth:Pt,filterDepth:Y,filterHeight:tt,filterWidth:ot,effectiveFilterDepth:Ft,effectiveFilterHeight:Rt,effectiveFilterWidth:Xt,dilationDepth:Et,dilationHeight:Ct,dilationWidth:At,inShape:N,outShape:_t,filterShape:W}}function n(N,W,k,T=1){const _=i(W,T);return Math.floor((N[0]*(k-1)-k+_)/2)}function a(N){return"number"==typeof N?[N,N,N]:2===N.length?[N[0],N[1],1]:N}function c(N){return"number"==typeof N?[N,N,N]:N}function i(N,W){return W<=1?N:N+(N-1)*(W-1)}function I(N,W){if(!W)return Math.trunc(N);switch(W){case"round":return Math.round(N);case"ceil":return Math.ceil(N);case"floor":return Math.floor(N);default:throw new Error(`Unknown roundingMode ${W}`)}}function S(N){const[W,k,T]=a(N);return 1===W&&1===k&&1===T}function K(N,W){return S(N)||S(W)}function z(N){return a(N).every(W=>W>0)}function H(N){if("NHWC"===N)return"channelsLast";if("NCHW"===N)return"channelsFirst";throw new Error(`Unknown dataFormat ${N}`)}function ct(N,W,k){if(null!=k){if("string"==typeof W)throw Error(`Error in ${N}: pad must be an integer when using dimRoundingMode ${k} but got pad ${W}.`);if("number"==typeof W)e.hu(e.GN(W),()=>`Error in ${N}: pad must be an integer when using dimRoundingMode ${k} but got pad ${W}.`);else{if("object"!=typeof W)throw Error(`Error in ${N}: Unknown padding parameter: ${W}`);W.forEach(T=>{T.forEach(_=>{e.hu(e.GN(_),()=>`Error in ${N}: pad must be an integer when using dimRoundingMode ${k} but got pad ${_}.`)})})}}}},1588:(Q,v,t)=>{"use strict";t.d(v,{m:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({cos_:function p(d){const n={x:(0,f._1)(d,"x","cos","float32")};return e.BV.runKernel(D.mc4,n)}})},3538:(Q,v,t)=>{"use strict";t.d(v,{f:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({cosh_:function p(d){const n={x:(0,f._1)(d,"x","cosh","float32")};return e.BV.runKernel(D.TR1,n)}})},233:(Q,v,t)=>{"use strict";t.d(v,{$:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({cumprod_:function p(d,o=0,n=!1,a=!1){const i={x:(0,f._1)(d,"x","cumprod")};return e.BV.runKernel(D.Byc,i,{axis:o,exclusive:n,reverse:a})}})},5023:(Q,v,t)=>{"use strict";t.d(v,{z:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({cumsum_:function p(d,o=0,n=!1,a=!1){const i={x:(0,f._1)(d,"x","cumsum")};return e.BV.runKernel(D.iHb,i,{axis:o,exclusive:n,reverse:a})}})},8663:(Q,v,t)=>{"use strict";t.d(v,{n:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({depthToSpace_:function h(o,n,a="NHWC"){const c=(0,f._1)(o,"x","depthToSpace","float32"),i="NHWC"===a?c.shape[1]:c.shape[2],g="NHWC"===a?c.shape[2]:c.shape[3],C="NHWC"===a?c.shape[3]:c.shape[1];return m.hu(n>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${n}`),m.hu(i*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${n}  for depthToSpace with input shape\n    ${c.shape}`),m.hu(g*n>=0,()=>`Negative dimension size caused by overflow when multiplying\n    ${g} and ${n} for depthToSpace with input shape\n        ${c.shape}`),m.hu(C%(n*n)==0,()=>`Dimension size must be evenly divisible by ${n*n} but is ${C} for depthToSpace with input shape ${c.shape}`),e.BV.runKernel(D.T0n,{x:c},{blockSize:n,dataFormat:a})}})},2514:(Q,v,t)=>{"use strict";t.d(v,{B:()=>n});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(7202),h=t(5948),d=t(3626);const n=(0,h.op)({depthwiseConv2d_:function o(a,c,i,g,C="NHWC",I=[1,1],S){const K=(0,f._1)(a,"x","depthwiseConv2d","float32"),z=(0,f._1)(c,"filter","depthwiseConv2d","float32");let H=K,ct=!1;3===K.rank&&(ct=!0,H=(0,d.X)(K,[1,K.shape[0],K.shape[1],K.shape[2]])),m.hu(4===H.rank,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${H.rank}.`),m.hu(4===z.rank,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${z.rank}.`);const N="NHWC"===C?H.shape[3]:H.shape[1];m.hu(N===z.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${N}) must match the inChannels dimension in filter ${z.shape[2]}.`),p.m("depthwiseConv2d",g,S);const T=e.BV.runKernel(D.cie,{x:H,filter:z},{strides:i,pad:g,dataFormat:C,dilations:I,dimRoundingMode:S});return ct?(0,d.X)(T,[T.shape[1],T.shape[2],T.shape[3]]):T}})},527:(Q,v,t)=>{"use strict";t.d(v,{z:()=>h});var e=t(2882),D=t(6338),f=t(5948),m=t(3626);const h=(0,f.op)({depthwiseConv2dNativeBackpropFilter_:function p(d,o,n,a,c,i=[1,1],g){let C=d;3===d.rank&&(C=(0,m.X)(d,[1,d.shape[0],d.shape[1],d.shape[2]]));let I=o;return 3===I.rank&&(I=(0,m.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]])),e.BV.runKernel(D.sL$,{x:C,dy:I},{strides:a,pad:c,dimRoundingMode:g,dilations:i,filterShape:n})}})},3905:(Q,v,t)=>{"use strict";t.d(v,{v:()=>h});var e=t(2882),D=t(6338),f=t(5948),m=t(3626);const h=(0,f.op)({depthwiseConv2dNativeBackpropInput_:function p(d,o,n,a,c,i=[1,1],g){let C=o,I=!1;3===o.rank&&(I=!0,C=(0,m.X)(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const z=e.BV.runKernel(D.y7R,{dy:C,filter:n},{strides:a,pad:c,dimRoundingMode:g,dilations:i,inputShape:d});return I?(0,m.X)(z,[z.shape[1],z.shape[2],z.shape[3]]):z}})},7501:(Q,v,t)=>{"use strict";t.d(v,{W:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(5948),h=t(3626);const o=(0,p.op)({dilation2d_:function d(n,a,c,i,g=[1,1],C="NHWC"){const I=(0,f._1)(n,"x","dilation2d"),S=(0,f._1)(a,"filter","dilation2d");m.hu(3===I.rank||4===I.rank,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${I.rank}.`),m.hu(3===S.rank,()=>`Error in dilation2d: filter must be rank 3, but got rank ${S.rank}.`),m.hu("NHWC"===C,()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${C}`);let K=I,z=!1;3===I.rank&&(K=(0,h.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]]),z=!0),m.hu(K.shape[3]===S.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${K.shape[3]} vs ${S.shape[2]}`);const N=e.BV.runKernel(D.p4S,{x:K,filter:S},{strides:c,pad:i,dilations:g});return z?(0,h.X)(N,[N.shape[1],N.shape[2],N.shape[3]]):N}})},8366:(Q,v,t)=>{"use strict";t.d(v,{h:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(4404);const o=(0,t(5948).op)({div_:function d(n,a){let c=(0,m._1)(n,"a","div"),i=(0,m._1)(a,"b","div");return[c,i]=(0,f.makeTypesMatch)(c,i),"int32"===c.dtype&&"int32"===i.dtype?(0,p.q)(c,i):e.BV.runKernel(D.oHH,{a:c,b:i},{})}})},8464:(Q,v,t)=>{"use strict";t.d(v,{N:()=>n});var e=t(7073),D=t(4810),f=t(8366),m=t(5393),p=t(5948),h=t(8793),d=t(9314);const n=(0,p.op)({divNoNan_:function o(a,c){let i=(0,D._1)(a,"a","div"),g=(0,D._1)(c,"b","div");[i,g]=(0,e.makeTypesMatch)(i,g);const C=(0,f.h)(i,g),I=(0,d.P)(C),S=(0,m.D)(g,I);return(0,h.a)(S,I,C)}})},4258:(Q,v,t)=>{"use strict";t.d(v,{A:()=>d});var e=t(4810),D=t(62),f=t(4291),m=t(5948),p=t(3626);const d=(0,m.op)({dot_:function h(o,n){const a=(0,e._1)(o,"t1","dot"),c=(0,e._1)(n,"t2","dot");D.hu(!(1!==a.rank&&2!==a.rank||1!==c.rank&&2!==c.rank),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${a.rank} and ${c.rank}.`);const i=1===a.rank?a.size:a.shape[1],g=1===c.rank?c.size:c.shape[0];if(D.hu(i===g,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${g}.`),1===a.rank&&1===c.rank){const C=(0,p.X)(a,[1,-1]),I=(0,p.X)(c,[-1,1]),S=(0,f.O)(C,I);return(0,p.X)(S,[])}if(1===a.rank&&2===c.rank){const C=(0,p.X)(a,[1,-1]),I=(0,p.X)(c,[c.shape[0],c.shape[1]]),S=(0,f.O)(C,I);return(0,p.X)(S,[S.size])}if(2===a.rank&&1===c.rank){const C=(0,p.X)(c,[-1,1]),I=(0,f.O)(a,C);return(0,p.X)(I,[I.size])}{const C=(0,p.X)(c,[c.shape[0],c.shape[1]]);return(0,f.O)(a,C)}}})},6818:(Q,v,t)=>{"use strict";t.d(v,{p:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({elu_:function p(d){const n={x:(0,f._1)(d,"x","elu","float32")};return e.BV.runKernel(D.SX0,n)}})},5393:(Q,v,t)=>{"use strict";t.d(v,{D:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({equal_:function d(n,a){let c=(0,m._1)(n,"a","equal","string_or_numeric"),i=(0,m._1)(a,"b","equal","string_or_numeric");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D.hdR,{a:c,b:i})}})},450:(Q,v,t)=>{"use strict";t.d(v,{q:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(4879);const o=(0,t(5948).op)({erf_:function d(n){let a=(0,f._1)(n,"x","erf");return m.hu("int32"===a.dtype||"float32"===a.dtype,()=>"Input dtype must be `int32` or `float32`."),"int32"===a.dtype&&(a=(0,p.p)(a,"float32")),e.BV.runKernel(D.Omj,{x:a})}})},2592:(Q,v,t)=>{"use strict";t.d(v,{d:()=>m});var e=t(8788);const m=(0,t(5948).op)({euclideanNorm_:function f(p,h=null,d=!1){return(0,e.K)(p,"euclidean",h,d)}})},835:(Q,v,t)=>{"use strict";t.d(v,{Q:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({exp_:function p(d){const n={x:(0,f._1)(d,"x","exp")};return e.BV.runKernel(D.NEP,n)}})},8457:(Q,v,t)=>{"use strict";t.d(v,{d:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({expandDims_:function h(o,n=0){const a=(0,f._1)(o,"x","expandDims","string_or_numeric");return m.hu(n<=a.rank,()=>"Axis must be <= rank of the tensor"),e.BV.runKernel(D.YFo,{input:a},{dim:n})}})},5914:(Q,v,t)=>{"use strict";t.d(v,{t:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({expm1_:function p(d){const n={x:(0,f._1)(d,"x","expm1")};return e.BV.runKernel(D.Y0y,n)}})},7237:(Q,v,t)=>{"use strict";t.d(v,{h:()=>m});var e=t(2882),D=t(6338),f=t(62);function m(p,h,d){return(0,f.Mu)(p),d=d||(0,f.D2)(h),e.BV.runKernel(D.deh,{},{shape:p,value:h,dtype:d})}},3849:(Q,v,t)=>{"use strict";t.d(v,{G:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({floor_:function p(d){const n={x:(0,f._1)(d,"x","floor","float32")};return e.BV.runKernel(D.OR,n)}})},4404:(Q,v,t)=>{"use strict";t.d(v,{q:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({floorDiv_:function h(o,n){let a=(0,m._1)(o,"a","floorDiv"),c=(0,m._1)(n,"b","floorDiv");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.jeX,{a,b:c})}})},4708:(Q,v,t)=>{"use strict";t.d(v,{Fr:()=>i,QH:()=>C,pf:()=>g,uy:()=>I});var e=t(3469),D=t(6818),f=t(8476),m=t(1300),p=t(4845),h=t(2047),d=t(1095),o=t(3626),n=t(4655),a=t(4429),c=t(7782);function i(S,K,z){if(null==z||"linear"===z)return S;if("relu"===z)return(0,m.d)(S,(0,a.N)(K));throw new Error(`Cannot compute gradient for fused activation ${z}.`)}function g(S,K){let z=K;const H=e.getReductionAxes(S.shape,K.shape);return H.length>0&&(z=(0,c.S)(z,H)),(0,o.X)(z,S.shape)}function C(S,K,z,H){if("linear"===K)return S;if("relu"===K)return(0,h.U)(S);if("elu"===K)return(0,D.p)(S);if("relu6"===K)return(0,d.b)(S);if("prelu"===K)return(0,p.A)(S,z);if("leakyrelu"===K)return(0,f.h)(S,H);if("sigmoid"===K)return(0,n.X)(S);throw new Error(`Unknown fused activation ${K}.`)}const I=(S,K)=>!(S>0)||"linear"===K},8181:(Q,v,t)=>{"use strict";t.d(v,{I:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({gather_:function p(d,o,n=0,a=0){const c=(0,f._1)(d,"x","gather"),i=(0,f._1)(o,"indices","gather","int32");return e.BV.runKernel(D.qi_,{x:c,indices:i},{axis:n,batchDims:a})}})},7844:(Q,v,t)=>{"use strict";t.d(v,{p:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({greater_:function d(n,a){let c=(0,m._1)(n,"a","greater","string_or_numeric"),i=(0,m._1)(a,"b","greater","string_or_numeric");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D.iZT,{a:c,b:i})}})},4239:(Q,v,t)=>{"use strict";t.d(v,{b:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({greaterEqual_:function d(n,a){let c=(0,m._1)(n,"a","greaterEqual","string_or_numeric"),i=(0,m._1)(a,"b","greaterEqual","string_or_numeric");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D.Acj,{a:c,b:i})}})},6308:(Q,v,t)=>{"use strict";t.d(v,{a:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({imag_:function p(d){const n={input:(0,f._1)(d,"input","imag")};return e.BV.runKernel(D.J_u,n)}})},4849:(Q,v,t)=>{"use strict";t.d(v,{I:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(5948),h=t(3626);const o=(0,p.op)({resizeBilinear_:function d(n,a,c=!1,i=!1){const g=(0,f._1)(n,"images","resizeBilinear");m.hu(3===g.rank||4===g.rank,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${g.rank}.`),m.hu(2===a.length,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${a}.`),m.hu(!1===i||!1===c,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let C=g,I=!1;3===g.rank&&(I=!0,C=(0,h.X)(g,[1,g.shape[0],g.shape[1],g.shape[2]]));const[]=a,z=e.BV.runKernel(D._Yw,{images:C},{alignCorners:c,halfPixelCenters:i,size:a});return I?(0,h.X)(z,[z.shape[1],z.shape[2],z.shape[3]]):z}})},2653:(Q,v,t)=>{"use strict";t.d(v,{j:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(5948),h=t(3626);const o=(0,p.op)({resizeNearestNeighbor_:function d(n,a,c=!1,i=!1){const g=(0,f._1)(n,"images","resizeNearestNeighbor");m.hu(3===g.rank||4===g.rank,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${g.rank}.`),m.hu(2===a.length,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${a}.`),m.hu("float32"===g.dtype||"int32"===g.dtype,()=>"`images` must have `int32` or `float32` as dtype"),m.hu(!1===i||!1===c,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let C=g,I=!1;3===g.rank&&(I=!0,C=(0,h.X)(g,[1,g.shape[0],g.shape[1],g.shape[2]]));const[]=a,z=e.BV.runKernel(D.dpD,{images:C},{alignCorners:c,halfPixelCenters:i,size:a});return I?(0,h.X)(z,[z.shape[1],z.shape[2],z.shape[3]]):z}})},870:(Q,v,t)=>{"use strict";t.d(v,{x:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({isFinite_:function p(d){const n={x:(0,f._1)(d,"x","isFinite")};return e.BV.runKernel(D.avt,n)}})},8620:(Q,v,t)=>{"use strict";t.d(v,{U:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({isInf_:function p(d){const n={x:(0,f._1)(d,"x","isInf")};return e.BV.runKernel(D.iWB,n)}})},1491:(Q,v,t)=>{"use strict";t.d(v,{i:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({isNaN_:function p(d){const n={x:(0,f._1)(d,"x","isNaN")};return e.BV.runKernel(D.r7n,n)}})},8476:(Q,v,t)=>{"use strict";t.d(v,{h:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({leakyRelu_:function p(d,o=.2){const a={x:(0,f._1)(d,"x","leakyRelu")};return e.BV.runKernel(D.J$2,a,{alpha:o})}})},9027:(Q,v,t)=>{"use strict";t.d(v,{d:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({less_:function d(n,a){let c=(0,m._1)(n,"a","less","string_or_numeric"),i=(0,m._1)(a,"b","less","string_or_numeric");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D.vtC,{a:c,b:i})}})},521:(Q,v,t)=>{"use strict";t.d(v,{z:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({lessEqual_:function d(n,a){let c=(0,m._1)(n,"a","lessEqual","string_or_numeric"),i=(0,m._1)(a,"b","lessEqual","string_or_numeric");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D.CAk,{a:c,b:i})}})},5455:(Q,v,t)=>{"use strict";t.d(v,{G:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(5948),h=t(3626);const o=(0,p.op)({localResponseNormalization_:function d(n,a=5,c=1,i=1,g=.5){const C=(0,f._1)(n,"x","localResponseNormalization");m.hu(4===C.rank||3===C.rank,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${C.rank}.`),m.hu(m.GN(a),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${a}.`);let I=C,S=!1;3===C.rank&&(S=!0,I=(0,h.X)(C,[1,C.shape[0],C.shape[1],C.shape[2]]));const H=e.BV.runKernel(D.eZ0,{x:I},{depthRadius:a,bias:c,alpha:i,beta:g});return S?(0,h.X)(H,[H.shape[1],H.shape[2],H.shape[3]]):H}})},8873:(Q,v,t)=>{"use strict";t.d(v,{c:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({log_:function p(d){const n={x:(0,f._1)(d,"x","log","float32")};return e.BV.runKernel(D.ZbH,n)}})},6357:(Q,v,t)=>{"use strict";t.d(v,{K:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({log1p_:function p(d){const n={x:(0,f._1)(d,"x","log1p")};return e.BV.runKernel(D.kU,n)}})},6071:(Q,v,t)=>{"use strict";t.d(v,{e:()=>n});var e=t(6921),D=t(4810),f=t(1300),m=t(181),p=t(5948),h=t(4655),d=t(7246);const n=(0,p.op)({logSigmoid_:function o(a){const c=(0,D._1)(a,"x","logSigmoid");return(0,e.cb)(g=>({value:(0,m.W)((0,d.W)((0,m.W)(g))),gradFunc:S=>(0,f.d)(S,(0,h.X)((0,m.W)(g)))}))(c)}})},2803:(Q,v,t)=>{"use strict";t.d(v,{C:()=>i});var e=t(6921),D=t(4810),f=t(4879),m=t(835),p=t(8873),h=t(8890),d=t(1300),o=t(5948),n=t(3217),a=t(7782);const i=(0,o.op)({logSoftmax_:function c(g,C=-1){const I=(0,D._1)(g,"logits","logSoftmax");if(-1===C&&(C=I.rank-1),C!==I.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${I.rank} and axis was ${C}`);return(0,e.cb)((K,z)=>{const ct=(0,h.F)(K,C,!0),N=(0,n.l)(K,ct),W=(0,n.l)((0,f.p)(N,"float32"),(0,p.c)((0,a.S)((0,m.Q)(N),C,!0)));return z([W]),{value:W,gradFunc:(T,_)=>{const[r]=_,x=(0,m.Q)(r);return(0,n.l)(T,(0,d.d)((0,a.S)(T,C,!0),x))}}})(I)}})},4494:(Q,v,t)=>{"use strict";t.d(v,{l:()=>g});var e=t(4810),D=t(62),f=t(319),m=t(2745),p=t(835),h=t(8873),d=t(8890),o=t(5948),n=t(3626),a=t(3217),c=t(7782);const g=(0,o.op)({logSumExp_:function i(C,I=null,S=!1){const K=(0,e._1)(C,"x","logSumExp"),z=(0,D.EC)(I,K.shape),H=(0,d.F)(K,z,!0),ct=(0,a.l)(K,H),N=(0,p.Q)(ct),W=(0,c.S)(N,z),k=(0,h.c)(W),T=(0,f.I)((0,n.X)(H,k.shape),k);if(S){const _=(0,m.rv)(T.shape,z);return(0,n.X)(T,_)}return T}})},7369:(Q,v,t)=>{"use strict";t.d(v,{H:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(3469);const d=(0,t(5948).op)({logicalAnd_:function h(o,n){const a=(0,f._1)(o,"a","logicalAnd","bool"),c=(0,f._1)(n,"b","logicalAnd","bool");return(0,m.assertAndGetBroadcastShape)(a.shape,c.shape),e.BV.runKernel(D.PYm,{a,b:c})}})},5280:(Q,v,t)=>{"use strict";t.d(v,{h:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({logicalNot_:function p(d){const n={x:(0,f._1)(d,"x","logicalNot","bool")};return e.BV.runKernel(D.VfG,n)}})},4712:(Q,v,t)=>{"use strict";t.d(v,{K:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(3469);const d=(0,t(5948).op)({logicalOr_:function h(o,n){const a=(0,f._1)(o,"a","logicalOr","bool"),c=(0,f._1)(n,"b","logicalOr","bool");return(0,m.assertAndGetBroadcastShape)(a.shape,c.shape),e.BV.runKernel(D.MZg,{a,b:c})}})},694:(Q,v,t)=>{"use strict";t.d(v,{e:()=>o});var e=t(4810),D=t(3469),f=t(7369),m=t(5280),p=t(4712);const o=(0,t(5948).op)({logicalXor_:function d(n,a){const c=(0,e._1)(n,"a","logicalXor","bool"),i=(0,e._1)(a,"b","logicalXor","bool");return(0,D.assertAndGetBroadcastShape)(c.shape,i.shape),(0,f.H)((0,p.K)(n,a),(0,m.h)((0,f.H)(n,a)))}})},1976:(Q,v,t)=>{"use strict";t.d(v,{I:()=>e});var e=(()=>((e=e||{})[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",e))()},4291:(Q,v,t)=>{"use strict";t.d(v,{O:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({matMul_:function h(o,n,a=!1,c=!1){let i=(0,m._1)(o,"a","matMul"),g=(0,m._1)(n,"b","matMul");return[i,g]=(0,f.makeTypesMatch)(i,g),e.BV.runKernel(D.XLW,{a:i,b:g},{transposeA:a,transposeB:c})}})},8890:(Q,v,t)=>{"use strict";t.d(v,{F:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({max_:function p(d,o=null,n=!1){const c={x:(0,f._1)(d,"x","max")};return e.BV.runKernel(D.YoZ,c,{reductionIndices:o,keepDims:n})}})},7542:(Q,v,t)=>{"use strict";t.d(v,{_:()=>n});var e=t(2882),D=t(6338),f=t(4810),m=t(62),p=t(7202),h=t(5948),d=t(3626);const n=(0,h.op)({maxPool_:function o(a,c,i,g,C){const I=(0,f._1)(a,"x","maxPool");let K=I,z=!1;3===I.rank&&(z=!0,K=(0,d.X)(I,[1,I.shape[0],I.shape[1],I.shape[2]])),m.hu(4===K.rank,()=>`Error in maxPool: input must be rank 4 but got rank ${K.rank}.`),m.hu(p.jT(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`),p.m("maxPool",g,C);const N=e.BV.runKernel(D.mTV,{x:K},{filterSize:c,strides:i,pad:g,dimRoundingMode:C});return z?(0,d.X)(N,[N.shape[1],N.shape[2],N.shape[3]]):N}})},8060:(Q,v,t)=>{"use strict";t.d(v,{g:()=>n});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469),h=t(4879);const n=(0,t(5948).op)({maximum_:function o(a,c){let i=(0,m._1)(a,"a","maximum"),g=(0,m._1)(c,"b","maximum");return[i,g]=(0,f.makeTypesMatch)(i,g),"bool"===i.dtype&&(i=(0,h.p)(i,"int32"),g=(0,h.p)(g,"int32")),(0,p.assertAndGetBroadcastShape)(i.shape,g.shape),e.BV.runKernel(D.BMI,{a:i,b:g})}})},317:(Q,v,t)=>{"use strict";t.d(v,{J:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({mean_:function p(d,o=null,n=!1){const c={x:(0,f._1)(d,"x","mean")};return e.BV.runKernel(D.q2K,c,{axis:o,keepDims:n})}})},2451:(Q,v,t)=>{"use strict";t.d(v,{V:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({min_:function p(d,o=null,n=!1){const c={x:(0,f._1)(d,"x","min")};return e.BV.runKernel(D.c17,c,{axis:o,keepDims:n})}})},1563:(Q,v,t)=>{"use strict";t.d(v,{L:()=>n});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469),h=t(4879);const n=(0,t(5948).op)({minimum_:function o(a,c){let i=(0,m._1)(a,"a","minimum"),g=(0,m._1)(c,"b","minimum");return[i,g]=(0,f.makeTypesMatch)(i,g),"bool"===i.dtype&&(i=(0,h.p)(i,"int32"),g=(0,h.p)(g,"int32")),(0,p.assertAndGetBroadcastShape)(i.shape,g.shape),e.BV.runKernel(D.q8u,{a:i,b:g})}})},4326:(Q,v,t)=>{"use strict";t.d(v,{V:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({mirrorPad_:function h(o,n,a){m.hu("reflect"===a||"symmetric"===a,()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${a}.`);const c=(0,f._1)(o,"x","mirrorPad");if(0===c.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");m.hu(n.length===c.rank,()=>`Padding doesn't match input. Must be ${c.rank}. Got ${n.length}.`);const i="reflect"===a?1:0;for(let I=0;I<c.rank;I++)m.hu(2===n[I].length,()=>"Invalid number of paddings. Must be length of 2 each."),m.hu(n[I][0]>=0&&n[I][0]<=c.shape[I]-i&&n[I][1]>=0&&n[I][1]<=c.shape[I]-i,()=>`Padding in dimension ${I} cannot be greater than or equal to ${c.shape[I]-i} or less than 0 for input of shape ${c.shape}`);return e.BV.runKernel(D.jQs,{x:c},{paddings:n,mode:a})}})},3832:(Q,v,t)=>{"use strict";t.d(v,{w:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({mod_:function h(o,n){let a=(0,m._1)(o,"a","mod"),c=(0,m._1)(n,"b","mod");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.Vbg,{a,b:c})}})},1300:(Q,v,t)=>{"use strict";t.d(v,{d:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({mul_:function h(o,n){let a=(0,m._1)(o,"a","mul"),c=(0,m._1)(n,"b","mul");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.wYn,{a,b:c})}})},181:(Q,v,t)=>{"use strict";t.d(v,{W:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({neg_:function p(d){const n={x:(0,f._1)(d,"x","neg")};return e.BV.runKernel(D.kuV,n)}})},8788:(Q,v,t)=>{"use strict";t.d(v,{K:()=>S});var e=t(4810),D=t(62),f=t(2992),m=t(2745),p=t(8890),h=t(2451),d=t(5948),o=t(2293),n=t(3626),a=t(8153),c=t(6900),i=t(4463),g=t(7782);function I(K,z,H=null){if(0===K.rank)return(0,f.W)(K);if(1!==K.rank&&null===H)return I((0,n.X)(K,[-1]),z,H);if(1===K.rank||"number"==typeof H||Array.isArray(H)&&1===H.length){if(1===z)return(0,g.S)((0,f.W)(K),H);if(z===1/0)return(0,p.F)((0,f.W)(K),H);if(z===-1/0)return(0,h.V)((0,f.W)(K),H);if("euclidean"===z||2===z)return(0,c._)((0,g.S)((0,o.s)((0,f.W)(K),(0,a.i)(2,"int32")),H));throw new Error(`Error in norm: invalid ord value: ${z}`)}if(Array.isArray(H)&&2===H.length){if(1===z)return(0,p.F)((0,g.S)((0,f.W)(K),H[0]),H[1]-1);if(z===1/0)return(0,p.F)((0,g.S)((0,f.W)(K),H[1]),H[0]);if(z===-1/0)return(0,h.V)((0,g.S)((0,f.W)(K),H[1]),H[0]);if("fro"===z||"euclidean"===z)return(0,c._)((0,g.S)((0,i.h)(K),H));throw new Error(`Error in norm: invalid ord value: ${z}`)}throw new Error(`Error in norm: invalid axis: ${H}`)}const S=(0,d.op)({norm_:function C(K,z="euclidean",H=null,ct=!1){const N=I(K=(0,e._1)(K,"x","norm"),z,H);let W=N.shape;if(ct){const k=(0,D.EC)(H,K.shape);W=m.rv(N.shape,k)}return(0,n.X)(N,W)}})},2684:(Q,v,t)=>{"use strict";t.d(v,{Q:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({notEqual_:function d(n,a){let c=(0,m._1)(n,"a","notEqual","string_or_numeric"),i=(0,m._1)(a,"b","notEqual","string_or_numeric");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D.yQU,{a:c,b:i})}})},8598:(Q,v,t)=>{"use strict";t.d(v,{l:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({oneHot_:function p(d,o,n=1,a=0,c="int32"){if(o<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${o}`);const g={indices:(0,f._1)(d,"indices","oneHot","int32")};return e.BV.runKernel(D.we_,g,{dtype:c,depth:o,onValue:n,offValue:a})}})},6217:(Q,v,t)=>{"use strict";t.d(v,{i:()=>p});var e=t(2882),D=t(62),f=t(7401),m=t(7799);function p(h,d="float32"){if((0,D.Mu)(h),"complex64"===d){const n=p(h,"float32"),a=(0,m.l)(h,"float32");return(0,f.P)(n,a)}const o=(0,D.p8)((0,D.NA)(h),d);return e.BV.makeTensor(o,h,d)}},3583:(Q,v,t)=>{"use strict";t.d(v,{J:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({onesLike_:function p(d){const n={x:(0,f._1)(d,"x","onesLike")};return e.BV.runKernel(D.qWM,n)}})},5948:(Q,v,t)=>{"use strict";t.d(v,{op:()=>m,z:()=>f});var e=t(2882),D=t(62);const f="__op";function m(p){const h=Object.keys(p);if(1!==h.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${h.length} keys.`);let d=h[0];const o=p[d];d.endsWith("_")&&(d=d.substring(0,d.length-1)),d+=f;const n=(...a)=>{e.BV.startScope(d);try{const c=o(...a);return(0,D.tI)(c)&&console.error("Cannot return a Promise inside of tidy."),e.BV.endScope(c),c}catch(c){throw e.BV.endScope(null),c}};return Object.defineProperty(n,"name",{value:d,configurable:!0}),n}},9587:(Q,v,t)=>{"use strict";t.d(v,{zvA:()=>a.z,WnP:()=>D.W,Khb:()=>f.K,__u:()=>m._,IHx:()=>p.I,QBD:()=>i,$6P:()=>g.$,YjB:()=>C.Y,NqF:()=>I.N,vHJ:()=>S.v,ZRM:()=>K.Z,VfV:()=>z.V,z4N:()=>H.z,fvJ:()=>ct.f,C80:()=>N.C,wS1:()=>W.w,uR5:()=>y,zEQ:()=>tt,tgs:()=>ft.t,Dxk:()=>pt,JY5:()=>Et,p3b:()=>At,E4h:()=>ot.E,yE8:()=>Rt,ycw:()=>en,anm:()=>Mo,XsQ:()=>G,UFq:()=>st.U,f3b:()=>it.f,pju:()=>k.p,mDi:()=>_t.m,iUl:()=>Bt.i,d9v:()=>wt.d,PYB:()=>Gt.P,zoF:()=>x.z,gME:()=>rn,Izb:()=>Se,MNy:()=>cs,ZaL:()=>fn,PAt:()=>xn.P,Tek:()=>ue.T,bc:()=>ds.b,pdZ:()=>ps,$QV:()=>Le,mCk:()=>We.m,f9Y:()=>Ue.f,mew:()=>It,$Gn:()=>ms.$,zbp:()=>Nn.z,ppE:()=>gs,nTT:()=>_s.n,B10:()=>$n.B,Ka3:()=>qn,WmZ:()=>be.W,hiC:()=>Yt.h,NTj:()=>Ds.N,AKD:()=>ce.A,rvX:()=>Mt,WYO:()=>he,pyx:()=>vs.p,GRh:()=>Tt,EDe:()=>Ps,DgJ:()=>fe.D,qNN:()=>Os.q,d2q:()=>Ts.d,Qqt:()=>te.Q,dt4:()=>un.d,t$B:()=>ur.t,iyy:()=>Ne,kp_:()=>gr.k,hlL:()=>pe.h,GWj:()=>wn.G,qPi:()=>Is.q,imm:()=>e,Iqj:()=>we.I,dbB:()=>mt,pjt:()=>In.p,brS:()=>Fe.b,Sxn:()=>_r.S,asL:()=>Ot.a,BHj:()=>ii,V3u:()=>mn,wx0:()=>Dr.w,xVT:()=>bt.x,UWc:()=>pn.U,i2d:()=>xt.i,hi7:()=>Fn.h,d9m:()=>_n.d,zN1:()=>cn.z,$r2:()=>li,SX3:()=>Sn,G9k:()=>Ln.G,cM7:()=>ee.c,Krr:()=>Dn.K,e_t:()=>Ve.e,CmS:()=>yn.C,l_t:()=>se.l,HvI:()=>ke.H,hJK:()=>Ee.h,K5V:()=>Ge.K,egP:()=>Vn.e,MB5:()=>ui,eab:()=>ge,OI3:()=>w.O,Fp7:()=>re.F,_sB:()=>_e._,YQQ:()=>As,Ip$:()=>Rs,gWQ:()=>Cs.g,J69:()=>oe.J,ry_:()=>xs,VV$:()=>$s.V,LTh:()=>ae.L,VdP:()=>Ss.V,wQq:()=>on.w,Gi7:()=>ve,p_:()=>E,dC7:()=>V.d,rq4:()=>Pe,SJ_:()=>Ws,W76:()=>Gn.W,KOy:()=>u.K,Quu:()=>Oe.Q,lfX:()=>Us.l,iUs:()=>Wn.i,JpU:()=>Te.J,op:()=>a.op,N2O:()=>Ie,vku:()=>Xn.v,pNR:()=>Ze,koy:()=>bs,t1L:()=>Ns,lGY:()=>jn,d_R:()=>Fs.d,sQ3:()=>Ae.s,AL3:()=>Ye.A,S0v:()=>Vs.S,WVs:()=>ks.W,$gW:()=>ie,VT$:()=>Mn,N89:()=>Kn,TN_:()=>Hs,wzB:()=>Ar,nGf:()=>Zs,ruB:()=>Qs,LGj:()=>Js,pe5:()=>xr,w6H:()=>Zn,kwC:()=>$r.k,M25:()=>Sr.M,UYe:()=>ts.U,btT:()=>Lr.b,XLQ:()=>_.X,GYS:()=>Re.G,SDf:()=>Wr,diP:()=>ns,sx7:()=>Ur,mG2:()=>br,QEs:()=>es.Q,NMM:()=>Er.N,bp0:()=>zn.b,iD$:()=>Jt.i,snQ:()=>b,zcT:()=>me,U8D:()=>Nr.U,U_I:()=>vn.U,ODp:()=>wr,XD2:()=>et.X,Xxe:()=>Fr.X,tdS:()=>ai,O$l:()=>Vr.O,R_K:()=>nr.R,tPi:()=>U.t,jZU:()=>Gr,SmN:()=>Hr,CnO:()=>jr,p0P:()=>mr,XAC:()=>Qr.X,Wvh:()=>Yr.W,fBT:()=>Jr.f,rVs:()=>ci,ers:()=>at,uN7:()=>oi,Vl2:()=>er.V,_b3:()=>qr._,h62:()=>Me.h,$i:()=>Mr.$,L9e:()=>sr.L,knu:()=>Ce.k,Nbs:()=>to.N,NXj:()=>no.N,Z_8:()=>hi,luU:()=>Ut.l,Smz:()=>sn.S,ORZ:()=>rr.O,AEp:()=>F.A,XeE:()=>or.X,RRF:()=>En,odF:()=>xe,wOQ:()=>eo.w,yXz:()=>so,Bfx:()=>ro,xZs:()=>oo,Pg0:()=>io,Gg6:()=>ne.G,hg7:()=>lo.h,p4s:()=>ss.p,Xu6:()=>co,Two:()=>ho.T,pUJ:()=>fo.p,HHK:()=>ar.H,GaM:()=>po,VD$:()=>Eo,arb:()=>Qn.a,itS:()=>Pr,lls:()=>Or.l,P84:()=>_o.P});var e={};t.r(e),t.d(e,{conv2d:()=>xo,depthwiseConv2d:()=>Wo,matMul:()=>Ko});var D=t(2992),f=t(2485),m=t(6725),p=t(319),h=t(2882),d=t(6338),o=t(4810),n=t(62),a=t(5948);const i=(0,a.op)({addN_:function c(B){n.hu(Array.isArray(B),()=>"The argument passed to tf.addN() must be a list of tensors"),n.hu(B.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${B.length}`);const O=B.map((R,$)=>(0,o._1)(R,`tensors${$}`,"addN")),M=O[0];return O.forEach(R=>{if(R.dtype!==M.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),O.forEach(R=>{if(!n.cO(R.shape,M.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}),h.BV.runKernel(d.Xze,O)}});var g=t(4187),C=t(2247),I=t(1257),S=t(1019),K=t(7194),z=t(231),H=t(1282),ct=t(9851),N=t(9776),W=t(282),k=t(4879),T=t(7202),_=t(3626);const y=(0,a.op)({avgPool3d_:function r(B,O,M,P,R,$="NDHWC"){const L=(0,o._1)(B,"x","avgPool3d","float32");let X=L,nt=!1;4===L.rank&&(nt=!0,X=(0,_.X)(L,[1,L.shape[0],L.shape[1],L.shape[2],L.shape[3]])),n.hu(5===X.rank,()=>`Error in avgPool3d: x must be rank 5 but got rank ${X.rank}.`),n.hu("NDHWC"===$,()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${$}`),n.hu("number"==typeof M&&M>0||Array.isArray(M)&&M[0]>0&&M[1]>0&&M[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${M}'`),(0,T.m)("avgPool3d",P,R);let dt=h.BV.runKernel(d._k9,{x:X},{filterSize:O,strides:M,pad:P,dimRoundingMode:R,dataFormat:$});return dt=(0,k.p)(dt,X.dtype),nt?(0,_.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3],dt.shape[4]]):dt}});var x=t(4664),w=t(4291),V=t(1300),et=t(4655),U=t(8577),F=t(8892);const tt=(0,a.op)({basicLSTMCell_:function Y(B,O,M,P,R,$){const L=(0,o._1)(B,"forgetBias","basicLSTMCell"),X=(0,o._1)(O,"lstmKernel","basicLSTMCell"),nt=(0,o._1)(M,"lstmBias","basicLSTMCell"),rt=(0,o._1)(P,"data","basicLSTMCell"),ht=(0,o._1)(R,"c","basicLSTMCell"),dt=(0,o._1)($,"h","basicLSTMCell"),vt=(0,x.z)([rt,dt],1),yt=(0,w.O)(vt,X),$t=(0,p.I)(yt,nt),St=$t.shape[1]/4,Nt=[$t.shape[0],St],an=(0,U.t)($t,[0,0],Nt),hn=(0,U.t)($t,[0,St],Nt),dn=(0,U.t)($t,[0,2*St],Nt),nn=(0,U.t)($t,[0,3*St],Nt),Lt=(0,p.I)((0,V.d)((0,et.X)(an),(0,F.A)(hn)),(0,V.d)(ht,(0,et.X)((0,p.I)(L,dn))));return[Lt,(0,V.d)((0,F.A)(Lt),(0,et.X)(nn))]}});var ot=t(1601),ft=t(5707);const pt=(0,a.op)({batchNorm2d_:function gt(B,O,M,P,R,$){const L=(0,o._1)(B,"x","batchNorm"),X=(0,o._1)(O,"mean","batchNorm"),nt=(0,o._1)(M,"variance","batchNorm");let rt,ht;return null!=R&&(rt=(0,o._1)(R,"scale","batchNorm")),null!=P&&(ht=(0,o._1)(P,"offset","batchNorm")),n.hu(2===L.rank,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${L.rank}.`),n.hu(2===X.rank||1===X.rank,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${X.rank}.`),n.hu(2===nt.rank||1===nt.rank,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${nt.rank}.`),null!=rt&&n.hu(2===rt.rank||1===rt.rank,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${rt.rank}.`),null!=ht&&n.hu(2===ht.rank||1===ht.rank,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${ht.rank}.`),(0,ft.t)(L,X,nt,ht,rt,$)}}),Et=(0,a.op)({batchNorm3d_:function Pt(B,O,M,P,R,$){const L=(0,o._1)(B,"x","batchNorm"),X=(0,o._1)(O,"mean","batchNorm"),nt=(0,o._1)(M,"variance","batchNorm");let rt,ht;return null!=R&&(rt=(0,o._1)(R,"scale","batchNorm")),null!=P&&(ht=(0,o._1)(P,"offset","batchNorm")),n.hu(3===L.rank,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${L.rank}.`),n.hu(3===X.rank||1===X.rank,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${X.rank}.`),n.hu(3===nt.rank||1===nt.rank,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${nt.rank}.`),null!=rt&&n.hu(3===rt.rank||1===rt.rank,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${rt.rank}.`),null!=ht&&n.hu(3===ht.rank||1===ht.rank,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${ht.rank}.`),(0,ft.t)(L,X,nt,ht,rt,$)}}),At=(0,a.op)({batchNorm4d_:function Ct(B,O,M,P,R,$){const L=(0,o._1)(B,"x","batchNorm"),X=(0,o._1)(O,"mean","batchNorm"),nt=(0,o._1)(M,"variance","batchNorm");let rt,ht;return null!=R&&(rt=(0,o._1)(R,"scale","batchNorm")),null!=P&&(ht=(0,o._1)(P,"offset","batchNorm")),n.hu(4===L.rank,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${L.rank}.`),n.hu(4===X.rank||1===X.rank,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${X.rank}.`),n.hu(4===nt.rank||1===nt.rank,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${nt.rank}.`),null!=rt&&n.hu(4===rt.rank||1===rt.rank,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${rt.rank}.`),null!=ht&&n.hu(4===ht.rank||1===ht.rank,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${ht.rank}.`),(0,ft.t)(L,X,nt,ht,rt,$)}}),Rt=(0,a.op)({bincount_:function Ft(B,O,M){const P=(0,o._1)(B,"x","bincount"),R=(0,o._1)(O,"weights","bincount");return n.hu("int32"===P.dtype,()=>`Error in bincount: input dtype must be int32, but got ${P.dtype}`),n.hu(M>=0,()=>`size must be non-negative, but got ${M}.`),n.hu(R.size===P.size||0===R.size,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${P.shape}, weights shape: ${R.shape}.`),h.BV.runKernel(d.zvY,{x:P,weights:R},{size:M})}}),en=(0,a.op)({bitwiseAnd_:function Xt(B,O){const M=(0,o._1)(B,"x","bitwiseAnd"),P=(0,o._1)(O,"y","bitwiseAnd");if(!(0,n.cO)(M.shape,P.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${M.shape}, y: ${P.shape}`);if("int32"!==M.dtype||"int32"!==P.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${M.dtype} and type of y: ${P.dtype}`);return h.BV.runKernel(d.hCO,{a:M,b:P})}}),G=(0,a.op)({broadcastArgs_:function ln(B,O){const M=(0,o._1)(B,"s0","broadcastArgs","int32"),P=(0,o._1)(O,"s1","broadcastArgs","int32");if(1!==M.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${M.rank}`);if(1!==P.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${P.rank}`);return h.BV.runKernel(d.eEB,{s0:M,s1:P})}});var st=t(6172),it=t(4062),_t=t(9249),Bt=t(1935),wt=t(7871),Gt=t(7401);const rn=(0,a.op)({concat1d_:function Vt(B){return(0,x.z)(B,0)}}),Se=(0,a.op)({concat2d_:function Tn(B,O){return(0,x.z)(B,O)}}),cs=(0,a.op)({concat3d_:function us(B,O){return(0,x.z)(B,O)}}),fn=(0,a.op)({concat4d_:function hs(B,O){return(0,x.z)(B,O)}});var xn=t(7182),ue=t(6509),ds=t(9053);const ps=(0,a.op)({conv3d_:function fs(B,O,M,P,R="NDHWC",$=[1,1,1]){const L=(0,o._1)(B,"x","conv3d"),X=(0,o._1)(O,"filter","conv3d");let nt=L,rt=!1;4===L.rank&&(rt=!0,nt=(0,_.X)(L,[1,L.shape[0],L.shape[1],L.shape[2],L.shape[3]])),n.hu(5===nt.rank,()=>`Error in conv3d: input must be rank 5, but got rank ${nt.rank}.`),n.hu(5===X.rank,()=>`Error in conv3d: filter must be rank 5, but got rank ${X.rank}.`),n.hu(nt.shape[4]===X.shape[3],()=>`Error in conv3d: depth of input (${nt.shape[4]}) must match input depth for filter ${X.shape[3]}.`),n.hu((0,T.jT)(M,$),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${M} and dilations '${$}'`),n.hu("NDHWC"===R,()=>`Error in conv3d: got dataFormat of ${R} but only NDHWC is currently supported.`),n.hu((0,T.U3)($),()=>"Error in conv3D: Dilated rates should be larger than 0."),n.hu((0,T.U3)(M),()=>"Error in conv3D: Strides should be larger than 0.");const vt=h.BV.runKernel(d.x12,{x:nt,filter:X},{strides:M,pad:P,dataFormat:R,dilations:$});return rt?(0,_.X)(vt,[vt.shape[1],vt.shape[2],vt.shape[3],vt.shape[4]]):vt}});var Es=t(8921);const Le=(0,a.op)({conv3dTranspose_:function lr(B,O,M,P,R){const $=(0,o._1)(B,"x","conv3dTranspose"),L=(0,o._1)(O,"filter","conv3dTranspose");return(0,Es._)(M,$,L,P,R)}});var We=t(1588),Ue=t(3538),ms=t(233),Nn=t(5023);const gs=(0,a.op)({denseBincount_:function Ke(B,O,M,P=!1){const R=(0,o._1)(B,"x","denseBincount"),$=(0,o._1)(O,"weights","denseBincount");return n.hu("int32"===R.dtype,()=>`Error in denseBincount: input dtype must be int32, but got ${R.dtype}`),n.hu(R.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${R.rank}.`),n.hu(M>=0,()=>`size must be non-negative, but got ${M}.`),n.hu($.size===R.size||0===$.size,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${R.shape}, weights shape: ${$.shape}.`),h.BV.runKernel(d.QRR,{x:R,weights:$},{size:M,binaryOutput:P})}});var _s=t(8663),$n=t(2514);const qn=(0,a.op)({diag_:function tn(B){const M={x:(0,o._1)(B,"x","diag")};return h.BV.runKernel(d.$w,M)}});var be=t(7501),Yt=t(8366),Ds=t(8464),ce=t(4258);const he=(0,a.op)({einsum_:function Ms(B,...O){const M=O.map((R,$)=>(0,o._1)(R,`tensors${$}`,"einsum"));return h.BV.runKernel(d.$g6,M,{equation:B})}});var vs=t(6818);const Ps=(0,a.op)({ensureShape_:function de(B,O){const M=(0,o._1)(B,"x","ensureShape","string_or_numeric");if(!(0,n.DK)(M.shape,O))throw new Error(`EnsureShape: Shape of tensor ${M.shape} is not compatible with expected shape ${O}`);return B}});var fe=t(5393),Os=t(450),Ts=t(2592),te=t(835),un=t(8457),ur=t(5914),ne=t(3063);const Ne=(0,a.op)({eye_:function cr(B,O,M,P="float32"){null==O&&(O=B);const R=(0,it.f)([B,O],P),$=B<=O?B:O;for(let X=0;X<$;++X)R.set(1,X,X);const L=(0,_.X)(R.toTensor(),[B,O]);if(null==M)return L;if(1===M.length)return(0,ne.G)((0,un.d)(L,0),[M[0],1,1]);if(2===M.length)return(0,ne.G)((0,un.d)((0,un.d)(L,0),0),[M[0],M[1],1,1]);if(3===M.length)return(0,ne.G)((0,un.d)((0,un.d)((0,un.d)(L,0),0),0),[M[0],M[1],M[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${M.length}D.`)}});var pe=t(7237),wn=t(3849),Is=t(4404),we=t(8181),In=t(7844),Fe=t(4239),Ot=t(6308),bt=t(870),pn=t(8620),xt=t(1491),Fn=t(8476),_n=t(9027),cn=t(521);function Sn(B,O,M){if(M<=0)throw new Error("The number of values should be positive.");return h.BV.runKernel(d.e7N,{},{start:B,stop:O,num:M})}var Ln=t(5455),ee=t(8873),Dn=t(6357),Ve=t(6071),yn=t(2803),se=t(4494),ke=t(7369),Ee=t(5280),Ge=t(4712),Vn=t(694);const kn=2147483648,me=(0,a.op)({searchSorted_:function ys(B,O,M="left"){const P=(0,o._1)(B,"sortedSequence","searchSorted"),R=(0,o._1)(O,"values","searchSorted"),L=R.shape[R.shape.length-1],X=(0,_.X)(P,[-1,P.shape[P.shape.length-1]]),nt=(0,_.X)(R,[-1,L]);if(X.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(X.shape[0]!==nt.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if((0,n.NA)(nt.shape)>=kn)throw new Error(`values tensor size must less than ${kn}`);if(X.shape[1]>=kn)throw new Error(`trailing dim_size must less than ${kn} for int32 output type, was ${X.shape[1]}`);return h.BV.runKernel(d.nr8,{sortedSequence:X,values:nt},{side:M})}});function ge(B,O){return me(B,O,"left")}var re=t(8890),_e=t(7542);const As=(0,a.op)({maxPool3d_:function De(B,O=[1,1,1],M,P,R,$="NDHWC"){const L=(0,o._1)(B,"x","maxPool3d");let X=L,nt=!1;4===L.rank&&(nt=!0,X=(0,_.X)(L,[1,L.shape[0],L.shape[1],L.shape[2],L.shape[3]])),n.hu(5===X.rank,()=>`Error in maxPool3d: x must be rank 5 but got rank ${X.rank}.`),n.hu("NDHWC"===$,()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${$}`),(0,T.m)("maxPool3d",P,R);const dt=h.BV.runKernel(d.OAf,{x:X},{filterSize:O,strides:M,pad:P,dimRoundingMode:R,dataFormat:$});return nt?(0,_.X)(dt,[dt.shape[1],dt.shape[2],dt.shape[3],dt.shape[4]]):dt}}),Rs=(0,a.op)({maxPoolWithArgmax_:function Bs(B,O,M,P,R=!1){const L={x:(0,o._1)(B,"x","maxPoolWithArgmax")},nt=h.BV.runKernel(d.vFR,L,{filterSize:O,strides:M,pad:P,includeBatchInIndex:R});return{result:nt[0],indexes:nt[1]}}});var Cs=t(8060),oe=t(317),Wn=t(6217),Un=t(8106);function xs(B,O,{indexing:M="xy"}={}){if("xy"!==M&&"ij"!==M)throw new TypeError(`${M} is not a valid third argument to meshgrid`);if(void 0===B)return[];let P=(0,o._1)(B,"x","meshgrid",B instanceof Un.es?B.dtype:"float32");if(void 0===O)return[P];let R=(0,o._1)(O,"y","meshgrid",O instanceof Un.es?O.dtype:"float32");const $=(0,n.NA)(P.shape),L=(0,n.NA)(R.shape);return"xy"===M?(P=(0,_.X)(P,[1,-1]),R=(0,_.X)(R,[-1,1]),[(0,w.O)((0,Wn.i)([L,1],P.dtype),P),(0,w.O)(R,(0,Wn.i)([1,$],R.dtype))]):(P=(0,_.X)(P,[-1,1]),R=(0,_.X)(R,[1,-1]),[(0,w.O)(P,(0,Wn.i)([1,L],P.dtype)),(0,w.O)((0,Wn.i)([$,1],R.dtype),R)])}var $s=t(2451),ae=t(1563),Ss=t(4326),on=t(3832),ze=t(2745),Me=t(4463),Ut=t(3217);const ve=(0,a.op)({moments_:function He(B,O=null,M=!1){B=(0,o._1)(B,"x","moments");const P=(0,n.EC)(O,B.shape),R=(0,oe.J)(B,P,M);let $=R.shape;M||($=(0,ze.rv)(R.shape,P));const L=(0,Me.h)((0,Ut.l)((0,k.p)(B,"float32"),(0,_.X)(R,$)));return{mean:R,variance:(0,oe.J)(L,P,M)}}}),Pe=(0,a.op)({multiRNNCell_:function Ls(B,O,M,P){const R=(0,o._1)(O,"data","multiRNNCell"),$=(0,o.sI)(M,"c","multiRNNCell"),L=(0,o.sI)(P,"h","multiRNNCell");let X=R;const nt=[];for(let dt=0;dt<B.length;dt++){const vt=B[dt](X,$[dt],L[dt]);nt.push(vt[0]),nt.push(vt[1]),X=vt[1]}const rt=[],ht=[];for(let dt=0;dt<nt.length;dt+=2)rt.push(nt[dt]),ht.push(nt[dt+1]);return[rt,ht]}}),Ws=(0,a.op)({multinomial_:function Xe(B,O,M,P=!1){const R=(0,o._1)(B,"logits","multinomial"),$=R.size,L=R.rank;if($<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${$}.`);if(L>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${L}`);M=M||Math.random();const nt={logits:1===L?(0,_.X)(R,[1,-1]):R},ht=h.BV.runKernel(d.NZg,nt,{numSamples:O,seed:M,normalized:P});return 1===L?(0,_.X)(ht,[ht.size]):ht}});var Gn=t(181),Oe=t(2684),Us=t(8598),Te=t(3583);const Ie=(0,a.op)({outerProduct_:function je(B,O){const M=(0,o._1)(B,"v1","outerProduct"),P=(0,o._1)(O,"v2","outerProduct");n.hu(1===M.rank&&1===P.rank,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${M.rank} and ${P.rank}.`);const R=(0,_.X)(M,[-1,1]),$=(0,_.X)(P,[1,-1]);return(0,w.O)(R,$)}});var Xn=t(1824);const Ze=(0,a.op)({pad1d_:function ye(B,O,M=0){return(0,n.hu)(2===O.length,()=>"Invalid number of paddings. Must be length of 2."),(0,Xn.v)(B,[O],M)}}),bs=(0,a.op)({pad2d_:function Ks(B,O,M=0){return(0,n.hu)(2===O.length&&2===O[0].length&&2===O[1].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,Xn.v)(B,O,M)}}),Ns=(0,a.op)({pad3d_:function Qe(B,O,M=0){return(0,n.hu)(3===O.length&&2===O[0].length&&2===O[1].length&&2===O[2].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,Xn.v)(B,O,M)}}),jn=(0,a.op)({pad4d_:function ws(B,O,M=0){return(0,n.hu)(4===O.length&&2===O[0].length&&2===O[1].length&&2===O[2].length&&2===O[3].length,()=>"Invalid number of paddings. Must be length of 2 each."),(0,Xn.v)(B,O,M)}});var Fs=t(5415),Ae=t(2293),Ye=t(4845),Vs=t(5514),ks=t(9357);const ie=(0,a.op)({raggedGather_:function Gs(B,O,M,P){const R=B.map((ht,dt)=>(0,o._1)(ht,`tensors${dt}`,"raggedGather","int32")),$=(0,o._1)(O,"paramsDenseValues","raggedGather"),L=(0,o._1)(M,"indices","raggedGather","int32"),rt=h.BV.runKernel(d.dDz,{paramsNestedSplits:R,paramsDenseValues:$,indices:L},{outputRaggedRank:P});return{outputNestedSplits:rt.slice(0,rt.length-1),outputDenseValues:rt[rt.length-1]}}}),Mn=(0,a.op)({raggedRange_:function J(B,O,M){const P=(0,o._1)(B,"starts","raggedRange"),R=(0,o._1)(O,"limits","raggedRange",P.dtype),$=(0,o._1)(M,"deltas","raggedRange",P.dtype),X=h.BV.runKernel(d.CQl,{starts:P,limits:R,deltas:$});return{rtNestedSplits:X[0],rtDenseValues:X[1]}}}),Kn=(0,a.op)({raggedTensorToTensor_:function zs(B,O,M,P,R){const $=(0,o._1)(B,"shape","raggedTensorToTensor","int32"),L=(0,o._1)(O,"values","raggedTensorToTensor"),X=(0,o._1)(M,"defaultValue","raggedTensorToTensor",L.dtype),nt=P.map((dt,vt)=>(0,o._1)(dt,`tensors${vt}`,"raggedTensorToTensor","int32"));return h.BV.runKernel(d.BiW,{shape:$,values:L,defaultValue:X,rowPartitionTensors:nt},{rowPartitionTypes:R})}}),Hs=(0,a.op)({rand_:function Je(B,O,M){(0,n.Mu)(B);const P=(0,n.NA)(B);let R=null;if(null==M||"float32"===M)R=new Float32Array(P);else if("int32"===M)R=new Int32Array(P);else{if("bool"!==M)throw new Error(`Unknown data type ${M}`);R=new Uint8Array(P)}for(let $=0;$<P;$++)R[$]=O();return h.BV.makeTensor(R,B,M)}});var Xs=t(4901);class js{constructor(O,M,P,R,$){this.mean=O,this.stdDev=M,this.dtype=P,this.nextVal=NaN,this.truncated=R,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const L=$||Math.random();this.random=Xs.alea(L.toString())}nextValue(){if(!isNaN(this.nextVal)){const R=this.nextVal;return this.nextVal=NaN,R}let O,M,P=!1;for(;!P;){let R,$,L;do{R=2*this.random()-1,$=2*this.random()-1,L=R*R+$*$}while(L>=1||0===L);const X=Math.sqrt(-2*Math.log(L)/L);O=this.mean+this.stdDev*R*X,M=this.mean+this.stdDev*$*X,(!this.truncated||this.isValidTruncated(O))&&(P=!0)}return(!this.truncated||this.isValidTruncated(M))&&(this.nextVal=this.convertValue(M)),this.convertValue(O)}convertValue(O){return null==this.dtype||"float32"===this.dtype?O:Math.round(O)}isValidTruncated(O){return O<=this.upper&&O>=this.lower}}class Tr{constructor(O,M,P,R){this.alpha=O,this.beta=1/M,this.dtype=P;const $=R||Math.random();this.randu=Xs.alea($.toString()),this.randn=new js(0,1,P,!1,this.randu()),this.d=O<1?O+2/3:O-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let O,M,P,R,$,L;for(;;){do{R=this.randn.nextValue(),L=1+this.c*R}while(L<=0);if(L*=L*L,O=R*R,M=1-.331*O*O,P=.5*O+this.d*(1-L+Math.log(L)),$=this.randu(),$<M||Math.log($)<P)break}return L*=1/this.beta*this.d,this.alpha<1&&(L*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(L)}convertValue(O){return"float32"===this.dtype?O:Math.round(O)}}class Ir{constructor(O=0,M=1,P,R){if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=O,this.range=M-O,this.dtype=P,null==R&&(R=Math.random()),"number"==typeof R&&(R=R.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${O} - ${M} <= 1 and dtype is not float`);this.random=Xs.alea(R)}convertValue(O){return this.canReturnFloat()?O:Math.round(O)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const Ar=(0,a.op)({randomGamma_:function fr(B,O,M=1,P="float32",R){if((0,n.Mu)(B),null==M&&(M=1),null==P&&(P="float32"),"float32"!==P&&"int32"!==P)throw new Error(`Unsupported data type ${P}`);const $=new Tr(O,M,P,R),L=(0,it.f)(B,P);for(let X=0;X<L.values.length;X++)L.values[X]=$.nextValue();return L.toTensor()}}),Zs=(0,a.op)({randomNormal_:function Br(B,O=0,M=1,P,R){if((0,n.Mu)(B),null!=P&&"bool"===P)throw new Error(`Unsupported data type ${P}`);const $=new js(O,M,P,!1,R),L=(0,it.f)(B,P);for(let X=0;X<L.values.length;X++)L.values[X]=$.nextValue();return L.toTensor()}}),Qs=(0,a.op)({randomStandardNormal_:function Rr(B,O,M){if(null!=O&&"bool"===O)throw new Error(`Unsupported data type ${O}`);return Zs(B,0,1,O,M)}}),Js=(0,a.op)({randomUniform_:function Ys(B,O=0,M=1,P="float32",R){(0,n.Mu)(B);const $=(0,it.f)(B,P),L=new Ir(O,M,null,R);for(let X=0;X<$.values.length;X++)$.values[X]=L.nextValue();return $.toTensor()}}),xr=(0,a.op)({randomUniformInt_:function Cr(B,O,M,P){return Js(B,O,M,"int32",P)}});function Zn(B,O,M=1,P="float32"){if(0===M)throw new Error("Cannot have a step of zero");return h.BV.runKernel(d.e6w,{},{start:B,stop:O,step:M,dtype:P})}var $r=t(6656),Sr=t(9372),ts=t(2047),Lr=t(1095),Re=t(7661);const Wr=(0,a.op)({reverse1d_:function qs(B){const O=(0,o._1)(B,"x","reverse");return n.hu(1===O.rank,()=>`Error in reverse1D: x must be rank 1 but got rank ${O.rank}.`),(0,Re.G)(O,0)}}),ns=(0,a.op)({reverse2d_:function pr(B,O){const M=(0,o._1)(B,"x","reverse");return n.hu(2===M.rank,()=>`Error in reverse2D: x must be rank 2 but got rank ${M.rank}.`),(0,Re.G)(M,O)}}),Ur=(0,a.op)({reverse3d_:function j(B,O){const M=(0,o._1)(B,"x","reverse");return n.hu(3===M.rank,()=>`Error in reverse3D: x must be rank 3 but got rank ${M.rank}.`),(0,Re.G)(M,O)}}),br=(0,a.op)({reverse4d_:function Kr(B,O){const M=(0,o._1)(B,"x","reverse");return n.hu(4===M.rank,()=>`Error in reverse4D: x must be rank 4 but got rank ${M.rank}.`),(0,Re.G)(M,O)}});var Er=t(2688),zn=t(242),Jt=t(8153),Nr=t(5484),vn=t(6020),An=t(8239);function tr(){return(tr=(0,An.Z)(function*(B,O){const M=(0,o._1)(B,"x","setdiff1d"),P=(0,o._1)(O,"y","setdiff1d");n.hu(M.dtype===P.dtype,()=>`x and y should have the same dtype, but got x (${M.dtype}) and y (${P.dtype}).`),n.hu(1===M.rank,()=>`x should be 1D tensor, but got x (${M.shape}).`),n.hu(1===P.rank,()=>`y should be 1D tensor, but got y (${P.shape}).`);const R=yield M.data(),$=yield P.data(),L=new Set($);let X=0;for(let ht=0;ht<R.length;ht++)L.has(R[ht])||X++;const nt=new Un.YD([X],M.dtype),rt=new Un.YD([X],"int32");for(let ht=0,dt=0;ht<R.length;ht++)L.has(R[ht])||(nt.values[dt]=R[ht],rt.values[dt]=ht,dt++);return[nt.toTensor(),rt.toTensor()]})).apply(this,arguments)}const wr=function zt(B,O){return tr.apply(this,arguments)};var Fr=t(184),Vr=t(1969),nr=t(3981);const Gr=(0,a.op)({slice1d_:function kr(B,O,M){const P=(0,o._1)(B,"x","slice1d");return n.hu(1===P.rank,()=>`slice1d expects a rank-1 tensor, but got a rank-${P.rank} tensor`),(0,U.t)(P,[O],[M])}}),Hr=(0,a.op)({slice2d_:function zr(B,O,M){const P=(0,o._1)(B,"x","slice2d");return n.hu(2===P.rank,()=>`slice2d expects a rank-2 tensor, but got a rank-${P.rank} tensor`),(0,U.t)(P,O,M)}}),jr=(0,a.op)({slice3d_:function Xr(B,O,M){const P=(0,o._1)(B,"x","slice3d");return n.hu(3===P.rank,()=>`slice3d expects a rank-3 tensor, but got a rank-${P.rank} tensor`),(0,U.t)(P,O,M)}}),mr=(0,a.op)({slice4d_:function Zr(B,O,M){const P=(0,o._1)(B,"x","slice4d");return n.hu(4===P.rank,()=>`slice4d expects a rank-4 tensor, but got a rank-${P.rank} tensor`),(0,U.t)(P,O,M)}});var Qr=t(2187),Yr=t(7246),Jr=t(1705),gr=t(5008),_r=t(1132),Dr=t(3176),es=t(4636),er=t(633),qr=t(6900),Mr=t(3629),sr=t(6458),Ce=t(1440),to=t(4429),no=t(92),sn=t(7782),rr=t(3992),or=t(5186),le=t(299);function En(B,O){(0,n.Cq)(B);const M=(0,o.C)(B,O);if(1!==M.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return(0,le.H)(B,null,M,O)}function xe(B,O,M){if((0,n.Cq)(B),null!=O&&2!==O.length)throw new Error("tensor2d() requires shape to have two numbers");const P=(0,o.C)(B,M);if(2!==P.length&&1!==P.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===P.length&&null==O)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return(0,le.H)(B,O,P,M)}var eo=t(3221);function so(B,O,M){if((0,n.Cq)(B),null!=O&&4!==O.length)throw new Error("tensor4d() requires shape to have four numbers");const P=(0,o.C)(B,M);if(4!==P.length&&1!==P.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===P.length&&null==O)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return(0,le.H)(B,O,P,M)}function ro(B,O,M){if((0,n.Cq)(B),null!=O&&5!==O.length)throw new Error("tensor5d() requires shape to have five numbers");const P=(0,o.C)(B,M);if(5!==P.length&&1!==P.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===P.length&&null==O)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return(0,le.H)(B,O,P,M)}function oo(B,O,M){if((0,n.Cq)(B),null!=O&&6!==O.length)throw new Error("tensor6d() requires shape to have six numbers");const P=(0,o.C)(B,M);if(6!==P.length&&1!==P.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===P.length&&null==O)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return(0,le.H)(B,O=O||P,P,M)}var vr=t(7169);const io=(0,a.op)({tensorScatterUpdate_:function ao(B,O,M){const P=(0,o._1)(B,"tensor","tensorScatterupdate"),R=(0,o._1)(O,"indices","tensorScatterupdate","int32"),$=(0,o._1)(M,"updates","tensorScatterupdate");if(vr.validateInput($,R,P.shape),P.dtype!==$.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${P.dtype} and ${$.dtype}.`);return h.BV.runKernel(d.SIB,{tensor:P,indices:R,updates:$},{})}});var lo=t(3187);const co=(0,a.op)({truncatedNormal_:function uo(B,O=0,M=1,P,R){if((0,n.Mu)(B),null!=P&&"bool"===P)throw new Error("Unsupported data type $ { dtype }");const $=new js(O,M,P,!0,R),L=(0,it.f)(B,P);for(let X=0;X<L.values.length;X++)L.values[X]=$.nextValue();return L.toTensor()}});var ho=t(5403),fo=t(6442),ar=t(230);function po(B,O){return me(B,O,"right")}function Eo(B,O=!0,M,P){return h.BV.makeVariable(B,O,M,P)}var Qn=t(8793),mo=t(4644);function ir(){return(ir=(0,An.Z)(function*(B){const O=(0,o._1)(B,"condition","whereAsync","bool"),M=yield O.data(),P=(0,mo.Z)(O.shape,M);return B!==O&&O.dispose(),P})).apply(this,arguments)}const Pr=function go(B){return ir.apply(this,arguments)};var Or=t(7799),_o=t(9314);function $e(){return($e=(0,An.Z)(function*(B,O,M){const P=(0,o._1)(B,"tensor","boolMask"),R=(0,o._1)(O,"mask","boolMask","bool"),$=M??0,L=R.rank,X=P.shape;n.hu(L>0,()=>"mask cannot be scalar"),n.k5(X.slice($,$+L),R.shape,"mask's shape must match the first K dimensions of tensor's shape,");let nt=1;for(let Kt=$;Kt<$+L;Kt++)nt*=X[Kt];const rt=X.slice(0,$).concat([nt],X.slice($+L)),ht=(0,_.X)(P,rt),dt=(0,_.X)(R,[-1]),vt=yield Pr(dt),yt=(0,sr.L)(vt,[1]),$t=(0,we.I)(ht,yt,$);return B!==P&&P.dispose(),O!==R&&R.dispose(),yt.dispose(),ht.dispose(),dt.dispose(),vt.dispose(),$t})).apply(this,arguments)}const Mo=function Do(B,O,M){return $e.apply(this,arguments)};var ss=t(3111),u=t(8788),s=t(7073);const E=(0,a.op)({movingAverage_:function l(B,O,M,P,R=!0){const $=(0,o._1)(B,"v","movingAverage"),L=(0,o._1)(O,"x","movingAverage"),X=(0,o._1)(M,"decay","movingAverage");(0,s.assertTypesMatch)($,L),n.hu(n.cO($.shape,L.shape),()=>"Shape mismatch in v and x");const nt=(0,Jt.i)(1),rt=(0,Ut.l)(nt,X);let ht=(0,V.d)((0,Ut.l)(L,$),rt);if(R){n.hu(null!=P,()=>"When using zeroDebias: true, step is required.");const dt=(0,o._1)(P,"step","movingAverage");ht=(0,Yt.h)(ht,(0,Ut.l)(nt,(0,Ae.s)(X,dt)))}return(0,p.I)($,ht)}}),b=(0,a.op)({scatterND_:function A(B,O,M){(0,n.Mu)(M);const P=(0,o._1)(B,"indices","scatterND","int32"),R=(0,o._1)(O,"updates","scatterND");return vr.validateInput(R,P,M),h.BV.runKernel(d.xQA,{indices:P,updates:R},{shape:M})}}),at=(0,a.op)({sparseToDense_:function q(B,O,M,P=0){(0,n.Mu)(M);const R=(0,o._1)(B,"sparseIndices","sparseToDense","int32"),$=(0,o._1)(O,"sparseValues","sparseToDense","string_or_numeric"),L=(0,o._1)(P,"defaultValue","sparseToDense",$.dtype);return function Z(B,O,M,P){if("int32"!==B.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${B.dtype}.`);if(B.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${B.shape}.`);const R=B.rank>0?B.shape[0]:1,$=B.rank>1?B.shape[1]:1;if(M.length!==$)throw new Error(`outputShape has incorrect number of elements:, ${M.length}, should be: ${$}.`);if(0!==O.rank&&(1!==O.rank||O.size!==R))throw new Error(`sparseValues has incorrect shape ${O.shape}, should be [] or [${R}]`);if(O.dtype!==P.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(R,$,M,L),h.BV.runKernel(d.D2d,{sparseIndices:R,sparseValues:$,defaultValue:L},{outputShape:M})}}),mt=(0,a.op)({gatherND_:function lt(B,O){const M=(0,o._1)(O,"indices","gatherND","int32"),R={params:(0,o._1)(B,"x","gatherND","string_or_numeric"),indices:M};return h.BV.runKernel(d.q1x,R)}}),Mt=(0,a.op)({dropout_:function Dt(B,O,M,P){const R=(0,o._1)(B,"x","dropout");if(n.hu("float32"===R.dtype,()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${R.dtype} tensor instead.`),n.hu(O>=0&&O<1,()=>`rate must be a float in the range [0, 1), but got ${O}.`),0===O)return B instanceof Un.es?R.clone():R;const $=function ut(B,O){if(null==O)return B.shape.slice();if(n.cO(B.shape,O))return O;if(B.shape.length===O.length){const M=[];for(let P=0;P<B.shape.length;P++)M.push(null==O[P]&&null!=B.shape[P]?B.shape[P]:O[P]);return M}return O}(R,M),L=1-O,X=(0,Yt.h)((0,wn.G)((0,p.I)(Js($,0,1,"float32",P),L)),L);return(0,V.d)(R,X)}});function Tt(B){return Math.floor(Math.pow(2,Math.ceil(Math.log(B)/Math.log(2))))}function It(B,O,M){const P=1-B%2,R=new Float32Array(B);for(let $=0;$<B;++$){const L=2*Math.PI*$/(B+P-1);R[$]=O-M*Math.cos(L)}return En(R,"float32")}function kt(){return(kt=(0,An.Z)(function*(B,O,M=1){const P=(0,o._1)(B,"predictions","inTopK"),R=(0,o._1)(O,"targets","inTopK");(0,n.hu)(P.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${P.rank}`),(0,n.hu)(P.rank-1===R.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${P.rank} and targets rank ${R.rank}`),(0,n.k5)(P.shape.slice(0,P.shape.length-1),R.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const $=P.shape[P.shape.length-1];(0,n.hu)(M>0&&M<=$,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${$}), but got ${M}`);const L=yield P.data(),X=yield R.data(),[nt,rt]=[L.length/$,$],ht=(0,n.WP)("bool",nt);for(let dt=0;dt<nt;dt++){const vt=dt*rt,yt=L.subarray(vt,vt+rt),$t=[];for(let Kt=0;Kt<yt.length;Kt++)$t.push({value:yt[Kt],index:Kt});$t.sort((Kt,St)=>St.value-Kt.value),ht[dt]=0;for(let Kt=0;Kt<M;Kt++)if($t[Kt].index===X[dt]){ht[dt]=1;break}}return B!==P&&P.dispose(),O!==R&&R.dispose(),(0,or.X)(ht,R.shape,"bool")})).apply(this,arguments)}const mn=function Wt(B,O){return kt.apply(this,arguments)};var gn=t(6921),bn=t(3469),rs=t(4867),vo=t(8445),Bn=t(4708);const xo=(0,a.op)({fusedConv2d_:function Co({x:B,filter:O,strides:M,pad:P,dataFormat:R="NHWC",dilations:$=[1,1],dimRoundingMode:L,bias:X,activation:nt="linear",preluActivationWeights:rt,leakyreluAlpha:ht}){if(!1===(0,Bn.uy)(h.BV.state.gradientDepth,nt=nt||"linear")){n.hu("NHWC"===R,()=>`Error in fused conv2d: got dataFormat of ${R} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let Lt=(0,ue.T)(B,O,M,P,R,$,L);return null!=X&&(Lt=(0,p.I)(Lt,X)),(0,Bn.QH)(Lt,nt,rt,ht)}const dt=(0,o._1)(B,"x","conv2d","float32"),vt=(0,o._1)(O,"filter","conv2d","float32");let yt=dt,$t=!1;3===dt.rank&&($t=!0,yt=(0,_.X)(dt,[1,dt.shape[0],dt.shape[1],dt.shape[2]])),n.hu(4===yt.rank,()=>`Error in fused conv2d: input must be rank 4, but got rank ${yt.rank}.`),n.hu(4===vt.rank,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${vt.rank}.`),T.m("fused conv2d",P,L);const Kt="NHWC"===R?yt.shape[3]:yt.shape[1];n.hu(vt.shape[2]===Kt,()=>`Error in conv2d: depth of input (${Kt}) must match input depth for filter ${vt.shape[2]}.`),n.hu(T.jT(M,$),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${M} and dilations '${$}'`);const St=T.Ix(yt.shape,vt.shape,M,$,P,L);let Nt,an;if(null!=X&&(Nt=(0,o._1)(X,"bias","fused conv2d"),[Nt]=(0,s.makeTypesMatch)(Nt,dt),"NHWC"===R?bn.assertAndGetBroadcastShape(St.outShape,Nt.shape):(n.hu(Nt.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${Nt.shape.length}.`),n.hu(0===Nt.shape.length||Nt.shape[0]===St.outChannels||1===Nt.shape[0],()=>`Error in fused conv2d: bias shape (${Nt.shape}) is not compatible with the number of output channels (${St.outChannels})`))),null!=rt){const Lt=rt.shape;if(n.hu(Lt.length<=1||3===Lt.length,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${Lt.length}.`),1===Lt.length)n.hu(1===Lt[0]||Lt[0]===St.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${Lt}) is not compatible with the number of output channels (${St.outChannels}).`);else if(3===Lt.length)try{bn.assertAndGetBroadcastShape(Lt,St.outShape)}catch{throw Error(`Error in fused conv2d: PReLU activation weights (${Lt}) is not compatible with the output shape of the conv2d (${St.outShape}).`)}an=(0,o._1)(rt,"prelu weights","fused conv2d")}const hn=(Lt,qt)=>{n.hu("NHWC"===R,()=>`Error in gradient of fused conv2D: got dataFormat of ${R} but only NHWC is currently supported.`);const[Zt,Ht,jt,Qt]=qt,Rn=(0,Bn.Fr)(Lt,jt,nt);n.hu(T.I0($),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${$}'`);const Hn=[(0,vo._)(Ht.shape,Rn,Zt,M,P),(0,rs.p)(Ht,Rn,Zt.shape,M,P)];if(null!=Qt){const as=(0,Bn.pf)(Qt,Rn);Hn.push(as)}return Hn},dn={x:yt,filter:vt,bias:Nt,preluActivationWeights:an},nn={strides:M,pad:P,dataFormat:R,dilations:$,dimRoundingMode:L,activation:nt,leakyreluAlpha:ht};return null==X?(0,gn.cb)((qt,Zt,Ht)=>{let jt=h.BV.runKernel(d._V0,dn,nn);return Ht([Zt,qt,jt]),$t&&(jt=(0,_.X)(jt,[jt.shape[1],jt.shape[2],jt.shape[3]])),{value:jt,gradFunc:hn}})(yt,vt):(0,gn.cb)((qt,Zt,Ht,jt)=>{let Qt=h.BV.runKernel(d._V0,dn,nn);return jt([Zt,qt,Qt,Ht]),$t&&(Qt=(0,_.X)(Qt,[Qt.shape[1],Qt.shape[2],Qt.shape[3]])),{value:Qt,gradFunc:hn}})(yt,vt,Nt)}});var $o=t(527),So=t(3905);const Wo=(0,a.op)({fusedDepthwiseConv2d_:function Lo({x:B,filter:O,strides:M,pad:P,dataFormat:R="NHWC",dilations:$=[1,1],dimRoundingMode:L,bias:X,activation:nt="linear",preluActivationWeights:rt,leakyreluAlpha:ht}){if(!1===(0,Bn.uy)(h.BV.state.gradientDepth,nt)){let nn=(0,$n.B)(B,O,M,P,R,$,L);return null!=X&&(nn=(0,p.I)(nn,X)),(0,Bn.QH)(nn,nt,rt,ht)}const dt=(0,o._1)(B,"x","depthwiseConv2d","float32"),vt=(0,o._1)(O,"filter","depthwiseConv2d","float32");let yt=dt,$t=!1;3===dt.rank&&($t=!0,yt=(0,_.X)(dt,[1,dt.shape[0],dt.shape[1],dt.shape[2]])),n.hu(4===yt.rank,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${yt.rank}.`),n.hu(4===vt.rank,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${vt.rank}.`),n.hu(yt.shape[3]===vt.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${yt.shape[3]}) must match the inChannels dimension in filter ${vt.shape[2]}.`),null==$&&($=[1,1]),n.hu(T.jT(M,$),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${M} and dilations '${$}'`),T.m("fused depthwiseConv2d",P,L);const Kt=T.Ix(yt.shape,vt.shape,M,$,P,L,!0);let St,Nt;null!=X&&(St=(0,o._1)(X,"bias","fused conv2d"),[St]=(0,s.makeTypesMatch)(St,dt),bn.assertAndGetBroadcastShape(Kt.outShape,St.shape)),null!=rt&&(Nt=(0,o._1)(rt,"prelu weights","fused depthwiseConv2d"));const an=(nn,Lt)=>{n.hu(T.I0($),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${$}'`);const[qt,Zt,Ht,jt]=Lt,Qt=(0,Bn.Fr)(nn,Ht,nt),Rn=(0,So.v)(Zt.shape,Qt,qt,M,P,$,L),On=(0,$o.z)(Zt,Qt,qt.shape,M,P,$,L);return null!=jt?[Rn,On,(0,Bn.pf)(St,Qt)]:[Rn,On]},hn={x:yt,filter:vt,bias:St,preluActivationWeights:Nt},dn={strides:M,pad:P,dataFormat:R,dilations:$,dimRoundingMode:L,activation:nt,leakyreluAlpha:ht};return null==X?(0,gn.cb)((Lt,qt,Zt)=>{let Ht=h.BV.runKernel(d.luS,hn,dn);return Zt([qt,Lt,Ht]),$t&&(Ht=(0,_.X)(Ht,[Ht.shape[1],Ht.shape[2],Ht.shape[3]])),{value:Ht,gradFunc:an}})(yt,vt):(0,gn.cb)((Lt,qt,Zt,Ht)=>{let jt=h.BV.runKernel(d.luS,hn,dn);return Ht([qt,Lt,jt,Zt]),$t&&(jt=(0,_.X)(jt,[jt.shape[1],jt.shape[2],jt.shape[3]])),{value:jt,gradFunc:an}})(yt,vt,St)}}),Ko=(0,a.op)({fusedMatMul_:function Uo({a:B,b:O,transposeA:M=!1,transposeB:P=!1,bias:R,activation:$="linear",preluActivationWeights:L,leakyreluAlpha:X=.2}){if(!1===(0,Bn.uy)(h.BV.state.gradientDepth,$)){let Qt=(0,w.O)(B,O,M,P);return null!=R&&(Qt=(0,p.I)(Qt,R)),(0,Bn.QH)(Qt,$,L,X)}let nt=(0,o._1)(B,"a","fused matMul"),rt=(0,o._1)(O,"b","fused matMul");[nt,rt]=(0,s.makeTypesMatch)(nt,rt);const ht=M?nt.shape[nt.rank-2]:nt.shape[nt.rank-1],dt=P?rt.shape[rt.rank-1]:rt.shape[rt.rank-2],vt=M?nt.shape[nt.rank-1]:nt.shape[nt.rank-2],yt=P?rt.shape[rt.rank-2]:rt.shape[rt.rank-1],$t=nt.shape.slice(0,-2),Kt=rt.shape.slice(0,-2),St=n.NA($t),Nt=n.NA(Kt);n.hu(ht===dt,()=>`Error in fused matMul: inner shapes (${ht}) and (${dt}) of Tensors with shapes ${nt.shape} and ${rt.shape} and transposeA=${M} and transposeB=${P} must match.`);const hn=bn.assertAndGetBroadcastShape(nt.shape.slice(0,-2),rt.shape.slice(0,-2)).concat([vt,yt]),dn=(0,_.X)(nt,M?[St,ht,vt]:[St,vt,ht]),nn=(0,_.X)(rt,P?[Nt,yt,dt]:[Nt,dt,yt]);let Lt,qt;null!=R&&(Lt=(0,o._1)(R,"bias","fused matMul"),[Lt]=(0,s.makeTypesMatch)(Lt,nt),bn.assertAndGetBroadcastShape(hn,Lt.shape)),null!=L&&(qt=(0,o._1)(L,"prelu weights","fused matMul"));const Zt=(Qt,Rn)=>{const[On,Cn,Hn,as]=Rn,Jn=(0,Bn.Fr)((0,_.X)(Qt,Hn.shape),Hn,$);let is,ls;return M||P?!M&&P?(is=(0,w.O)(Jn,Cn,!1,!1),ls=(0,w.O)(Jn,On,!0,!1)):M&&!P?(is=(0,w.O)(Cn,Jn,!1,!0),ls=(0,w.O)(On,Jn,!1,!1)):(is=(0,w.O)(Cn,Jn,!0,!0),ls=(0,w.O)(Jn,On,!0,!0)):(is=(0,w.O)(Jn,Cn,!1,!0),ls=(0,w.O)(On,Jn,!0,!1)),null!=R?[is,ls,(0,Bn.pf)(as,Jn)]:[is,ls]},Ht={a:dn,b:nn,bias:Lt,preluActivationWeights:qt},jt={transposeA:M,transposeB:P,activation:$,leakyreluAlpha:X};return null==R?(0,gn.cb)((Rn,On,Cn)=>{const Hn=h.BV.runKernel(d.usg,Ht,jt);return Cn([Rn,On,Hn]),{value:(0,_.X)(Hn,hn),gradFunc:Zt}})(dn,nn):(0,gn.cb)((Rn,On,Cn,Hn)=>{const as=h.BV.runKernel(d.usg,Ht,jt);return Hn([Rn,On,as,Cn]),{value:(0,_.X)(as,hn),gradFunc:Zt}})(dn,nn,Lt)}}),No=(0,a.op)({hammingWindow_:function bo(B){return It(B,.54,.46)}}),Ao=(0,a.op)({hannWindow_:function wo(B){return It(B,.5,.5)}}),Bo=(0,a.op)({frame_:function Fo(B,O,M,P=!1,R=0){let $=0;const L=[];for(;$+O<=B.size;)L.push((0,U.t)(B,$,O)),$+=M;if(P)for(;$<B.size;){const X=$+O-B.size,nt=(0,x.z)([(0,U.t)(B,$,O-X),(0,pe.h)([X],R)]);L.push(nt),$+=M}return 0===L.length?xe([],[0,O]):(0,_.X)((0,x.z)(L),[L.length,O])}}),ko=(0,a.op)({stft_:function Vo(B,O,M,P,R=Ao){null==P&&(P=Tt(O));const $=Bo(B,O,M),L=(0,V.d)($,R(O));return(0,es.Q)(L,P)}}),zo=(0,a.op)({cropAndResize_:function Go(B,O,M,P,R="bilinear",$=0){const L=(0,o._1)(B,"image","cropAndResize"),X=(0,o._1)(O,"boxes","cropAndResize","float32"),nt=(0,o._1)(M,"boxInd","cropAndResize","int32"),rt=X.shape[0];return n.hu(4===L.rank,()=>`Error in cropAndResize: image must be rank 4,but got rank ${L.rank}.`),n.hu(2===X.rank&&4===X.shape[1],()=>`Error in cropAndResize: boxes must be have size [${rt},4] but had shape ${X.shape}.`),n.hu(1===nt.rank&&nt.shape[0]===rt,()=>`Error in cropAndResize: boxInd must be have size [${rt}] but had shape ${X.shape}.`),n.hu(2===P.length,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${P.length}.`),n.hu(P[0]>=1&&P[1]>=1,()=>`cropSize must be atleast [1,1], but was ${P}`),n.hu("bilinear"===R||"nearest"===R,()=>`method must be bilinear or nearest, but was ${R}`),h.BV.runKernel(d.VcC,{image:L,boxes:X,boxInd:nt},{method:R,extrapolationValue:$,cropSize:P})}}),Xo=(0,a.op)({flipLeftRight_:function Ho(B){const O=(0,o._1)(B,"image","flipLeftRight","float32");return n.hu(4===O.rank,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${O.rank}.`),h.BV.runKernel(d.Uyb,{image:O},{})}}),Zo=(0,a.op)({grayscaleToRGB_:function jo(B){const O=(0,o._1)(B,"image","grayscaleToRGB"),M=O.rank-1,P=O.shape[M];n.hu(O.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${O.rank}.`),n.hu(1===P,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${P}.`);const R=new Array(O.rank);return R.fill(1,0,M),R[M]=3,(0,ne.G)(O,R)}}),Yo=(0,a.op)({rotateWithOffset_:function Qo(B,O,M=0,P=.5){const R=(0,o._1)(B,"image","rotateWithOffset","float32");return n.hu(4===R.rank,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${R.rank}.`),h.BV.runKernel(d.b9H,{image:R},{radians:O,fillValue:M,center:P})}});function os(B,O,M,P,R,$){null==P&&(P=.5),null==R&&(R=Number.NEGATIVE_INFINITY),null==$&&($=0);const L=B.shape[0];return M=Math.min(M,L),n.hu(0<=P&&P<=1,()=>`iouThreshold must be in [0, 1], but was '${P}'`),n.hu(2===B.rank,()=>`boxes must be a 2D tensor, but was of rank '${B.rank}'`),n.hu(4===B.shape[1],()=>`boxes must have 4 columns, but 2nd dimension was ${B.shape[1]}`),n.hu(1===O.rank,()=>"scores must be a 1D tensor"),n.hu(O.shape[0]===L,()=>`scores has incompatible shape with boxes. Expected ${L}, but was ${O.shape[0]}`),n.hu(0<=$&&$<=1,()=>`softNmsSigma must be in [0, 1], but was '${$}'`),{maxOutputSize:M,iouThreshold:P,scoreThreshold:R,softNmsSigma:$}}const qo=(0,a.op)({nonMaxSuppression_:function Jo(B,O,M,P=.5,R=Number.NEGATIVE_INFINITY){const $=(0,o._1)(B,"boxes","nonMaxSuppression","float32"),L=(0,o._1)(O,"scores","nonMaxSuppression","float32"),X=os($,L,M,P,R);return h.BV.runKernel(d.uv1,{boxes:$,scores:L},{maxOutputSize:M=X.maxOutputSize,iouThreshold:P=X.iouThreshold,scoreThreshold:R=X.scoreThreshold})}});var Po=t(1831);function Oo(){return(Oo=(0,An.Z)(function*(B,O,M,P=.5,R=Number.NEGATIVE_INFINITY){const $=(0,o._1)(B,"boxes","nonMaxSuppressionAsync"),L=(0,o._1)(O,"scores","nonMaxSuppressionAsync"),X=os($,L,M,P,R);M=X.maxOutputSize,P=X.iouThreshold,R=X.scoreThreshold;const nt=yield Promise.all([$.data(),L.data()]),rt=nt[0],ht=nt[1],{selectedIndices:dt}=(0,Po.GP)(rt,ht,M,P,R);return $!==B&&$.dispose(),L!==O&&L.dispose(),En(dt,"int32")})).apply(this,arguments)}const sa=(0,a.op)({nonMaxSuppressionWithScore_:function ea(B,O,M,P=.5,R=Number.NEGATIVE_INFINITY,$=0){const L=(0,o._1)(B,"boxes","nonMaxSuppression"),X=(0,o._1)(O,"scores","nonMaxSuppression"),nt=os(L,X,M,P,R,$),dt=h.BV.runKernel(d.W0H,{boxes:L,scores:X},{maxOutputSize:M=nt.maxOutputSize,iouThreshold:P=nt.iouThreshold,scoreThreshold:R=nt.scoreThreshold,softNmsSigma:$=nt.softNmsSigma});return{selectedIndices:dt[0],selectedScores:dt[1]}}});function To(){return(To=(0,An.Z)(function*(B,O,M,P=.5,R=Number.NEGATIVE_INFINITY,$=0){const L=(0,o._1)(B,"boxes","nonMaxSuppressionAsync"),X=(0,o._1)(O,"scores","nonMaxSuppressionAsync"),nt=os(L,X,M,P,R,$);M=nt.maxOutputSize,P=nt.iouThreshold,R=nt.scoreThreshold,$=nt.softNmsSigma;const rt=yield Promise.all([L.data(),X.data()]),ht=rt[0],dt=rt[1],{selectedIndices:vt,selectedScores:yt}=(0,Po.pA)(ht,dt,M,P,R,$);return L!==B&&L.dispose(),X!==O&&X.dispose(),{selectedIndices:En(vt,"int32"),selectedScores:En(yt)}})).apply(this,arguments)}const ia=(0,a.op)({nonMaxSuppressionPadded_:function aa(B,O,M,P=.5,R=Number.NEGATIVE_INFINITY,$=!1){const L=(0,o._1)(B,"boxes","nonMaxSuppression"),X=(0,o._1)(O,"scores","nonMaxSuppression"),nt=os(L,X,M,P,R,null),$t=h.BV.runKernel(d.cye,{boxes:L,scores:X},{maxOutputSize:nt.maxOutputSize,iouThreshold:nt.iouThreshold,scoreThreshold:nt.scoreThreshold,padToMaxOutputSize:$});return{selectedIndices:$t[0],validOutputs:$t[1]}}});function Io(){return(Io=(0,An.Z)(function*(B,O,M,P=.5,R=Number.NEGATIVE_INFINITY,$=!1){const L=(0,o._1)(B,"boxes","nonMaxSuppressionAsync"),X=(0,o._1)(O,"scores","nonMaxSuppressionAsync"),nt=os(L,X,M,P,R,null),rt=nt.maxOutputSize,ht=nt.iouThreshold,dt=nt.scoreThreshold,[vt,yt]=yield Promise.all([L.data(),X.data()]),{selectedIndices:$t,validOutputs:Kt}=(0,Po.qP)(vt,yt,rt,ht,dt,$);return L!==B&&L.dispose(),X!==O&&X.dispose(),{selectedIndices:En($t,"int32"),validOutputs:(0,Jt.i)(Kt,"int32")}})).apply(this,arguments)}var ca=t(4849),ha=t(2653);const pa=(0,a.op)({threshold_:function da(B,O="binary",M=!1,P=.5){const R=(0,o._1)(B,"image","threshold"),nt=R.shape[0]*R.shape[1];let ht,dt,vt,yt,rt=(0,V.d)(En([P]),255);if(n.hu(3===R.rank,()=>`Error in threshold: image must be rank 3,but got rank ${R.rank}.`),n.hu(3===R.shape[2]||1===R.shape[2],()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${R.shape[2]}.`),n.hu("int32"===R.dtype||"float32"===R.dtype,()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${R.dtype}.`),n.hu("otsu"===O||"binary"===O,()=>`Method must be binary or otsu, but was ${O}`),3===R.shape[2]){[ht,dt,vt]=(0,er.V)(R,[1,1,1],-1);const St=(0,V.d)(ht,.2989),Nt=(0,V.d)(dt,.587),an=(0,V.d)(vt,.114);yt=(0,p.I)((0,p.I)(St,Nt),an)}else yt=B;"otsu"===O&&(rt=function fa(B,O){let $,L,X,nt,rt,ht,M=En([-1]),P=En([0]),R=En([0]);for(let dt=0;dt<B.size-1;dt++){$=(0,U.t)(B,0,dt+1),L=(0,U.t)(B,dt+1),rt=(0,Yt.h)((0,sn.S)($),O),ht=(0,Yt.h)((0,sn.S)(L),O);const vt=(0,sn.S)((0,V.d)($,Zn(0,$.size)));X=(0,Yt.h)(vt,(0,sn.S)($));const yt=(0,pe.h)(L.shape,$.size),$t=(0,p.I)(Zn(0,L.size),yt),Kt=(0,V.d)(L,$t);nt=(0,Yt.h)((0,sn.S)(Kt),(0,sn.S)(L));const St=(0,Ut.l)(X,nt),Nt=(0,Ut.l)(X,nt),an=(0,V.d)(rt,ht);R=(0,V.d)((0,V.d)(an,St),Nt);const hn=(0,In.p)(R,P);P=(0,Qn.a)(hn,R,P),M=(0,Qn.a)(hn,En([dt]),M)}return M}(Rt((0,k.p)((0,Er.N)(yt),"int32"),(0,or.X)([]),256),nt));const $t=M?(0,cn.z)(yt,rt):(0,In.p)(yt,rt);return(0,k.p)((0,V.d)($t,255),"int32")}}),ma=(0,a.op)({transform_:function Ea(B,O,M="nearest",P="constant",R=0,$){const L=(0,o._1)(B,"image","transform","float32"),X=(0,o._1)(O,"transforms","transform","float32");return n.hu(4===L.rank,()=>`Error in transform: image must be rank 4,but got rank ${L.rank}.`),n.hu(2===X.rank&&(X.shape[0]===L.shape[0]||1===X.shape[0])&&8===X.shape[1],()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),n.hu(null==$||2===$.length,()=>`Error in transform: outputShape must be [height, width] or null, but got ${$}.`),h.BV.runKernel(d.wx7,{image:L,transforms:X},{interpolation:M,fillMode:P,fillValue:R,outputShape:$})}}),_a=(0,a.op)({bandPart_:function ga(B,O,M){const P=(0,o._1)(B,"a","bandPart");(0,n.hu)(P.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${P.rank}.`);const R=P.shape,[$,L]=P.shape.slice(-2);let X,nt;"number"==typeof O?((0,n.hu)(O%1==0,()=>`bandPart(): numLower must be an integer, got ${O}.`),(0,n.hu)(O<=$,()=>`bandPart(): numLower (${O}) must not be greater than the number of rows (${$}).`),X=(0,o._1)(O<0?$:O,"numLower","bandPart")):((0,n.hu)("int32"===O.dtype,()=>"bandPart(): numLower's dtype must be an int32."),X=(0,Qn.a)((0,_n.d)(O,0),$,(0,ae.L)(O,$))),"number"==typeof M?((0,n.hu)(M%1==0,()=>`bandPart(): numUpper must be an integer, got ${M}.`),(0,n.hu)(M<=L,()=>`bandPart(): numUpper (${M}) must not be greater than the number of columns (${L}).`),nt=(0,o._1)(M<0?L:M,"numUpper","bandPart")):((0,n.hu)("int32"===M.dtype,()=>"bandPart(): numUpper's dtype must be an int32."),nt=(0,Qn.a)((0,_n.d)(M,0),L,(0,ae.L)(M,L)));const rt=(0,_.X)(Zn(0,$,1,"int32"),[-1,1]),ht=Zn(0,L,1,"int32"),dt=(0,Ut.l)(rt,ht),vt=(0,ke.H)((0,cn.z)(dt,X),(0,Fe.b)(dt,(0,Gn.W)(nt))),yt=(0,Or.l)([$,L],P.dtype);return(0,_.X)((0,Ce.k)((0,ar.H)((0,_.X)(P,[-1,$,L])).map($t=>(0,Qn.a)(vt,$t,yt))),R)}}),Ma=(0,a.op)({gramSchmidt_:function Da(B){let O;if(Array.isArray(B)){O=!1,(0,n.hu)(null!=B&&B.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const R=B[0].shape[0];for(let $=1;$<B.length;++$)(0,n.hu)(B[$].shape[0]===R,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${B[$].shape[0]} vs. ${R})`)}else O=!0,B=(0,er.V)(B,B.shape[0],0).map(R=>(0,sr.L)(R,[0]));(0,n.hu)(B.length<=B[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${B.length}) exceeds number of dimensions (${B[0].shape[0]}).`);const M=[],P=B;for(let R=0;R<B.length;++R)M.push(h.BV.tidy(()=>{let $=P[R];if(R>0)for(let L=0;L<R;++L){const X=(0,V.d)((0,sn.S)((0,V.d)(M[L],$)),M[L]);$=(0,Ut.l)($,X)}return(0,Yt.h)($,(0,u.K)($,"euclidean"))}));return O?(0,Ce.k)(M,0):M}});var va=t(2133);function Ro(B,O=!1){return h.BV.tidy(()=>{(0,n.hu)(2===B.shape.length,()=>`qr2d() requires a 2D Tensor, but got a ${B.shape.length}D Tensor.`);const M=B.shape[0],P=B.shape[1];let R=Ne(M),$=(0,wt.d)(B);const L=xe([[1]],[1,1]);let X=(0,wt.d)(L);const nt=M>=P?P:M;for(let rt=0;rt<nt;++rt){const ht=$,dt=X,vt=R;[X,$,R]=h.BV.tidy(()=>{const yt=(0,U.t)($,[rt,rt],[M-rt,1]),$t=(0,u.K)(yt),Kt=(0,U.t)($,[rt,rt],[1,1]),St=(0,Qn.a)((0,In.p)(Kt,0),xe([[-1]]),xe([[1]])),Nt=(0,Ut.l)(Kt,(0,V.d)(St,$t)),an=(0,Yt.h)(yt,Nt);X=1===an.shape[0]?(0,wt.d)(L):(0,x.z)([L,(0,U.t)(an,[1,0],[an.shape[0]-1,an.shape[1]])],0);const hn=(0,Gn.W)((0,Yt.h)((0,w.O)(St,Nt),$t)),dn=(0,U.t)($,[rt,0],[M-rt,P]),nn=(0,V.d)(hn,X),Lt=(0,ss.p)(X);if(0===rt)$=(0,Ut.l)(dn,(0,w.O)(nn,(0,w.O)(Lt,dn)));else{const Ht=(0,Ut.l)(dn,(0,w.O)(nn,(0,w.O)(Lt,dn)));$=(0,x.z)([(0,U.t)($,[0,0],[rt,P]),Ht],0)}const qt=(0,ss.p)(nn),Zt=(0,U.t)(R,[0,rt],[M,R.shape[1]-rt]);if(0===rt)R=(0,Ut.l)(Zt,(0,w.O)((0,w.O)(Zt,X),qt));else{const Ht=(0,Ut.l)(Zt,(0,w.O)((0,w.O)(Zt,X),qt));R=(0,x.z)([(0,U.t)(R,[0,0],[M,rt]),Ht],1)}return[X,$,R]}),(0,va.B9)([ht,dt,vt])}return!O&&M>P&&(R=(0,U.t)(R,[0,0],[M,P]),$=(0,U.t)($,[0,0],[P,P])),[R,$]})}const Oa=(0,a.op)({qr_:function Pa(B,O=!1){if((0,n.hu)(B.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${B.rank}`),2===B.rank)return Ro(B,O);{const M=B.shape.slice(0,B.shape.length-2).reduce((nt,rt)=>nt*rt),P=(0,ar.H)((0,_.X)(B,[M,B.shape[B.shape.length-2],B.shape[B.shape.length-1]]),0),R=[],$=[];return P.forEach(nt=>{const[rt,ht]=Ro(nt,O);R.push(rt),$.push(ht)}),[(0,_.X)((0,Ce.k)(R,0),B.shape),(0,_.X)((0,Ce.k)($,0),B.shape)]}}});var Pn=t(1976);const Yn=(0,a.op)({computeWeightedLoss_:function Ta(B,O,M=Pn.I.SUM_BY_NONZERO_WEIGHTS){const P=(0,o._1)(B,"losses","computeWeightedLoss");let R=null;null!=O&&(R=(0,o._1)(O,"weights","computeWeightedLoss"));const $=null==R?P:(0,V.d)(P,R);if(M===Pn.I.NONE)return $;if(M===Pn.I.SUM)return(0,sn.S)($);if(M===Pn.I.MEAN){if(null==R)return(0,oe.J)($);{const L=P.size/R.size,X=(0,Yt.h)((0,sn.S)($),(0,sn.S)(R));return L>1?(0,Yt.h)(X,(0,Jt.i)(L)):X}}if(M===Pn.I.SUM_BY_NONZERO_WEIGHTS){if(null==R)return(0,Yt.h)((0,sn.S)($),(0,Jt.i)(P.size));{const L=(0,V.d)(R,(0,Wn.i)(P.shape)),X=(0,k.p)((0,sn.S)((0,Oe.Q)(L,(0,Jt.i)(0))),"float32");return(0,Yt.h)((0,sn.S)($),X)}}throw Error(`Unknown reduction: ${M}`)}}),ya=(0,a.op)({absoluteDifference_:function Ia(B,O,M,P=Pn.I.SUM_BY_NONZERO_WEIGHTS){const R=(0,o._1)(B,"labels","absoluteDifference"),$=(0,o._1)(O,"predictions","absoluteDifference");let L=null;null!=M&&(L=(0,o._1)(M,"weights","absoluteDifference")),(0,n.k5)(R.shape,$.shape,"Error in absoluteDifference: ");const X=(0,D.W)((0,Ut.l)(R,$));return Yn(X,L,P)}}),Ba=(0,a.op)({cosineDistance_:function Aa(B,O,M,P,R=Pn.I.SUM_BY_NONZERO_WEIGHTS){const $=(0,o._1)(B,"labels","cosineDistance"),L=(0,o._1)(O,"predictions","cosineDistance");let X=null;null!=P&&(X=(0,o._1)(P,"weights","cosineDistance")),(0,n.k5)($.shape,L.shape,"Error in cosineDistance: ");const nt=(0,Jt.i)(1),rt=(0,Ut.l)(nt,(0,sn.S)((0,V.d)($,L),M,!0));return Yn(rt,X,R)}}),Ca=(0,a.op)({hingeLoss_:function Ra(B,O,M,P=Pn.I.SUM_BY_NONZERO_WEIGHTS){let R=(0,o._1)(B,"labels","hingeLoss");const $=(0,o._1)(O,"predictions","hingeLoss");let L=null;null!=M&&(L=(0,o._1)(M,"weights","hingeLoss")),(0,n.k5)(R.shape,$.shape,"Error in hingeLoss: ");const X=(0,Jt.i)(1);R=(0,Ut.l)((0,V.d)((0,Jt.i)(2),R),X);const nt=(0,ts.U)((0,Ut.l)(X,(0,V.d)(R,$)));return Yn(nt,L,P)}}),$a=(0,a.op)({huberLoss_:function xa(B,O,M,P=1,R=Pn.I.SUM_BY_NONZERO_WEIGHTS){const $=(0,o._1)(B,"labels","huberLoss"),L=(0,o._1)(O,"predictions","huberLoss");let X=null;null!=M&&(X=(0,o._1)(M,"weights","huberLoss")),(0,n.k5)($.shape,L.shape,"Error in huberLoss: ");const nt=(0,Jt.i)(P),rt=(0,D.W)((0,Ut.l)(L,$)),ht=(0,ae.L)(rt,nt),dt=(0,Ut.l)(rt,ht),vt=(0,p.I)((0,V.d)((0,Jt.i)(.5),(0,Me.h)(ht)),(0,V.d)(nt,dt));return Yn(vt,X,R)}}),La=(0,a.op)({logLoss_:function Sa(B,O,M,P=1e-7,R=Pn.I.SUM_BY_NONZERO_WEIGHTS){const $=(0,o._1)(B,"labels","logLoss"),L=(0,o._1)(O,"predictions","logLoss");let X=null;null!=M&&(X=(0,o._1)(M,"weights","logLoss")),(0,n.k5)($.shape,L.shape,"Error in logLoss: ");const nt=(0,Jt.i)(1),rt=(0,Jt.i)(P),ht=(0,Gn.W)((0,V.d)($,(0,ee.c)((0,p.I)(L,rt)))),dt=(0,V.d)((0,Ut.l)(nt,$),(0,ee.c)((0,p.I)((0,Ut.l)(nt,L),rt))),vt=(0,Ut.l)(ht,dt);return Yn(vt,X,R)}}),Ua=(0,a.op)({meanSquaredError_:function Wa(B,O,M,P=Pn.I.SUM_BY_NONZERO_WEIGHTS){const R=(0,o._1)(B,"labels","meanSquaredError"),$=(0,o._1)(O,"predictions","meanSquaredError");let L=null;null!=M&&(L=(0,o._1)(M,"weights","meanSquaredError")),(0,n.k5)(R.shape,$.shape,"Error in meanSquaredError: ");const X=(0,Mr.$)(R,$);return Yn(X,L,P)}}),Na=(0,a.op)({sigmoidCrossEntropy_:function ba(B,O,M,P=0,R=Pn.I.SUM_BY_NONZERO_WEIGHTS){let $=(0,o._1)(B,"multiClassLabels","sigmoidCrossEntropy");const L=(0,o._1)(O,"logits","sigmoidCrossEntropy");let X=null;if(null!=M&&(X=(0,o._1)(M,"weights","sigmoidCrossEntropy")),(0,n.k5)($.shape,L.shape,"Error in sigmoidCrossEntropy: "),P>0){const rt=(0,Jt.i)(P),ht=(0,Jt.i)(1),dt=(0,Jt.i)(.5);$=(0,p.I)((0,V.d)($,(0,Ut.l)(ht,rt)),(0,V.d)(dt,rt))}const nt=function Ka(B,O){const M=(0,o._1)(B,"labels","sigmoidCrossEntropyWithLogits"),P=(0,o._1)(O,"logits","sigmoidCrossEntropyWithLogits");(0,n.k5)(M.shape,P.shape,"Error in sigmoidCrossEntropyWithLogits: ");const R=(0,ts.U)(P),$=(0,V.d)(P,M),L=(0,Dn.K)((0,te.Q)((0,Gn.W)((0,D.W)(P))));return(0,p.I)((0,Ut.l)(R,$),L)}($,L);return Yn(nt,X,R)}}),Va=(0,a.op)({softmaxCrossEntropy_:function Fa(B,O,M,P=0,R=Pn.I.SUM_BY_NONZERO_WEIGHTS){let $=(0,o._1)(B,"onehotLabels","softmaxCrossEntropy");const L=(0,o._1)(O,"logits","softmaxCrossEntropy");let X=null;if(null!=M&&(X=(0,o._1)(M,"weights","softmaxCrossEntropy")),(0,n.k5)($.shape,L.shape,"Error in softmaxCrossEntropy: "),P>0){const rt=(0,Jt.i)(P),ht=(0,Jt.i)(1),dt=(0,Jt.i)($.shape[1]);$=(0,p.I)((0,V.d)($,(0,Ut.l)(ht,rt)),(0,Yt.h)(rt,dt))}const nt=function wa(B,O,M=-1){if(-1===M&&(M=O.rank-1),M!==O.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${O.rank} and dim was ${M}`);return(0,gn.cb)((R,$,L)=>{const nt=(0,se.l)($,[M],!0),rt=(0,Ut.l)((0,k.p)($,"float32"),nt);L([R,rt]);const ht=(0,Gn.W)((0,V.d)(rt,R));return{value:(0,sn.S)(ht,[M]),gradFunc:(yt,$t)=>{const[Kt,St]=$t,Nt=(0,ze.rv)(yt.shape,[M]);return[(0,V.d)((0,_.X)(yt,Nt),(0,Ut.l)((0,k.p)(Kt,"float32"),(0,te.Q)(St))),(0,V.d)((0,_.X)(yt,Nt),(0,Ut.l)((0,te.Q)(St),(0,k.p)(Kt,"float32")))]}}})(B,O)}($,L);return Yn(nt,X,R)}}),oi={fft:gr.k,ifft:_r.S,rfft:es.Q,irfft:Dr.w},ai={hammingWindow:No,hannWindow:Ao,frame:Bo,stft:ko},ii={flipLeftRight:Xo,grayscaleToRGB:Zo,resizeNearestNeighbor:ha.j,resizeBilinear:ca.I,rotateWithOffset:Yo,cropAndResize:zo,nonMaxSuppression:qo,nonMaxSuppressionAsync:function ta(B,O,M){return Oo.apply(this,arguments)},nonMaxSuppressionWithScore:sa,nonMaxSuppressionWithScoreAsync:function ra(B,O,M){return To.apply(this,arguments)},nonMaxSuppressionPadded:ia,nonMaxSuppressionPaddedAsync:function la(B,O,M){return Io.apply(this,arguments)},threshold:pa,transform:ma},li={bandPart:_a,gramSchmidt:Ma,qr:Oa},ui={absoluteDifference:ya,computeWeightedLoss:Yn,cosineDistance:Ba,hingeLoss:Ca,huberLoss:$a,logLoss:La,meanSquaredError:Ua,sigmoidCrossEntropy:Na,softmaxCrossEntropy:Va},ci={sparseFillEmptyRows:(0,a.op)({sparseFillEmptyRows_:function ka(B,O,M,P){const R=(0,o._1)(B,"indices","sparseFillEmptyRows","int32"),$=(0,o._1)(O,"values","sparseFillEmptyRows"),L=(0,o._1)(M,"denseShape","sparseFillEmptyRows","int32"),X=(0,o._1)(P,"defaultValue","sparseFillEmptyRows",$.dtype);if(2!==R.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${R.shape}`);if(1!==$.rank)throw new Error(`Values should be Tensor1D but received shape ${$.shape}`);if(1!==L.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${L.shape}`);if(0!==X.rank)throw new Error(`Default value should be a scalar but received shape ${X.shape}`);const rt=h.BV.runKernel(d.O3z,{indices:R,values:$,denseShape:L,defaultValue:X});return{outputIndices:rt[0],outputValues:rt[1],emptyRowIndicator:rt[2],reverseIndexMap:rt[3]}}}),sparseReshape:(0,a.op)({sparseReshape_:function za(B,O,M){const P=(0,o._1)(B,"inputIndices","sparseReshape","int32"),R=(0,o._1)(O,"inputShape","sparseReshape","int32"),$=(0,o._1)(M,"newShape","sparseReshape","int32");if(2!==P.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${P.shape}`);if(1!==R.rank)throw new Error(`Input shape should be Tensor1D but received shape ${R.shape}`);if(1!==$.rank)throw new Error(`New shape should be Tensor1D but received shape ${$.shape}`);const X=h.BV.runKernel(d.nhH,{inputIndices:P,inputShape:R,newShape:$});return{outputIndices:X[0],outputShape:X[1]}}}),sparseSegmentMean:(0,a.op)({sparseSegmentMean_:function Xa(B,O,M){const P=(0,o._1)(B,"data","sparseSegmentMean"),R=(0,o._1)(O,"indices","sparseSegmentMean","int32"),$=(0,o._1)(M,"segmentIds","sparseSegmentMean","int32");if(P.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==R.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${R.shape}`);if(1!==$.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${$.shape}`);return h.BV.runKernel(d.w3H,{data:P,indices:R,segmentIds:$})}}),sparseSegmentSum:(0,a.op)({sparseSegmentSum_:function Za(B,O,M){const P=(0,o._1)(B,"data","sparseSegmentSum"),R=(0,o._1)(O,"indices","sparseSegmentSum","int32"),$=(0,o._1)(M,"segmentIds","sparseSegmentSum","int32");if(P.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==R.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${R.shape}`);if(1!==$.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${$.shape}`);return h.BV.runKernel(d.ZjV,{data:P,indices:R,segmentIds:$})}})},hi={stringNGrams:(0,a.op)({stringNGrams_:function Ya(B,O,M,P,R,$,L,X){const nt=(0,o._1)(B,"data","stringNGrams","string");if("string"!==nt.dtype)throw new Error("Data must be of datatype string");if(1!==nt.shape.length)throw new Error(`Data must be a vector, saw: ${nt.shape}`);const rt=(0,o._1)(O,"dataSplits","stringNGrams");if("int32"!==rt.dtype)throw new Error("Data splits must be of datatype int32");const vt=h.BV.runKernel(d._JP,{data:nt,dataSplits:rt},{separator:M,nGramWidths:P,leftPad:R,rightPad:$,padWidth:L,preserveShortSequences:X});return{nGrams:vt[0],nGramsSplits:vt[1]}}}),stringSplit:(0,a.op)({stringSplit_:function qa(B,O,M=!0){const P=(0,o._1)(B,"input","stringSplit","string"),R=(0,o._1)(O,"delimiter","stringSplit","string");if(1!==P.rank)throw new Error(`Input should be Tensor1D but received shape ${P.shape}`);if(0!==R.rank)throw new Error(`Delimiter should be a scalar but received shape ${R.shape}`);const X=h.BV.runKernel(d.s1s,{input:P,delimiter:R},{skipEmpty:M});return{indices:X[0],values:X[1],shape:X[2]}}}),stringToHashBucketFast:(0,a.op)({stringToHashBucketFast_:function ni(B,O){const M=(0,o._1)(B,"input","stringToHashBucketFast","string"),P={numBuckets:O};if(O<=0)throw new Error("Number of buckets must be at least 1");return h.BV.runKernel(d.XkS,{input:M},P)}}),staticRegexReplace:(0,a.op)({staticRegexReplace_:function si(B,O,M,P=!0){const R=(0,o._1)(B,"input","staticRegexReplace","string");return h.BV.runKernel(d.e0R,{x:R},{pattern:O,rewrite:M,replaceGlobal:P})}})}},1357:(Q,v,t)=>{"use strict";t.r(v),t.d(v,{OP_SCOPE_SUFFIX:()=>e.zvA,abs:()=>e.WnP,acos:()=>e.Khb,acosh:()=>e.__u,add:()=>e.IHx,addN:()=>e.QBD,all:()=>e.$6P,any:()=>e.YjB,argMax:()=>e.NqF,argMin:()=>e.vHJ,asin:()=>e.ZRM,asinh:()=>e.VfV,atan:()=>e.z4N,atan2:()=>e.fvJ,atanh:()=>e.C80,avgPool:()=>e.wS1,avgPool3d:()=>e.uR5,basicLSTMCell:()=>e.zEQ,batchNorm:()=>e.tgs,batchNorm2d:()=>e.Dxk,batchNorm3d:()=>e.JY5,batchNorm4d:()=>e.p3b,batchToSpaceND:()=>e.E4h,bincount:()=>e.yE8,bitwiseAnd:()=>e.ycw,booleanMaskAsync:()=>e.anm,broadcastArgs:()=>e.XsQ,broadcastTo:()=>e.UFq,buffer:()=>e.f3b,cast:()=>e.pju,ceil:()=>e.mDi,clipByValue:()=>e.iUl,clone:()=>e.d9v,complex:()=>e.PYB,concat:()=>e.zoF,concat1d:()=>e.gME,concat2d:()=>e.Izb,concat3d:()=>e.MNy,concat4d:()=>e.ZaL,conv1d:()=>e.PAt,conv2d:()=>e.Tek,conv2dTranspose:()=>e.bc,conv3d:()=>e.pdZ,conv3dTranspose:()=>e.$QV,cos:()=>e.mCk,cosh:()=>e.f9Y,cosineWindow:()=>e.mew,cumprod:()=>e.$Gn,cumsum:()=>e.zbp,denseBincount:()=>e.ppE,depthToSpace:()=>e.nTT,depthwiseConv2d:()=>e.B10,diag:()=>e.Ka3,dilation2d:()=>e.WmZ,div:()=>e.hiC,divNoNan:()=>e.NTj,dot:()=>e.AKD,dropout:()=>e.rvX,einsum:()=>e.WYO,elu:()=>e.pyx,enclosingPowerOfTwo:()=>e.GRh,ensureShape:()=>e.EDe,equal:()=>e.DgJ,erf:()=>e.qNN,euclideanNorm:()=>e.d2q,exp:()=>e.Qqt,expandDims:()=>e.dt4,expm1:()=>e.t$B,eye:()=>e.iyy,fft:()=>e.kp_,fill:()=>e.hlL,floor:()=>e.GWj,floorDiv:()=>e.qPi,fused:()=>e.imm,gather:()=>e.Iqj,gatherND:()=>e.dbB,greater:()=>e.pjt,greaterEqual:()=>e.brS,ifft:()=>e.Sxn,imag:()=>e.asL,image:()=>e.BHj,inTopKAsync:()=>e.V3u,irfft:()=>e.wx0,isFinite:()=>e.xVT,isInf:()=>e.UWc,isNaN:()=>e.i2d,leakyRelu:()=>e.hi7,less:()=>e.d9m,lessEqual:()=>e.zN1,linalg:()=>e.$r2,linspace:()=>e.SX3,localResponseNormalization:()=>e.G9k,log:()=>e.cM7,log1p:()=>e.Krr,logSigmoid:()=>e.e_t,logSoftmax:()=>e.CmS,logSumExp:()=>e.l_t,logicalAnd:()=>e.HvI,logicalNot:()=>e.hJK,logicalOr:()=>e.K5V,logicalXor:()=>e.egP,losses:()=>e.MB5,lowerBound:()=>e.eab,matMul:()=>e.OI3,max:()=>e.Fp7,maxPool:()=>e._sB,maxPool3d:()=>e.YQQ,maxPoolWithArgmax:()=>e.Ip$,maximum:()=>e.gWQ,mean:()=>e.J69,meshgrid:()=>e.ry_,min:()=>e.VV$,minimum:()=>e.LTh,mirrorPad:()=>e.VdP,mod:()=>e.wQq,moments:()=>e.Gi7,movingAverage:()=>e.p_,mul:()=>e.dC7,multiRNNCell:()=>e.rq4,multinomial:()=>e.SJ_,neg:()=>e.W76,norm:()=>e.KOy,notEqual:()=>e.Quu,oneHot:()=>e.lfX,ones:()=>e.iUs,onesLike:()=>e.JpU,op:()=>e.op,outerProduct:()=>e.N2O,pad:()=>e.vku,pad1d:()=>e.pNR,pad2d:()=>e.koy,pad3d:()=>e.t1L,pad4d:()=>e.lGY,pool:()=>e.d_R,pow:()=>e.sQ3,prelu:()=>e.AL3,print:()=>e.S0v,prod:()=>e.WVs,raggedGather:()=>e.$gW,raggedRange:()=>e.VT$,raggedTensorToTensor:()=>e.N89,rand:()=>e.TN_,randomGamma:()=>e.wzB,randomNormal:()=>e.nGf,randomStandardNormal:()=>e.ruB,randomUniform:()=>e.LGj,randomUniformInt:()=>e.pe5,range:()=>e.w6H,real:()=>e.kwC,reciprocal:()=>e.M25,relu:()=>e.UYe,relu6:()=>e.btT,reshape:()=>e.XLQ,reverse:()=>e.GYS,reverse1d:()=>e.SDf,reverse2d:()=>e.diP,reverse3d:()=>e.sx7,reverse4d:()=>e.mG2,rfft:()=>e.QEs,round:()=>e.NMM,rsqrt:()=>e.bp0,scalar:()=>e.iD$,scatterND:()=>e.snQ,searchSorted:()=>e.zcT,selu:()=>e.U8D,separableConv2d:()=>e.U_I,setdiff1dAsync:()=>e.ODp,sigmoid:()=>e.XD2,sign:()=>e.Xxe,signal:()=>e.tdS,sin:()=>e.O$l,sinh:()=>e.R_K,slice:()=>e.tPi,slice1d:()=>e.jZU,slice2d:()=>e.SmN,slice3d:()=>e.CnO,slice4d:()=>e.p0P,softmax:()=>e.XAC,softplus:()=>e.Wvh,spaceToBatchND:()=>e.fBT,sparse:()=>e.rVs,sparseToDense:()=>e.ers,spectral:()=>e.uN7,split:()=>e.Vl2,sqrt:()=>e._b3,square:()=>e.h62,squaredDifference:()=>e.$i,squeeze:()=>e.L9e,stack:()=>e.knu,step:()=>e.Nbs,stridedSlice:()=>e.NXj,string:()=>e.Z_8,sub:()=>e.luU,sum:()=>e.Smz,tan:()=>e.ORZ,tanh:()=>e.AEp,tensor:()=>e.XeE,tensor1d:()=>e.RRF,tensor2d:()=>e.odF,tensor3d:()=>e.wOQ,tensor4d:()=>e.yXz,tensor5d:()=>e.Bfx,tensor6d:()=>e.xZs,tensorScatterUpdate:()=>e.Pg0,tile:()=>e.Gg6,topk:()=>e.hg7,transpose:()=>e.p4s,truncatedNormal:()=>e.Xu6,unique:()=>e.Two,unsortedSegmentSum:()=>e.pUJ,unstack:()=>e.HHK,upperBound:()=>e.GaM,variable:()=>e.VD$,where:()=>e.arb,whereAsync:()=>e.itS,zeros:()=>e.lls,zerosLike:()=>e.P84});var e=t(9587)},1824:(Q,v,t)=>{"use strict";t.d(v,{v:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({pad_:function p(d,o,n=0){const a=(0,f._1)(d,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");return e.BV.runKernel(D.lyA,{x:a},{paddings:o,constantValue:n})}})},5415:(Q,v,t)=>{"use strict";t.d(v,{d:()=>g});var e=t(4810),D=t(62),f=t(282),m=t(1601),p=t(7202),h=t(7542),d=t(5948),o=t(3626),n=t(1705);const g=(0,d.op)({pool_:function a(C,I,S,K,z,H,ct){null==z&&(z=[1,1]),null==H&&(H=1),0===K&&(K="valid");const N=(0,e._1)(C,"x","maxPool");let W=N,k=!1;3===N.rank&&(k=!0,W=(0,o.X)(N,[1,N.shape[0],N.shape[1],N.shape[2]])),D.hu(p.jT(H,z),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${H} and dilations '${z}'`);const T=p.Xw(W.shape,I,H,z,K),_=[T.dilationHeight,T.dilationWidth];let r;r="same"===K?function i(C,I){const K=C.map((ct,N)=>ct+(ct-1)*(I[N]-1)).map(ct=>ct-1),z=K.map(ct=>Math.floor(ct/2)),H=K.map((ct,N)=>ct-z[N]);return K.map((ct,N)=>[z[N],H[N]])}([T.filterHeight,T.filterWidth],_):[[0,0],[0,0]];const y=1===_[0]&&1===_[1],[x,w]=function c(C,I,S){const K=S.map(T=>T[0]),z=S.map(T=>T[1]),H=C.concat(K,z),ct=I.map((T,_)=>(T-H[_]%T)%T),N=z.map((T,_)=>T+ct[_]),W=I.map((T,_)=>[K[_],N[_]]),k=I.map((T,_)=>[0,ct[_]]);return[W,k]}([T.inHeight,T.inWidth],_,r),V=y?K:"valid",et=y?W:(0,n.f)(W,_,x),F=("avg"===S?()=>(0,f.w)(et,I,H,V,ct):()=>(0,h._)(et,I,H,V,ct))(),Y=y?F:(0,m.E)(F,_,w);return k?(0,o.X)(Y,[Y.shape[1],Y.shape[2],Y.shape[3]]):Y}})},2293:(Q,v,t)=>{"use strict";t.d(v,{s:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({pow_:function h(o,n){let a=(0,m._1)(o,"base","pow"),c=(0,m._1)(n,"exp","pow");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.pe_,{a,b:c})}})},4845:(Q,v,t)=>{"use strict";t.d(v,{A:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({prelu_:function p(d,o){const n=(0,f._1)(d,"x","prelu"),a=(0,f._1)(o,"alpha","prelu");return e.BV.runKernel(D.o0g,{x:n,alpha:a})}})},5514:(Q,v,t)=>{"use strict";function e(D,f=!1){console.log(D.toString(f))}t.d(v,{S:()=>e})},9357:(Q,v,t)=>{"use strict";t.d(v,{W:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(4879);const d=(0,t(5948).op)({prod_:function h(o,n=null,a=!1){let c=(0,f._1)(o,"x","prod");return"bool"===c.dtype&&(c=(0,m.p)(c,"int32")),e.BV.runKernel(D.DlI,{x:c},{axis:n,keepDims:a})}})},6656:(Q,v,t)=>{"use strict";t.d(v,{k:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({real_:function p(d){const n={input:(0,f._1)(d,"input","real")};return e.BV.runKernel(D.xJR,n)}})},9372:(Q,v,t)=>{"use strict";t.d(v,{M:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({reciprocal_:function p(d){const n={x:(0,f._1)(d,"x","reciprocal")};return e.BV.runKernel(D.$HU,n)}})},2047:(Q,v,t)=>{"use strict";t.d(v,{U:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({relu_:function p(d){const n={x:(0,f._1)(d,"x","relu")};return e.BV.runKernel(D.qkr,n)}})},1095:(Q,v,t)=>{"use strict";t.d(v,{b:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({relu6_:function p(d){const n={x:(0,f._1)(d,"x","relu6")};return e.BV.runKernel(D.SbG,n)}})},3626:(Q,v,t)=>{"use strict";t.d(v,{X:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({reshape_:function p(d,o){const a={x:(0,f._1)(d,"x","reshape","string_or_numeric")};return e.BV.runKernel(D.HZH,a,{shape:o})}})},7661:(Q,v,t)=>{"use strict";t.d(v,{G:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({reverse_:function p(d,o){const a={x:(0,f._1)(d,"x","reverse")};return e.BV.runKernel(D.mKl,a,{dims:o})}})},2688:(Q,v,t)=>{"use strict";t.d(v,{N:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({round_:function p(d){const n={x:(0,f._1)(d,"x","round")};return e.BV.runKernel(D.e07,n)}})},242:(Q,v,t)=>{"use strict";t.d(v,{b:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({rsqrt_:function p(d){const n={x:(0,f._1)(d,"x","rsqrt","float32")};return e.BV.runKernel(D.bV0,n)}})},8153:(Q,v,t)=>{"use strict";t.d(v,{i:()=>f});var e=t(1530),D=t(299);function f(m,p){if(((0,e.isTypedArray)(m)&&"string"!==p||Array.isArray(m))&&"complex64"!==p)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===p&&(0,e.isTypedArray)(m)&&!(m instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return(0,D.H)(m,[],[],p)}},7169:(Q,v,t)=>{"use strict";t.r(v),t.d(v,{calculateShapes:()=>m,validateInput:()=>f,validateUpdateShape:()=>D});var e=t(62);function D(p,h,d){const o=h.rank>1?h.shape[h.rank-1]:1,n=h.rank>1?h.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${d.shape}, indices.shape: ${h.shape}, shape: ${p}, sliceDim: ${o}, and batchDim: ${n}.`;if(d.rank<n)throw new Error(a+` update.rank < ${n}. `);if(p.length<o+(d.rank-n))throw new Error(a+` Output shape length < ${o+(d.rank-n)}`);if(d.rank!==n+p.length-o)throw new Error(a+" update.rank != "+(n+p.length-o));for(let c=0;c<n;++c)if(d.shape[c]!==h.shape[c])throw new Error(a+` updates.shape[${c}] (${d.shape[c]}) != indices.shape[${c}] (${h.shape[c]}).`);for(let c=0;c<d.rank-n;++c)if(d.shape[c+n]!==p[c+o])throw new Error(a+` updates.shape[${c+n}] (${d.shape[c+n]}) != shape[${c+n}] (${p[c+n]})`)}function f(p,h,d){if(h.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${h.rank}.`);if(p.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${p.rank}.`);if("int32"!==h.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${h.dtype}`);if(d.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${d}`);if(0===d.length){if(0===h.size)throw new Error(`Indices specified for empty output. indices shape: ${h.shape}`);if(0===p.size)throw new Error(`Updates specified for empty output. updates shape: ${p.shape}`)}D(d,h,p)}function m(p,h,d){const o=h.shape.length,n=o>1?h.shape[o-1]:1,a=d.length;let c=1;for(let S=n;S<a;++S)c*=d[S];const i=n<1?1:n;return{sliceRank:n,numUpdates:(0,e.NA)(h.shape)/i,sliceSize:c,strides:[...(0,e.e3)(d.slice(0,n)),1],outputSize:(0,e.NA)(d)}}},5484:(Q,v,t)=>{"use strict";t.d(v,{U:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({selu_:function p(d){const n={x:(0,f._1)(d,"x","selu")};return e.BV.runKernel(D.oFR,n)}})},287:(Q,v,t)=>{"use strict";t.d(v,{$:()=>D,y:()=>e});const e=1.7580993408473768,D=1.0507009873554805},6020:(Q,v,t)=>{"use strict";t.d(v,{U:()=>o});var e=t(4810),D=t(62),f=t(6509),m=t(2514),p=t(5948),h=t(3626);const o=(0,p.op)({separableConv2d_:function d(n,a,c,i,g,C=[1,1],I="NHWC"){const S=(0,e._1)(n,"x","separableConv2d"),K=(0,e._1)(a,"depthwiseFilter","separableConv2d"),z=(0,e._1)(c,"pointwiseFilter","separableConv2d");let H=S,ct=!1;if(3===S.rank&&(ct=!0,H=(0,h.X)(S,[1,S.shape[0],S.shape[1],S.shape[2]])),"NCHW"===I)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D.hu(4===H.rank,()=>`Error in separableConv2d: input must be rank 4, but got rank ${H.rank}.`),D.hu(4===K.rank,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${K.rank}.`),D.hu(4===z.rank,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${K.rank}.`),D.hu(1===z.shape[0],()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${z.shape[0]}.`),D.hu(1===z.shape[1],()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${z.shape[1]}.`);const N=K.shape[2],W=K.shape[3];D.hu(z.shape[2]===N*W,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${N*W}, but got ${z.shape[2]}.`);const k=(0,m.B)(H,K,i,g,I,C),_=(0,f.T)(k,z,1,"valid",I);return ct?(0,h.X)(_,[_.shape[1],_.shape[2],_.shape[3]]):_}})},4655:(Q,v,t)=>{"use strict";t.d(v,{X:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({sigmoid_:function p(d){const n={x:(0,f._1)(d,"x","sigmoid","float32")};return e.BV.runKernel(D.a5O,n)}})},184:(Q,v,t)=>{"use strict";t.d(v,{X:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({sign_:function p(d){const n={x:(0,f._1)(d,"x","sign")};return e.BV.runKernel(D.i5y,n)}})},1969:(Q,v,t)=>{"use strict";t.d(v,{O:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({sin_:function p(d){const n={x:(0,f._1)(d,"x","sin","float32")};return e.BV.runKernel(D.RQH,n)}})},3981:(Q,v,t)=>{"use strict";t.d(v,{R:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({sinh_:function p(d){const n={x:(0,f._1)(d,"x","sinh")};return e.BV.runKernel(D.wYB,n)}})},8577:(Q,v,t)=>{"use strict";t.d(v,{t:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({slice_:function p(d,o,n){const a=(0,f._1)(d,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");return e.BV.runKernel(D.p2w,{x:a},{begin:o,size:n})}})},4361:(Q,v,t)=>{"use strict";t.r(v),t.d(v,{assertParamsValid:()=>m,computeFlatOffset:()=>K,computeOutShape:()=>h,getNormalizedAxes:()=>a,isSliceContinous:()=>S,maskToAxes:()=>p,parseSliceParams:()=>z,sliceInfo:()=>H,startForAxis:()=>C,startIndicesWithElidedDims:()=>c,stopForAxis:()=>I,stopIndicesWithElidedDims:()=>i,stridesForAxis:()=>g,stridesWithElidedDims:()=>d});var e=t(62);const D=-2,f=-1;function m(W,k,T){const _=W.shape.length;e.hu(_===k.length,()=>`Error in slice${_}D: Length of begin ${k} must match the rank of the array (${_}).`),e.hu(_===T.length,()=>`Error in slice${_}D: Length of size ${T} must match the rank of the array (${_}).`);for(let r=0;r<_;++r)e.hu(k[r]+T[r]<=W.shape[r],()=>`Error in slice${_}D: begin[${r}] + size[${r}] (${k[r]+T[r]}) would overflow input.shape[${r}] (${W.shape[r]})`)}function p(W){const k=[];let T=0;for(;W>0;)1&W&&k.push(T),W/=2,T++;return k}function h(W,k,T){const _=[];for(let r=0;r<W.length;r++)_[r]=Math.ceil((k[r]-W[r])/T[r]);return _}function d(W,k,T,_){const r=[...W];for(let y=r.length;y<_.length;y++)r.push(1);for(let y=0;y<T;y++)0===y?r[k]=1:(r.splice(k,0,1),r.pop());return r}function o(W,k,T){return T<=W?T:T-(k-1)}function n(W,k){const T=[];for(let _=0;_<W;_++)T.push(k+_);return T}function a(W,k,T,_,r,y,x,w,V){const et=W.length;let U=new Array(et),F=new Array(et),Y=new Array(et);if(k.length&&T>0){const tt=k[0],ot=T+1;U=c(x,tt,ot,_,W),F=i(w,tt,ot,r,W),Y=d(y,tt,ot,W)}else for(let tt=0;tt<et;tt++)U[tt]=C(x,_,y,W,tt,V),F[tt]=I(w,r,y,W,tt,V),Y[tt]=g(y,tt,V);return{begin:U,end:F,strides:Y}}function c(W,k,T,_,r){const y=[...r],x=n(T,k);for(let w=0;w<y.length;w++)if(x.indexOf(w)>-1)y[w]=0;else{const V=o(k,T,w);let et=_[V];W&1<<V&&(et=0),y[w]=et}return y}function i(W,k,T,_,r){const y=[...r],x=n(T,k);for(let w=0;w<y.length;w++)if(x.indexOf(w)>-1)y[w]=Number.MAX_SAFE_INTEGER;else{const V=o(k,T,w);let et=_[V];W&1<<V&&(et=Number.MAX_SAFE_INTEGER),y[w]=et}for(let w=0;w<y.length;w++)y[w]<0&&(y[w]+=r[w]),y[w]=e.uZ(0,y[w],r[w]);return y}function g(W,k,T){let _=W[k];return(T&1<<k||null==_)&&(_=1),_}function C(W,k,T,_,r,y){let x=k[r];(W&1<<r||y&1<<r||null==x)&&(x=(T[r]||1)>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const V=_[r];return x<0&&(x+=V),x=e.uZ(0,x,V-1),x}function I(W,k,T,_,r,y){let x=k[r];const w=T[r]||1;(W&1<<r||y&1<<r||null==x)&&(x=w>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const V=_[r];return x<0&&(x+=V),x=w>0?e.uZ(0,x,V):e.uZ(-1,x,V-1),x}function S(W,k,T){let _=T.length;for(let r=0;r<T.length;r++)if(T[r]>1){_=r;break}for(let r=_+1;r<T.length;r++)if(k[r]>0||T[r]!==W[r])return!1;return!0}function K(W,k){let T=W.length>0?W[W.length-1]:1;for(let _=0;_<W.length-1;_++)T+=W[_]*k[_];return T}function z(W,k,T){let _;const r=W.shape.length;let y;return _="number"==typeof k?[k,...new Array(r-1).fill(0)]:k.length<r?k.concat(new Array(r-k.length).fill(0)):k.slice(),_.forEach(x=>{e.hu(-1!==x,()=>"slice() does not support negative begin indexing.")}),y=null==T?new Array(r).fill(-1):"number"==typeof T?[T,...new Array(r-1).fill(-1)]:T.length<r?T.concat(new Array(r-T.length).fill(-1)):T,y=y.map((x,w)=>x>=0?x:(e.hu(-1===x,()=>`Negative size values should be exactly -1 but got ${x} for the slice() size at index ${w}.`),W.shape[w]-_[w])),[_,y]}function H(W,k,T,_,r,y,x,w,V){let et;if(null==_?(et=new Array(k.length),et.fill(1)):et=_,null!=x&&x&x-1)throw new Error("Multiple ellipses in slice is not allowed.");let U=!1;const F={dims:et.length,numAddAxisAfterEllipsis:0,begin:k.slice(),end:T.slice(),strides:et.slice(),beginMask:r,endMask:y,ellipsisMask:x,newAxisMask:w,shrinkAxisMask:V};for(let Et=0;Et<F.dims;Et++)U&&1<<Et&w&&F.numAddAxisAfterEllipsis++,1<<Et&x&&(U=!0);U||(F.ellipsisMask|=1<<F.dims,F.dims++);const Y={dims:W.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function ct(W,k){k.beginMask=0,k.endMask=0,k.shrinkAxisMask=0;let T=0;k.beginValid=null!=W.begin,k.endValid=null!=W.end,k.begin=new Array(k.dims),k.end=new Array(k.dims),k.strides=new Array(k.dims),k.finalShapeGatherIndices=[],k.finalShapeGatherIndicesSparse=[],k.inputShapeGatherIndicesSparse=new Array(k.dims);for(let _=0;_<W.dims;_++)if(1<<_&W.ellipsisMask){const r=Math.min(k.dims-(W.dims-_)+1+W.numAddAxisAfterEllipsis,k.dims);for(;T<r;T++)k.begin[T]=0,k.end[T]=0,k.strides[T]=1,k.beginMask|=1<<T,k.endMask|=1<<T,k.finalShapeGatherIndices.push(T),k.finalShapeGatherIndicesSparse.push(-1),k.inputShapeGatherIndicesSparse[T]=_}else if(1<<_&W.newAxisMask)k.finalShapeGatherIndices.push(D),k.finalShapeGatherIndicesSparse.push(-1);else{if(T===k.begin.length)throw Error(`Index out of range using input dim ${T}; input has only ${k.dims} dims, ${k.begin.length}.`);null!=W.begin&&(k.begin[T]=W.begin[_]),null!=W.end&&(k.end[T]=W.end[_]),k.strides[T]=W.strides[_],W.beginMask&1<<_&&(k.beginMask|=1<<T),W.endMask&1<<_&&(k.endMask|=1<<T),W.shrinkAxisMask&1<<_?(k.finalShapeGatherIndices.push(f),k.finalShapeGatherIndicesSparse.push(-1),k.shrinkAxisMask|=1<<T):(k.finalShapeGatherIndices.push(T),k.finalShapeGatherIndicesSparse.push(_)),k.inputShapeGatherIndicesSparse[T]=_,T++}}(F,Y);let tt=!0,ot=!0,ft=!0;const gt=[],pt=[];for(let Et=0;Et<W.length;++Et){if(0===Y.strides[Et])throw Error(`strides[${Et}] must be non-zero`);const Ct=!!(Y.shrinkAxisMask&1<<Et),At=W[Et];if(-1===At){gt.push(Ct?1:-1);continue}const Ft=[Y.beginMask&1<<Et,Y.endMask&1<<Et],Rt=[Y.strides[Et]>0?0:-1,Y.strides[Et]>0?At:At-1];if(Ct&&Y.strides[Et]<=0)throw Error("only stride 1 allowed on non-range indexing.");ft=ft&&1===Y.strides[Et];const Xt=!!(Y.beginMask&1<<Et&&Y.endMask&1<<Et);if(Y.beginValid&&Y.endValid){if(Ct){const st=Y.begin[Et]<0?At+Y.begin[Et]:Y.begin[Et];if(Y.begin[Et]=st,Y.end[Et]=Y.begin[Et]+1,st<0||st>=At)throw Error(`slice index ${Y.begin[Et]} of dimension ${Et} out of bounds.`)}else Y.begin[Et]=N(Y.begin[Et],0,Y.strides[Et],At,Ft,Rt),Y.end[Et]=N(Y.end[Et],1,Y.strides[Et],At,Ft,Rt);const G=1===Y.strides[Et]&&0===Y.begin[Et]&&Y.end[Et]===At;tt=tt&&G,ot=ot&&(0===Et&&1===Y.strides[Et]||G)}else tt=tt&&1===Y.strides[Et]&&Xt,ot=ot&&(0===Et&&1===Y.strides[Et]||Xt);let en,ln=!1;if(Y.beginValid&&Y.endValid?(en=Y.end[Et]-Y.begin[Et],ln=!0):Ct?(en=1,ln=!0):Xt&&At>=0&&(en=Y.strides[Et]<0?-At:At,ln=!0),ln){let G;G=0===en||en<0!=Y.strides[Et]<0?0:Math.trunc(en/Y.strides[Et])+(en%Y.strides[Et]!=0?1:0),gt.push(G)}else gt.push(-1)}for(let Et=0;Et<Y.finalShapeGatherIndices.length;++Et){const Ct=Y.finalShapeGatherIndices[Et];Ct>=0?pt.push(gt[Ct]):Ct===D&&pt.push(1)}return{finalShapeSparse:pt.filter((Et,Ct)=>Y.finalShapeGatherIndices[Ct]!==D),finalShape:pt,isIdentity:tt,sliceDim0:ot,isSimpleSlice:ft,begin:Y.begin,end:Y.end,strides:Y.strides}}function N(W,k,T,_,r,y){if(r[k])return T>0?y[k]:y[k+1&1];{const x=W<0?_+W:W;return x<y[0]?y[0]:x>y[1]?y[1]:x}}},2187:(Q,v,t)=>{"use strict";t.d(v,{X:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({softmax_:function p(d,o=-1){const n=(0,f._1)(d,"logits","softmax","float32");if(-1===o&&(o=n.rank-1),o!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${o}`);return e.BV.runKernel(D.Gcp,{logits:n},{dim:o})}})},7246:(Q,v,t)=>{"use strict";t.d(v,{W:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({softplus_:function p(d){const n={x:(0,f._1)(d,"x","softplus")};return e.BV.runKernel(D.MRv,n)}})},1705:(Q,v,t)=>{"use strict";t.d(v,{f:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({spaceToBatchND_:function h(o,n,a){const c=(0,f._1)(o,"x","spaceToBatchND");return m.hu(c.rank>=1+n.length,()=>`input rank ${c.rank} should be > than [blockShape] ${n.length}`),m.hu(a.length===n.length,()=>`paddings.shape[0] ${a.length} must be equal to [blockShape] ${n.length}`),m.hu(c.shape.reduce((C,I,S)=>S>0&&S<=n.length?C&&(I+a[S-1][0]+a[S-1][1])%n[S-1]==0:C,!0),()=>`input spatial dimensions ${c.shape.slice(1)} with paddings ${a.toString()} must be divisible by blockShapes ${n.toString()}`),e.BV.runKernel(D.TQc,{x:c},{blockShape:n,paddings:a})}})},5008:(Q,v,t)=>{"use strict";t.d(v,{k:()=>h});var e=t(2882),D=t(6338),f=t(62);const h=(0,t(5948).op)({fft_:function p(d){return(0,f.hu)("complex64"===d.dtype,()=>`The dtype for tf.spectral.fft() must be complex64 but got ${d.dtype}.`),e.BV.runKernel(D.vwp,{input:d})}})},1132:(Q,v,t)=>{"use strict";t.d(v,{S:()=>h});var e=t(2882),D=t(6338),f=t(62);const h=(0,t(5948).op)({ifft_:function p(d){return(0,f.hu)("complex64"===d.dtype,()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${d.dtype}.`),e.BV.runKernel(D.Qg5,{input:d})}})},3176:(Q,v,t)=>{"use strict";t.d(v,{w:()=>g});var e=t(7401),D=t(4664),f=t(6308),m=t(1300),p=t(5948),h=t(6656),d=t(3626),o=t(7661),n=t(8153),a=t(8577),c=t(1132);const g=(0,p.op)({irfft_:function i(C){const I=C.shape[C.shape.length-1],S=C.size/I;let K;if(I<=2){const z=(0,d.X)(C,[S,I]);K=(0,c.S)(z)}else{const z=[S,2*(I-1)],H=(0,d.X)((0,h.k)(C),[S,I]),ct=(0,d.X)((0,f.a)(C),[S,I]),N=(0,o.G)((0,a.t)(H,[0,1],[S,I-2]),1),W=(0,m.d)((0,o.G)((0,a.t)(ct,[0,1],[S,I-2]),1),(0,n.i)(-1)),k=(0,D.z)([H,N],1),T=(0,D.z)([ct,W],1),_=(0,d.X)((0,e.P)(k,T),[z[0],z[1]]);K=(0,c.S)(_)}if(K=(0,h.k)(K),3===C.rank&&0!==C.shape[0]){const z=K,H=C.shape[0];K=(0,d.X)(K,[H,K.shape[0]/H,K.shape[1]]),z.dispose()}return K}})},4636:(Q,v,t)=>{"use strict";t.d(v,{Q:()=>C});var e=t(62),D=t(7401),f=t(4664),m=t(6308),p=t(5948),h=t(6656),d=t(3626),o=t(8577),n=t(633),a=t(7799),c=t(9314),i=t(5008);const C=(0,p.op)({rfft_:function g(I,S){(0,e.hu)("float32"===I.dtype,()=>`The dtype for rfft() must be real value but got ${I.dtype}`);let K=I.shape[I.shape.length-1];const z=I.size/K;let H;if(null!=S&&S<K){const w=I.shape.map(et=>0),V=I.shape.map(et=>et);V[I.shape.length-1]=S,H=(0,o.t)(I,w,V),K=S}else if(null!=S&&S>K){const w=I.shape.map(V=>V);w[I.shape.length-1]=S-K,H=(0,f.z)([I,(0,a.l)(w)],I.shape.length-1),K=S}else H=I;const ct=(0,c.P)(H),N=(0,d.X)((0,D.P)(H,ct),[z,K]),W=(0,i.k)(N),k=Math.floor(K/2)+1,T=(0,h.k)(W),_=(0,m.a)(W),r=(0,n.V)(T,[k,K-k],T.shape.length-1),y=(0,n.V)(_,[k,K-k],_.shape.length-1),x=H.shape.slice();return x[H.shape.length-1]=k,(0,d.X)((0,D.P)(r[0],y[0]),x)}})},633:(Q,v,t)=>{"use strict";t.d(v,{V:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({split_:function p(d,o,n=0){const c={x:(0,f._1)(d,"x","split")};return e.BV.runKernel(D.L8s,c,{numOrSizeSplits:o,axis:n})}})},6900:(Q,v,t)=>{"use strict";t.d(v,{_:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({sqrt_:function p(d){const n={x:(0,f._1)(d,"x","sqrt","float32")};return e.BV.runKernel(D.FKq,n)}})},4463:(Q,v,t)=>{"use strict";t.d(v,{h:()=>p});var e=t(2882),D=t(4810);const p=(0,t(5948).op)({square_:function m(h){const d=(0,D._1)(h,"x","square");return e.BV.runKernel("Square",{x:d},{})}})},3629:(Q,v,t)=>{"use strict";t.d(v,{$:()=>o});var e=t(2882),D=t(6338),f=t(7073),m=t(4810),p=t(3469);const o=(0,t(5948).op)({squaredDifference_:function d(n,a){let c=(0,m._1)(n,"a","squaredDifference"),i=(0,m._1)(a,"b","squaredDifference");return[c,i]=(0,f.makeTypesMatch)(c,i),(0,p.assertAndGetBroadcastShape)(c.shape,i.shape),e.BV.runKernel(D._tC,{a:c,b:i},{})}})},6458:(Q,v,t)=>{"use strict";t.d(v,{L:()=>h});var e=t(4810),D=t(62),f=t(5948),m=t(3626);const h=(0,f.op)({squeeze_:function p(d,o){const n=(0,e._1)(d,"x","squeeze","string_or_numeric");return(0,m.X)(n,(0,D.bp)(n.shape,o).newShape)}})},1440:(Q,v,t)=>{"use strict";t.d(v,{k:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({stack_:function h(o,n=0){const a=(0,f.sI)(o,"tensors","stack","string_or_numeric");return m.hu(a.length>=1,()=>"Pass at least one tensor to tf.stack"),a.length>0&&m.hu(n<=a[0].rank,()=>"Axis must be <= rank of the tensor"),e.BV.runKernel(D.QiL,a,{axis:n})}})},4429:(Q,v,t)=>{"use strict";t.d(v,{N:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({step_:function p(d,o=0){const a={x:(0,f._1)(d,"x","step")};return e.BV.runKernel(D.h8e,a,{alpha:o})}})},92:(Q,v,t)=>{"use strict";t.d(v,{N:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({stridedSlice_:function p(d,o,n,a,c=0,i=0,g=0,C=0,I=0){const K={x:(0,f._1)(d,"x","stridedSlice","string_or_numeric")};return e.BV.runKernel(D.jQk,K,{begin:o,end:n,strides:a,beginMask:c,endMask:i,ellipsisMask:g,newAxisMask:C,shrinkAxisMask:I})}})},3217:(Q,v,t)=>{"use strict";t.d(v,{l:()=>d});var e=t(2882),D=t(6338),f=t(7073),m=t(4810);const d=(0,t(5948).op)({sub_:function h(o,n){let a=(0,m._1)(o,"a","sub"),c=(0,m._1)(n,"b","sub");return[a,c]=(0,f.makeTypesMatch)(a,c),e.BV.runKernel(D.Tr8,{a,b:c})}})},7782:(Q,v,t)=>{"use strict";t.d(v,{S:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(4879);const d=(0,t(5948).op)({sum_:function h(o,n=null,a=!1){let c=(0,f._1)(o,"x","sum");return"bool"===c.dtype&&(c=(0,m.p)(c,"int32")),e.BV.runKernel(D.GBy,{x:c},{axis:n,keepDims:a})}})},3992:(Q,v,t)=>{"use strict";t.d(v,{O:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({tan_:function p(d){const n={x:(0,f._1)(d,"x","tan","float32")};return e.BV.runKernel(D.sEM,n)}})},8892:(Q,v,t)=>{"use strict";t.d(v,{A:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({tanh_:function p(d){const n={x:(0,f._1)(d,"x","tanh","float32")};return e.BV.runKernel(D.MIZ,n)}})},5186:(Q,v,t)=>{"use strict";t.d(v,{X:()=>f});var e=t(4810),D=t(299);function f(m,p,h){const d=(0,e.C)(m,h);return(0,D.H)(m,p,d,h)}},3221:(Q,v,t)=>{"use strict";t.d(v,{w:()=>m});var e=t(4810),D=t(62),f=t(299);function m(p,h,d){if((0,D.Cq)(p),null!=h&&3!==h.length)throw new Error("tensor3d() requires shape to have three numbers");const o=(0,e.C)(p,d);if(3!==o.length&&1!==o.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===o.length&&null==h)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return(0,f.H)(p,h,o,d)}},299:(Q,v,t)=>{"use strict";t.d(v,{H:()=>p});var e=t(2882),D=t(6209),f=t(62),m=t(1530);function p(h,d,o,n){if(null==n)n=(0,f.D2)(h);else if("complex64"===n)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if((0,D.$F)(h)||(0,D.Oq)(h)){if("float32"!==n&&"int32"!==n)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return e.BV.backend.createTensorFromGPUData(h,d||o,n)}if(!(0,m.isTypedArray)(h)&&!Array.isArray(h)&&"number"!=typeof h&&"boolean"!=typeof h&&"string"!=typeof h)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=d){(0,f.Mu)(d);const a=(0,f.NA)(d),c=(0,f.NA)(o);(0,f.hu)(a===c,()=>`Based on the provided shape, [${d}], the tensor should have ${a} values but has ${c}`);for(let i=0;i<o.length;++i){const C=i!==o.length-1||o[i]!==(0,f.NA)(d.slice(i));(0,f.hu)(o[i]===d[i]||!C,()=>`Error creating a new Tensor. Inferred shape (${o}) does not match the provided shape (${d}). `)}}return!(0,m.isTypedArray)(h)&&!Array.isArray(h)&&(h=[h]),d=d||o,h="string"!==n?(0,m.toTypedArray)(h,n):(0,m.flatten)(h,[],!0),e.BV.makeTensor(h,d,n)}},3063:(Q,v,t)=>{"use strict";t.d(v,{G:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({tile_:function h(o,n){const a=(0,f._1)(o,"x","tile","string_or_numeric");return m.hu(a.rank===n.length,()=>`Error in transpose: rank of input ${a.rank} must match length of reps ${n}.`),e.BV.runKernel(D.n9L,{x:a},{reps:n})}})},3187:(Q,v,t)=>{"use strict";t.d(v,{h:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({topk_:function p(d,o=1,n=!0){const a=(0,f._1)(d,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const c=a.shape[a.shape.length-1];if(o<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${o}`);if(o>c)throw new Error(`'k' passed to topk() must be <= the last dimension (${c}) but got ${o}`);const i={x:a},g={k:o,sorted:n},[C,I]=e.BV.runKernel(D.cWu,i,g);return{values:C,indices:I}}})},3111:(Q,v,t)=>{"use strict";t.d(v,{p:()=>i});var e=t(2882),D=t(2133),f=t(6338),m=t(4810),p=t(62),h=t(7401),d=t(6308),o=t(181),n=t(5948),a=t(6656);const i=(0,n.op)({transpose_:function c(g,C,I){const S=(0,m._1)(g,"x","transpose");if(null==C&&(C=S.shape.map((H,ct)=>ct).reverse()),p.hu(S.rank===C.length,()=>`Error in transpose: rank of input ${S.rank} must match length of perm ${C}.`),C.forEach(H=>{p.hu(H>=0&&H<S.rank,()=>`All entries in 'perm' must be between 0 and ${S.rank-1} but got ${C}`)}),S.rank<=1)return S.clone();const K={x:S},z={perm:C};return"complex64"===S.dtype?(0,D.lu)(()=>{let H=(0,a.k)(S),ct=(0,d.a)(S);return H=e.BV.runKernel(f.G3Y,{x:H},z),ct=e.BV.runKernel(f.G3Y,{x:ct},z),I&&(ct=(0,o.W)(ct)),(0,h.P)(H,ct)}):e.BV.runKernel(f.G3Y,K,z)}})},5403:(Q,v,t)=>{"use strict";t.d(v,{T:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({unique_:function h(o,n=0){const a=(0,f._1)(o,"x","unique","string_or_numeric");(0,m.hu)(a.rank>0,()=>"The input tensor must be at least 1D");const c={x:a},i={axis:n},[g,C]=e.BV.runKernel(D.kpP,c,i);return{values:g,indices:C}}})},6442:(Q,v,t)=>{"use strict";t.d(v,{p:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({unsortedSegmentSum_:function h(o,n,a){const c=(0,f._1)(o,"x","unsortedSegmentSum"),i=(0,f._1)(n,"segmentIds","unsortedSegmentSum","int32");return(0,m.hu)((0,m.GN)(a),()=>"numSegments must be of dtype int"),e.BV.runKernel(D.Qvg,{x:c,segmentIds:i},{numSegments:a})}})},230:(Q,v,t)=>{"use strict";t.d(v,{H:()=>d});var e=t(2882),D=t(6338),f=t(4810),m=t(62);const d=(0,t(5948).op)({unstack_:function h(o,n=0){const a=(0,f._1)(o,"x","unstack","string_or_numeric");return m.hu(n>=-a.shape.length&&n<a.shape.length,()=>`Axis = ${n} is not in [-${a.shape.length}, ${a.shape.length})`),e.BV.runKernel(D.ToN,{value:a},{axis:n})}})},8793:(Q,v,t)=>{"use strict";t.d(v,{a:()=>o});var e=t(2882),D=t(6338),f=t(4810),m=t(6172),p=t(3469);const o=(0,t(5948).op)({where_:function d(n,a,c){const i=(0,f._1)(a,"a","where"),g=(0,f._1)(c,"b","where"),C=(0,f._1)(n,"condition","where","bool"),I=(0,p.assertAndGetBroadcastShape)((0,p.assertAndGetBroadcastShape)(C.shape,i.shape),g.shape),S=(0,m.U)(C,I),K=(0,m.U)(i,I),z=(0,m.U)(g,I);return e.BV.runKernel(D.PhF,{condition:S,t:K,e:z})}})},7799:(Q,v,t)=>{"use strict";t.d(v,{l:()=>m});var e=t(2882),D=t(62),f=t(7401);function m(p,h="float32"){if((0,D.Mu)(p),"complex64"===h){const o=m(p,"float32"),n=m(p,"float32");return(0,f.P)(o,n)}const d=(0,D.wT)((0,D.NA)(p),h);return e.BV.makeTensor(d,p,h)}},9314:(Q,v,t)=>{"use strict";t.d(v,{P:()=>h});var e=t(2882),D=t(6338),f=t(4810);const h=(0,t(5948).op)({zerosLike_:function p(d){const n={x:(0,f._1)(d,"x","zerosLike")};return e.BV.runKernel(D.RuY,n)}})},7517:(Q,v,t)=>{"use strict";function e(D){return D instanceof Float32Array||D instanceof Int32Array||D instanceof Uint8Array||D instanceof Uint8ClampedArray}t.d(v,{j:()=>e})},8106:(Q,v,t)=>{"use strict";t.d(v,{es:()=>N,YD:()=>C,_w:()=>k,t3:()=>W,FZ:()=>ct,Vp:()=>H,Vi:()=>z});var e=t(8239),D=t(3860),f=t(62);const m=20,p=3,h=7;function d(T,_,r,y){const x=(0,f.e3)(_),w=function o(T,_,r,y){const x=(0,f.NA)(_),w=y[y.length-1],V=new Array(w).fill(0),et=_.length,U="complex64"===r?i(T):T;if(et>1)for(let F=0;F<x/w;F++){const Y=F*w;for(let tt=0;tt<w;tt++)V[tt]=Math.max(V[tt],n(U[Y+tt],0,r).length)}return V}(T,_,r,x),V=_.length,et=c(T,_,r,x,w),U=["Tensor"];return y&&(U.push(`  dtype: ${r}`),U.push(`  rank: ${V}`),U.push(`  shape: [${_}]`),U.push("  values:")),U.push(et.map(F=>"    "+F).join("\n")),U.join("\n")}function n(T,_,r){let y;return y=Array.isArray(T)?`${parseFloat(T[0].toFixed(h))} + ${parseFloat(T[1].toFixed(h))}j`:(0,f.HD)(T)?`'${T}'`:"bool"===r?a(T):parseFloat(T.toFixed(h)).toString(),(0,f.oj)(y,_)}function a(T){return 0===T?"false":"true"}function c(T,_,r,y,x,w=!0){const V="complex64"===r?2:1,et=_[0],U=_.length;if(0===U)return"complex64"===r?[n(i(T)[0],0,r)]:"bool"===r?[a(T[0])]:[T[0].toString()];if(1===U){if(et>m){let Et=Array.from(T.slice(0,p*V)),Ct=Array.from(T.slice((et-p)*V,et*V));return"complex64"===r&&(Et=i(Et),Ct=i(Ct)),["["+Et.map((At,Ft)=>n(At,x[Ft],r)).join(", ")+", ..., "+Ct.map((At,Ft)=>n(At,x[et-p+Ft],r)).join(", ")+"]"]}return["["+("complex64"===r?i(T):Array.from(T)).map((Pt,Et)=>n(Pt,x[Et],r)).join(", ")+"]"]}const F=_.slice(1),Y=y.slice(1),tt=y[0]*V,ot=[];if(et>m){for(let pt=0;pt<p;pt++){const Pt=pt*tt;ot.push(...c(T.slice(Pt,Pt+tt),F,r,Y,x,!1))}ot.push("...");for(let pt=et-p;pt<et;pt++){const Pt=pt*tt;ot.push(...c(T.slice(Pt,Pt+tt),F,r,Y,x,pt===et-1))}}else for(let pt=0;pt<et;pt++){const Pt=pt*tt;ot.push(...c(T.slice(Pt,Pt+tt),F,r,Y,x,pt===et-1))}const ft=2===U?",":"";ot[0]="["+(et>0?ot[0]+ft:"");for(let pt=1;pt<ot.length-1;pt++)ot[pt]=" "+ot[pt]+ft;let gt=",\n";for(let pt=2;pt<U;pt++)gt+="\n";return ot[ot.length-1]=" "+ot[ot.length-1]+"]"+(w?"":gt),ot}function i(T){const _=[];for(let r=0;r<T.length;r+=2)_.push([T[r],T[r+1]]);return _}var g=t(1530);class C{constructor(_,r,y){if(this.dtype=r,this.shape=_.slice(),this.size=f.NA(_),null!=y){const x=y.length;f.hu(x===this.size,()=>`Length of values '${x}' does not match the size inferred by the shape '${this.size}'.`)}if("complex64"===r)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=y||f.rQ(r,this.size),this.strides=(0,f.e3)(_)}set(_,...r){0===r.length&&(r=[0]),f.hu(r.length===this.rank,()=>`The number of provided coordinates (${r.length}) must match the rank (${this.rank})`);const y=this.locToIndex(r);this.values[y]=_}get(..._){0===_.length&&(_=[0]);let r=0;for(const x of _){if(x<0||x>=this.shape[r])throw new Error(`Requested out of range element at ${_}.   Buffer shape=${this.shape}`);r++}let y=_[_.length-1];for(let x=0;x<_.length-1;++x)y+=this.strides[x]*_[x];return this.values[y]}locToIndex(_){if(0===this.rank)return 0;if(1===this.rank)return _[0];let r=_[_.length-1];for(let y=0;y<_.length-1;++y)r+=this.strides[y]*_[y];return r}indexToLoc(_){if(0===this.rank)return[];if(1===this.rank)return[_];const r=new Array(this.shape.length);for(let y=0;y<r.length-1;++y)r[y]=Math.floor(_/this.strides[y]),_-=r[y]*this.strides[y];return r[r.length-1]=_,r}get rank(){return this.shape.length}toTensor(){return I().makeTensor(this.values,this.shape,this.dtype)}}let I=null,S=null,K=null;function z(T){I=T}function H(T){S=T}function ct(T){K=T}class N{constructor(_,r,y,x){this.kept=!1,this.isDisposedInternal=!1,this.shape=_.slice(),this.dtype=r||"float32",this.size=f.NA(_),this.strides=(0,f.e3)(_),this.dataId=y,this.id=x,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}buffer(){var _=this;return(0,e.Z)(function*(){const r=yield _.data();return S.buffer(_.shape,_.dtype,r)})()}bufferSync(){return S.buffer(this.shape,this.dtype,this.dataSync())}array(){var _=this;return(0,e.Z)(function*(){const r=yield _.data();return(0,f.GX)(_.shape,r,"complex64"===_.dtype)})()}arraySync(){return(0,f.GX)(this.shape,this.dataSync(),"complex64"===this.dtype)}data(){var _=this;return(0,e.Z)(function*(){_.throwIfDisposed();const r=I().read(_.dataId);if("string"===_.dtype){const y=yield r;try{return y.map(x=>g.decodeString(x))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return r})()}dataToGPU(_){return this.throwIfDisposed(),I().readToGPU(this.dataId,_)}dataSync(){this.throwIfDisposed();const _=I().readSync(this.dataId);if("string"===this.dtype)try{return _.map(r=>g.decodeString(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return _}bytes(){var _=this;return(0,e.Z)(function*(){_.throwIfDisposed();const r=yield I().read(_.dataId);return"string"===_.dtype?r:new Uint8Array(r.buffer)})()}dispose(){this.isDisposed||(I().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(_=!1){return S.print(this,_)}clone(){return this.throwIfDisposed(),S.clone(this)}toString(_=!1){return d(this.dataSync(),this.shape,this.dtype,_)}cast(_){return this.throwIfDisposed(),S.cast(this,_)}variable(_=!0,r,y){return this.throwIfDisposed(),I().makeVariable(this,_,r,y)}}function W(){return(0,D.R)("Tensor",()=>N)}Object.defineProperty(N,Symbol.hasInstance,{value:T=>!!T&&null!=T.data&&null!=T.dataSync&&null!=T.throwIfDisposed}),W();class k extends N{constructor(_,r,y,x){super(_.shape,_.dtype,_.dataId,x),this.trainable=r,this.name=y}assign(_){if(_.dtype!==this.dtype)throw new Error(`dtype of the new value (${_.dtype}) and previous value (${this.dtype}) must match`);if(!f.cO(_.shape,this.shape))throw new Error(`shape of the new value (${_.shape}) and previous value (${this.shape}) must match`);I().disposeTensor(this),this.dataId=_.dataId,I().incRef(this,null)}dispose(){I().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(k,Symbol.hasInstance,{value:T=>T instanceof N&&null!=T.assign&&T.assign instanceof Function})},7073:(Q,v,t)=>{"use strict";t.r(v),t.d(v,{assertTypesMatch:()=>p,getTensorsInContainer:()=>d,isTensorInList:()=>h,makeTypesMatch:()=>m});var e=t(8106),D=t(6209),f=t(62);function m(a,c){if(a.dtype===c.dtype)return[a,c];const i=(0,D.x8)(a.dtype,c.dtype);return[a.cast(i),c.cast(i)]}function p(a,c){(0,f.hu)(a.dtype===c.dtype,()=>`The dtypes of the first(${a.dtype}) and second(${c.dtype}) input must match`)}function h(a,c){return c.some(i=>i.id===a.id)}function d(a){const c=[];return o(a,c,new Set),c}function o(a,c,i){if(null==a)return;if(a instanceof e.es)return void c.push(a);if(!function n(a){return Array.isArray(a)||"object"==typeof a}(a))return;const g=a;for(const C in g){const I=g[C];i.has(I)||(i.add(I),o(I,c,i))}}},4810:(Q,v,t)=>{"use strict";t.d(v,{C:()=>d,_1:()=>a,sI:()=>c});var e=t(2882),D=t(2433),f=t(8106),m=t(6209),p=t(1530),h=t(62);function d(i,g){let C=i;if((0,p.isTypedArray)(i))return"string"===g?[]:[i.length];if((0,m.Oq)(i))return[i.height,i.width*(i.channels||"RGBA").length];if((0,m.$F)(i))return[i.buffer.size/(null==g?4:(0,h.bT)(g))];if(!Array.isArray(i))return[];const I=[];for(;Array.isArray(C)||(0,p.isTypedArray)(C)&&"string"!==g;)I.push(C.length),C=C[0];return Array.isArray(i)&&(0,D.OB)().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&o(i,I,[]),I}function o(i,g,C){if(C=C||[],!Array.isArray(i)&&!(0,p.isTypedArray)(i))return void(0,h.hu)(0===g.length,()=>`Element arr[${C.join("][")}] is a primitive, but should be an array/TypedArray of ${g[0]} elements`);(0,h.hu)(g.length>0,()=>`Element arr[${C.join("][")}] should be a primitive, but is an array of ${i.length} elements`),(0,h.hu)(i.length===g[0],()=>`Element arr[${C.join("][")}] should have ${g[0]} elements, but has ${i.length} elements`);const I=g.slice(1);for(let S=0;S<i.length;++S)o(i[S],I,C.concat(S))}function n(i,g,C,I){if("string_or_numeric"!==i){if(null==i)throw new Error("Expected dtype cannot be null.");if("numeric"!==i&&i!==g||"numeric"===i&&"string"===g)throw new Error(`Argument '${C}' passed to '${I}' must be ${i} tensor, but got ${g} tensor`)}}function a(i,g,C,I="numeric"){if(i instanceof f.es)return n(I,i.dtype,g,C),i;let S=(0,h.D2)(i);if("string"!==S&&["bool","int32","float32"].indexOf(I)>=0&&(S=I),n(I,S,g,C),null==i||!(0,p.isTypedArray)(i)&&!Array.isArray(i)&&"number"!=typeof i&&"boolean"!=typeof i&&"string"!=typeof i)throw new Error(`Argument '${g}' passed to '${C}' must be a Tensor or TensorLike, but got '${null==i?"null":i.constructor.name}'`);const K=d(i,S);!(0,p.isTypedArray)(i)&&!Array.isArray(i)&&(i=[i]);const H="string"!==S?(0,p.toTypedArray)(i,S):(0,p.flatten)(i,[],!0);return e.BV.makeTensor(H,K,S)}function c(i,g,C,I="numeric"){if(!Array.isArray(i))throw new Error(`Argument ${g} passed to ${C} must be a \`Tensor[]\` or \`TensorLike[]\``);return i.map((K,z)=>a(K,`${g}[${z}]`,C,I))}},6209:(Q,v,t)=>{"use strict";t.d(v,{$F:()=>a,Oq:()=>n,x8:()=>d,yw:()=>e,z4:()=>o});var e=(()=>((e=e||{}).R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6",e))(),D=(()=>((D=D||{}).float32="float32",D.int32="int32",D.bool="int32",D.complex64="complex64",D))(),f=(()=>((f=f||{}).float32="float32",f.int32="int32",f.bool="bool",f.complex64="complex64",f))(),m=(()=>((m=m||{}).float32="float32",m.int32="float32",m.bool="float32",m.complex64="complex64",m))(),p=(()=>((p=p||{}).float32="complex64",p.int32="complex64",p.bool="complex64",p.complex64="complex64",p))();const h={float32:m,int32:D,bool:f,complex64:p};function d(c,i){if("string"===c||"string"===i){if("string"===c&&"string"===i)return"string";throw new Error(`Can not upcast ${c} with ${i}`)}return h[c][i]}function o(c){return d(c,"int32")}function n(c){return null!=c&&"object"==typeof c&&"texture"in c&&c.texture instanceof WebGLTexture}function a(c){return typeof GPUBuffer<"u"&&null!=c&&"object"==typeof c&&"buffer"in c&&c.buffer instanceof GPUBuffer}},1530:(Q,v,t)=>{"use strict";t.r(v),t.d(v,{arraysEqual:()=>f.cO,arraysEqualWithNull:()=>f.DK,assert:()=>f.hu,assertNonNegativeIntegerDimensions:()=>f.Mu,assertNonNull:()=>f.Cq,assertShapesMatch:()=>f.k5,bytesFromStringArray:()=>f.Ub,bytesPerElement:()=>f.bT,checkConversionForErrors:()=>f.D5,clamp:()=>f.uZ,computeStrides:()=>f.e3,convertBackendValuesAndArrayBuffer:()=>f.KS,createScalarValue:()=>k,createShuffledIndices:()=>f.U$,decodeString:()=>w,distSquared:()=>f.E7,encodeString:()=>x,fetch:()=>y,fingerPrint64:()=>W,flatten:()=>et,getArrayFromDType:()=>f.rQ,getTypedArrayFromDType:()=>f.WP,hasEncodingLoss:()=>f.QB,hexToLong:()=>d,indexToLoc:()=>f.NE,inferDtype:()=>f.D2,inferFromImplicitShape:()=>f.JZ,isBoolean:()=>f.jn,isFunction:()=>f.mf,isInt:()=>f.GN,isNumber:()=>f.hj,isPromise:()=>f.tI,isScalarShape:()=>f.xH,isString:()=>f.HD,isTypedArray:()=>V,isValidDtype:()=>f.LP,locToIndex:()=>f.qy,makeOnesTypedArray:()=>f.p8,makeZerosNestedTypedArray:()=>f.l6,makeZerosTypedArray:()=>f.wT,nearestDivisor:()=>f.jP,nearestLargerEven:()=>f.nY,now:()=>r,parseAxisParam:()=>f.EC,randUniform:()=>f.bj,repeatedTry:()=>f.WD,rightPad:()=>f.oj,shuffle:()=>f.TV,shuffleCombo:()=>f.d7,sizeFromShape:()=>f.NA,sizeToSquarishShape:()=>f.YP,squeezeShape:()=>f.bp,sum:()=>f.Sm,swap:()=>f.LF,tanh:()=>f.AE,toNestedArray:()=>f.GX,toTypedArray:()=>_});var e=t(2433),D=t(7517),f=t(62),m=t(7080);const h=t.n(m)()||m;function d(U){return h.fromString(U,!0,16)}const o=d("c3a5c85c97cb3127"),n=d("b492b66fbe98f273"),a=d("9ae16a3b2f90404f");function c(U){return U.xor(U.shru(47))}function i(U,F,Y){const tt=U.slice(F,F+Y);return h.fromBytes(Array.from(tt),!0,!0)}function g(U,F){return i(U,F,8)}function C(U,F){return i(U,F,4)}function I(U,F){return 0===F?U:U.shru(F).or(U.shl(64-F))}function S(U,F,Y=d("9ddfea08eb382d69")){let tt=U.xor(F).mul(Y);tt=tt.xor(tt.shru(47));let ot=F.xor(tt).mul(Y);return ot=ot.xor(ot.shru(47)),ot=ot.mul(Y),ot}function z(U,F,Y,tt){return function K(U,F,Y,tt,ot,ft){ot=ot.add(U),ft=I(ft.add(ot).add(tt),21);const gt=ot;return ot=(ot=ot.add(F)).add(Y),ft=ft.add(I(ot,44)),[ot.add(tt),ft.add(gt)]}(g(U,F),g(U,F+8),g(U,F+16),g(U,F+24),Y,tt)}function W(U,F=U.length){const Y=h.fromNumber(81,!0);if(F<=32)return F<=16?function H(U,F=U.length){if(F>=8){const Y=a.add(2*F),tt=g(U,0).add(a),ot=g(U,F-8);return S(I(ot,37).mul(Y).add(tt),I(tt,25).add(ot).mul(Y),Y)}if(F>=4){const Y=a.add(2*F);return S(C(U,0).shl(3).add(F),C(U,F-4),Y)}if(F>0){const gt=F+(U[F-1]<<2);return c(a.mul(U[0]+(U[F>>1]<<8)).xor(o.mul(gt))).mul(a)}return a}(U,F):function ct(U,F=U.length){const Y=a.add(2*F),tt=g(U,0).mul(n),ot=g(U,8),ft=g(U,F-8).mul(Y),gt=g(U,F-16).mul(a);return S(I(tt.add(ot),43).add(I(ft,30)).add(gt),tt.add(I(ot.add(a),18)).add(ft),Y)}(U,F);if(F<=64)return function N(U,F=U.length){const Y=a.add(2*F),tt=g(U,0).mul(a),ot=g(U,8),ft=g(U,F-8).mul(Y),gt=g(U,F-16).mul(a),pt=I(tt.add(ot),43).add(I(ft,30)).add(gt),Pt=S(pt,tt.add(I(ot.add(a),18)).add(ft),Y),Et=g(U,16).mul(Y),Ct=g(U,24),At=pt.add(g(U,F-32)).mul(Y),Ft=Pt.add(g(U,F-24)).mul(Y);return S(I(Et.add(Ct),43).add(I(At,30)).add(Ft),Et.add(I(Ct.add(tt),18)).add(At),Y)}(U,F);let tt=Y,ot=Y.mul(n).add(113),ft=c(ot.mul(a).add(113)).mul(a),gt=[h.UZERO,h.UZERO],pt=[h.UZERO,h.UZERO];tt=tt.mul(a).add(g(U,0));let Pt=0;const Et=64*(F-1>>6),Ct=Et+(F-1&63)-63;do{tt=I(tt.add(ot).add(gt[0]).add(g(U,Pt+8)),37).mul(n),ot=I(ot.add(gt[1]).add(g(U,Pt+48)),42).mul(n),tt=tt.xor(pt[1]),ot=ot.add(gt[0]).add(g(U,Pt+40)),ft=I(ft.add(pt[0]),33).mul(n),gt=z(U,Pt,gt[1].mul(n),tt.add(pt[0])),pt=z(U,Pt+32,ft.add(pt[1]),ot.add(g(U,Pt+16))),[ft,tt]=[tt,ft],Pt+=64}while(Pt!==Et);const At=n.add(ft.and(255).shl(1));return Pt=Ct,pt[0]=pt[0].add(F-1&63),gt[0]=gt[0].add(pt[0]),pt[0]=pt[0].add(gt[0]),tt=I(tt.add(ot).add(gt[0]).add(g(U,Pt+8)),37).mul(At),ot=I(ot.add(gt[1]).add(g(U,Pt+48)),42).mul(At),tt=tt.xor(pt[1].mul(9)),ot=ot.add(gt[0].mul(9).add(g(U,Pt+40))),ft=I(ft.add(pt[0]),33).mul(At),gt=z(U,Pt,gt[1].mul(At),tt.add(pt[0])),pt=z(U,Pt+32,ft.add(pt[1]),ot.add(g(U,Pt+16))),[ft,tt]=[tt,ft],S(S(gt[0],pt[0],At).add(c(ot).mul(o)).add(ft),S(gt[1],pt[1],At).add(tt),At)}function k(U,F){return"string"===F?x(U):_([U],F)}function _(U,F){if("string"===F)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(U)&&(U=et(U)),(0,e.OB)().getBool("DEBUG")&&f.D5(U,F),function T(U,F){return U instanceof Float32Array&&"float32"===F||U instanceof Int32Array&&"int32"===F||U instanceof Uint8Array&&"bool"===F}(U,F))return U;if(null==F||"float32"===F||"complex64"===F)return new Float32Array(U);if("int32"===F)return new Int32Array(U);if("bool"===F){const Y=new Uint8Array(U.length);for(let tt=0;tt<Y.length;++tt)0!==Math.round(U[tt])&&(Y[tt]=1);return Y}throw new Error(`Unknown data type ${F}`)}function r(){return(0,e.OB)().platform.now()}function y(U,F){return(0,e.OB)().platform.fetch(U,F)}function x(U,F="utf-8"){return F=F||"utf-8",(0,e.OB)().platform.encode(U,F)}function w(U,F="utf-8"){return F=F||"utf-8",(0,e.OB)().platform.decode(U,F)}function V(U){return null!=(0,e.OB)().platform.isTypedArray?(0,e.OB)().platform.isTypedArray(U):(0,D.j)(U)}function et(U,F=[],Y=!1){if(null==F&&(F=[]),"boolean"==typeof U||"number"==typeof U||"string"==typeof U||f.tI(U)||null==U||V(U)&&Y)F.push(U);else if(Array.isArray(U)||V(U))for(let tt=0;tt<U.length;++tt)et(U[tt],F,Y);else{let tt=-1;for(const ot of Object.keys(U))/^([1-9]+[0-9]*|0)$/.test(ot)&&(tt=Math.max(tt,Number(ot)));for(let ot=0;ot<=tt;ot++)et(U[ot],F,Y)}return F}},62:(Q,v,t)=>{"use strict";function e(G){let st=G.length,it=0;for(;st>0;)it=Math.random()*st|0,st--,p(G,st,it)}function D(G,st){if(G.length!==st.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${G.length}Second array length was ${st.length}`);let it=G.length,_t=0;for(;it>0;)_t=Math.random()*it|0,it--,p(G,it,_t),p(st,it,_t)}function f(G,st,it){return Math.max(G,Math.min(st,it))}function m(G){return G%2==0?G:G+1}function p(G,st,it){const _t=G[st];G[st]=G[it],G[it]=_t}function h(G){let st=0;for(let it=0;it<G.length;it++)st+=G[it];return st}function d(G,st){const it=Math.random();return st*it+(1-it)*G}function o(G,st){let it=0;for(let _t=0;_t<G.length;_t++){const Bt=Number(G[_t])-Number(st[_t]);it+=Bt*Bt}return it}function n(G,st){if(!G)throw new Error("string"==typeof st?st:st())}function a(G,st,it=""){n(I(G,st),()=>it+` Shapes ${G} and ${st} must match`)}function c(G){n(null!=G,()=>"The input to the tensor constructor must be a non-null value.")}function i(G){if(0===G.length)return 1;let st=G[0];for(let it=1;it<G.length;it++)st*=G[it];return st}function g(G){return 0===G.length}function C(G,st){if(G===st)return!0;if(null==G||null==st||G.length!==st.length)return!1;for(let it=0;it<G.length;it++)if(null!==G[it]&&null!==st[it]&&G[it]!==st[it])return!1;return!0}function I(G,st){if(G===st)return!0;if(null==G||null==st||G.length!==st.length)return!1;for(let it=0;it<G.length;it++)if(G[it]!==st[it])return!1;return!0}function S(G){return G%1==0}function K(G){if(null!=Math.tanh)return Math.tanh(G);if(G===1/0)return 1;if(G===-1/0)return-1;{const st=Math.exp(2*G);return(st-1)/(st+1)}}function z(G){const st=Math.ceil(Math.sqrt(G));return[st,Math.ceil(G/st)]}function H(G){const st=new Uint32Array(G);for(let it=0;it<G;++it)st[it]=it;return e(st),st}function ct(G,st){return st<=G.length?G:G+" ".repeat(st-G.length)}function N(G,st=(Bt=>0),it,_t){return new Promise((Bt,wt)=>{let Gt=0;const Vt=()=>{if(G())return void Bt();Gt++;const rn=st(Gt);null!=it&&Gt>=it?wt():null!=_t?_t(Vt,rn):setTimeout(Vt,rn)};Vt()})}function W(G,st){let it=1,_t=-1;for(let wt=0;wt<G.length;++wt)if(G[wt]>=0)it*=G[wt];else if(-1===G[wt]){if(-1!==_t)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${_t} and dim ${wt}`);_t=wt}else if(G[wt]<0)throw Error(`Shapes can not be < 0. Found ${G[wt]} at dim ${wt}`);if(-1===_t){if(st>0&&st!==it)throw Error(`Size(${st}) must match the product of shape ${G}`);return G}if(0===it)throw Error(`Cannot infer the missing size in [${G}] when there are 0 elements`);if(st%it!=0)throw Error(`The implicit shape can't be a fractional number. Got ${st} / ${it}`);const Bt=G.slice();return Bt[_t]=st/it,Bt}function k(G,st){const it=st.length;return n((G=null==G?st.map((_t,Bt)=>Bt):[].concat(G)).every(_t=>_t>=-it&&_t<it),()=>`All values in axis param must be in range [-${it}, ${it}) but got axis ${G}`),n(G.every(_t=>S(_t)),()=>`All values in axis param must be integers but got axis ${G}`),G.map(_t=>_t<0?it+_t:_t)}function T(G,st){const it=[],_t=[],Bt=null!=st&&Array.isArray(st)&&0===st.length,wt=null==st||Bt?null:k(st,G).sort();let Gt=0;for(let Vt=0;Vt<G.length;++Vt){if(null!=wt){if(wt[Gt]===Vt&&1!==G[Vt])throw new Error(`Can't squeeze axis ${Vt} since its dim '${G[Vt]}' is not 1`);(null==wt[Gt]||wt[Gt]>Vt)&&1===G[Vt]&&(it.push(G[Vt]),_t.push(Vt)),wt[Gt]<=Vt&&Gt++}1!==G[Vt]&&(it.push(G[Vt]),_t.push(Vt))}return{newShape:it,keptDims:_t}}function _(G,st){return r(G,st)}function r(G,st){let it=null;if(null==G||"float32"===G)it=new Float32Array(st);else if("int32"===G)it=new Int32Array(st);else if("bool"===G)it=new Uint8Array(st);else{if("string"!==G)throw new Error(`Unknown data type ${G}`);it=new Array(st)}return it}function y(G,st){for(let it=0;it<G.length;it++){const _t=G[it];if(isNaN(_t)||!isFinite(_t))throw Error(`A tensor of type ${st} being uploaded contains ${_t}.`)}}function x(G){return"bool"===G||"complex64"===G||"float32"===G||"int32"===G||"string"===G}function w(G,st){return!("complex64"===st||"float32"===st&&"complex64"!==G||"int32"===st&&"float32"!==G&&"complex64"!==G||"bool"===st&&"bool"===G)}function V(G){if("float32"===G||"int32"===G)return 4;if("complex64"===G)return 8;if("bool"===G)return 1;throw new Error(`Unknown dtype ${G}`)}function et(G){if(null==G)return 0;let st=0;return G.forEach(it=>st+=it.length),st}function U(G){return"string"==typeof G||G instanceof String}function F(G){return"boolean"==typeof G}function Y(G){return"number"==typeof G}function tt(G){return Array.isArray(G)?tt(G[0]):G instanceof Float32Array?"float32":G instanceof Int32Array||G instanceof Uint8Array||G instanceof Uint8ClampedArray?"int32":Y(G)?"float32":U(G)?"string":F(G)?"bool":"float32"}function ot(G){return!!(G&&G.constructor&&G.call&&G.apply)}function ft(G,st){for(let it=st;it<G;++it)if(G%it==0)return it;return G}function gt(G){const st=G.length;if(st<2)return[];const it=new Array(st-1);it[st-2]=G[st-1];for(let _t=st-3;_t>=0;--_t)it[_t]=it[_t+1]*G[_t+1];return it}function pt(G,st,it,_t=!1){const Bt=new Array;if(1===st.length){const wt=st[0]*(_t?2:1);for(let Gt=0;Gt<wt;Gt++)Bt[Gt]=it[G+Gt]}else{const wt=st[0],Gt=st.slice(1),Vt=Gt.reduce((rn,Tn)=>rn*Tn)*(_t?2:1);for(let rn=0;rn<wt;rn++)Bt[rn]=pt(G+rn*Vt,Gt,it,_t)}return Bt}function Pt(G,st,it=!1){if(0===G.length)return st[0];const _t=G.reduce((Bt,wt)=>Bt*wt)*(it?2:1);if(0===_t)return[];if(_t!==st.length)throw new Error(`[${G}] does not match the input size ${st.length}${it?" for a complex tensor":""}.`);return pt(0,G,st,it)}function Et(G,st){if(Array.isArray(G))return G;if("float32"===st)return G instanceof Float32Array?G:new Float32Array(G);if("int32"===st)return G instanceof Int32Array?G:new Int32Array(G);if("bool"===st||"string"===st)return Uint8Array.from(new Int32Array(G));throw new Error(`Unknown dtype ${st}`)}function Ct(G,st){const it=At(G,st);for(let _t=0;_t<it.length;_t++)it[_t]=1;return it}function At(G,st){if(null==st||"float32"===st||"complex64"===st)return new Float32Array(G);if("int32"===st)return new Int32Array(G);if("bool"===st)return new Uint8Array(G);throw new Error(`Unknown data type ${st}`)}function Ft(G,st){const it=G.reduce((_t,Bt)=>_t*Bt,1);if(null==st||"float32"===st)return Pt(G,new Float32Array(it));if("int32"===st)return Pt(G,new Int32Array(it));if("bool"===st)return Pt(G,new Uint8Array(it));throw new Error(`Unknown data type ${st}`)}function Rt(G){G.forEach(st=>{n(Number.isInteger(st)&&st>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${G}].`)})}function Xt(G,st,it){if(0===st)return 0;if(1===st)return G[0];let _t=G[G.length-1];for(let Bt=0;Bt<G.length-1;++Bt)_t+=it[Bt]*G[Bt];return _t}function en(G,st,it){if(0===st)return[];if(1===st)return[G];const _t=new Array(st);for(let Bt=0;Bt<_t.length-1;++Bt)_t[Bt]=Math.floor(G/it[Bt]),G-=_t[Bt]*it[Bt];return _t[_t.length-1]=G,_t}function ln(G){return G&&G.then&&"function"==typeof G.then}t.d(v,{AE:()=>K,Cq:()=>c,D2:()=>tt,D5:()=>y,DK:()=>C,E7:()=>o,EC:()=>k,GN:()=>S,GX:()=>Pt,HD:()=>U,JZ:()=>W,KS:()=>Et,LF:()=>p,LP:()=>x,Mu:()=>Rt,NA:()=>i,NE:()=>en,QB:()=>w,Sm:()=>h,TV:()=>e,U$:()=>H,Ub:()=>et,WD:()=>N,WP:()=>_,YP:()=>z,bT:()=>V,bj:()=>d,bp:()=>T,cO:()=>I,d7:()=>D,e3:()=>gt,hj:()=>Y,hu:()=>n,jP:()=>ft,jn:()=>F,k5:()=>a,l6:()=>Ft,mf:()=>ot,nY:()=>m,oj:()=>ct,p8:()=>Ct,qy:()=>Xt,rQ:()=>r,tI:()=>ln,uZ:()=>f,wT:()=>At,xH:()=>g})},7080:Q=>{Q.exports=t;var v=null;try{v=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(_,r,y){this.low=0|_,this.high=0|r,this.unsigned=!!y}function e(_){return!0===(_&&_.__isLong__)}Object.defineProperty(t.prototype,"__isLong__",{value:!0}),t.isLong=e;var D={},f={};function m(_,r){var y,x,w;return r?(w=0<=(_>>>=0)&&_<256)&&(x=f[_])?x:(y=h(_,(0|_)<0?-1:0,!0),w&&(f[_]=y),y):(w=-128<=(_|=0)&&_<128)&&(x=D[_])?x:(y=h(_,_<0?-1:0,!1),w&&(D[_]=y),y)}function p(_,r){if(isNaN(_))return r?K:S;if(r){if(_<0)return K;if(_>=g)return W}else{if(_<=-C)return k;if(_+1>=C)return N}return _<0?p(-_,r).neg():h(_%i|0,_/i|0,r)}function h(_,r,y){return new t(_,r,y)}t.fromInt=m,t.fromNumber=p,t.fromBits=h;var d=Math.pow;function o(_,r,y){if(0===_.length)throw Error("empty string");if("NaN"===_||"Infinity"===_||"+Infinity"===_||"-Infinity"===_)return S;if("number"==typeof r?(y=r,r=!1):r=!!r,(y=y||10)<2||36<y)throw RangeError("radix");var x;if((x=_.indexOf("-"))>0)throw Error("interior hyphen");if(0===x)return o(_.substring(1),r,y).neg();for(var w=p(d(y,8)),V=S,et=0;et<_.length;et+=8){var U=Math.min(8,_.length-et),F=parseInt(_.substring(et,et+U),y);if(U<8){var Y=p(d(y,U));V=V.mul(Y).add(p(F))}else V=(V=V.mul(w)).add(p(F))}return V.unsigned=r,V}function n(_,r){return"number"==typeof _?p(_,r):"string"==typeof _?o(_,r):h(_.low,_.high,"boolean"==typeof r?r:_.unsigned)}t.fromString=o,t.fromValue=n;var i=4294967296,g=i*i,C=g/2,I=m(1<<24),S=m(0);t.ZERO=S;var K=m(0,!0);t.UZERO=K;var z=m(1);t.ONE=z;var H=m(1,!0);t.UONE=H;var ct=m(-1);t.NEG_ONE=ct;var N=h(-1,2147483647,!1);t.MAX_VALUE=N;var W=h(-1,-1,!0);t.MAX_UNSIGNED_VALUE=W;var k=h(0,-2147483648,!1);t.MIN_VALUE=k;var T=t.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*i+(this.low>>>0):this.high*i+(this.low>>>0)},T.toString=function(r){if((r=r||10)<2||36<r)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(k)){var y=p(r),x=this.div(y),w=x.mul(y).sub(this);return x.toString(r)+w.toInt().toString(r)}return"-"+this.neg().toString(r)}for(var V=p(d(r,6),this.unsigned),et=this,U="";;){var F=et.div(V),tt=(et.sub(F.mul(V)).toInt()>>>0).toString(r);if((et=F).isZero())return tt+U;for(;tt.length<6;)tt="0"+tt;U=""+tt+U}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(k)?64:this.neg().getNumBitsAbs();for(var r=0!=this.high?this.high:this.low,y=31;y>0&&!(r&1<<y);y--);return 0!=this.high?y+33:y+1},T.isZero=function(){return 0===this.high&&0===this.low},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return 1==(1&this.low)},T.isEven=function(){return 0==(1&this.low)},T.equals=function(r){return e(r)||(r=n(r)),(this.unsigned===r.unsigned||this.high>>>31!=1||r.high>>>31!=1)&&this.high===r.high&&this.low===r.low},T.eq=T.equals,T.notEquals=function(r){return!this.eq(r)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(r){return this.comp(r)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(r){return this.comp(r)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(r){return this.comp(r)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(r){return this.comp(r)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(r){if(e(r)||(r=n(r)),this.eq(r))return 0;var y=this.isNegative(),x=r.isNegative();return y&&!x?-1:!y&&x?1:this.unsigned?r.high>>>0>this.high>>>0||r.high===this.high&&r.low>>>0>this.low>>>0?-1:1:this.sub(r).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(k)?k:this.not().add(z)},T.neg=T.negate,T.add=function(r){e(r)||(r=n(r));var tt=0,ot=0,ft=0,gt=0;return ft+=(gt+=(65535&this.low)+(65535&r.low))>>>16,ot+=(ft+=(this.low>>>16)+(r.low>>>16))>>>16,tt+=(ot+=(65535&this.high)+(65535&r.high))>>>16,tt+=(this.high>>>16)+(r.high>>>16),h((ft&=65535)<<16|(gt&=65535),(tt&=65535)<<16|(ot&=65535),this.unsigned)},T.subtract=function(r){return e(r)||(r=n(r)),this.add(r.neg())},T.sub=T.subtract,T.multiply=function(r){if(this.isZero())return S;if(e(r)||(r=n(r)),v)return h(v.mul(this.low,this.high,r.low,r.high),v.get_high(),this.unsigned);if(r.isZero())return S;if(this.eq(k))return r.isOdd()?k:S;if(r.eq(k))return this.isOdd()?k:S;if(this.isNegative())return r.isNegative()?this.neg().mul(r.neg()):this.neg().mul(r).neg();if(r.isNegative())return this.mul(r.neg()).neg();if(this.lt(I)&&r.lt(I))return p(this.toNumber()*r.toNumber(),this.unsigned);var w=65535&this.high,V=this.low>>>16,et=65535&this.low,F=65535&r.high,Y=r.low>>>16,tt=65535&r.low,ot=0,ft=0,gt=0,pt=0;return gt+=(pt+=et*tt)>>>16,ft+=(gt+=V*tt)>>>16,gt&=65535,ft+=(gt+=et*Y)>>>16,ot+=(ft+=w*tt)>>>16,ft&=65535,ot+=(ft+=V*Y)>>>16,ft&=65535,ot+=(ft+=et*F)>>>16,ot+=(this.high>>>16)*tt+w*Y+V*F+et*(r.high>>>16),h((gt&=65535)<<16|(pt&=65535),(ot&=65535)<<16|(ft&=65535),this.unsigned)},T.mul=T.multiply,T.divide=function(r){if(e(r)||(r=n(r)),r.isZero())throw Error("division by zero");var x,w,V;if(v)return this.unsigned||-2147483648!==this.high||-1!==r.low||-1!==r.high?h((this.unsigned?v.div_u:v.div_s)(this.low,this.high,r.low,r.high),v.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?K:S;if(this.unsigned){if(r.unsigned||(r=r.toUnsigned()),r.gt(this))return K;if(r.gt(this.shru(1)))return H;V=K}else{if(this.eq(k))return r.eq(z)||r.eq(ct)?k:r.eq(k)?z:(x=this.shr(1).div(r).shl(1)).eq(S)?r.isNegative()?z:ct:(w=this.sub(r.mul(x)),V=x.add(w.div(r)));if(r.eq(k))return this.unsigned?K:S;if(this.isNegative())return r.isNegative()?this.neg().div(r.neg()):this.neg().div(r).neg();if(r.isNegative())return this.div(r.neg()).neg();V=S}for(w=this;w.gte(r);){x=Math.max(1,Math.floor(w.toNumber()/r.toNumber()));for(var U=Math.ceil(Math.log(x)/Math.LN2),F=U<=48?1:d(2,U-48),Y=p(x),tt=Y.mul(r);tt.isNegative()||tt.gt(w);)tt=(Y=p(x-=F,this.unsigned)).mul(r);Y.isZero()&&(Y=z),V=V.add(Y),w=w.sub(tt)}return V},T.div=T.divide,T.modulo=function(r){return e(r)||(r=n(r)),v?h((this.unsigned?v.rem_u:v.rem_s)(this.low,this.high,r.low,r.high),v.get_high(),this.unsigned):this.sub(this.div(r).mul(r))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return h(~this.low,~this.high,this.unsigned)},T.and=function(r){return e(r)||(r=n(r)),h(this.low&r.low,this.high&r.high,this.unsigned)},T.or=function(r){return e(r)||(r=n(r)),h(this.low|r.low,this.high|r.high,this.unsigned)},T.xor=function(r){return e(r)||(r=n(r)),h(this.low^r.low,this.high^r.high,this.unsigned)},T.shiftLeft=function(r){return e(r)&&(r=r.toInt()),0==(r&=63)?this:r<32?h(this.low<<r,this.high<<r|this.low>>>32-r,this.unsigned):h(0,this.low<<r-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(r){return e(r)&&(r=r.toInt()),0==(r&=63)?this:r<32?h(this.low>>>r|this.high<<32-r,this.high>>r,this.unsigned):h(this.high>>r-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(r){if(e(r)&&(r=r.toInt()),0==(r&=63))return this;var y=this.high;return r<32?h(this.low>>>r|y<<32-r,y>>>r,this.unsigned):h(32===r?y:y>>>r-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?h(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:h(this.low,this.high,!0)},T.toBytes=function(r){return r?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var r=this.high,y=this.low;return[255&y,y>>>8&255,y>>>16&255,y>>>24,255&r,r>>>8&255,r>>>16&255,r>>>24]},T.toBytesBE=function(){var r=this.high,y=this.low;return[r>>>24,r>>>16&255,r>>>8&255,255&r,y>>>24,y>>>16&255,y>>>8&255,255&y]},t.fromBytes=function(r,y,x){return x?t.fromBytesLE(r,y):t.fromBytesBE(r,y)},t.fromBytesLE=function(r,y){return new t(r[0]|r[1]<<8|r[2]<<16|r[3]<<24,r[4]|r[5]<<8|r[6]<<16|r[7]<<24,y)},t.fromBytesBE=function(r,y){return new t(r[4]<<24|r[5]<<16|r[6]<<8|r[7],r[0]<<24|r[1]<<16|r[2]<<8|r[3],y)}},3291:(Q,v,t)=>{"use strict";t.d(v,{d:()=>p});var e=t(8023);const D={now:()=>(D.delegate||Date).now(),delegate:void 0};class f extends e.x{constructor(d=1/0,o=1/0,n=D){super(),this._bufferSize=d,this._windowTime=o,this._timestampProvider=n,this._buffer=[],this._infiniteTimeWindow=!0,this._infiniteTimeWindow=o===1/0,this._bufferSize=Math.max(1,d),this._windowTime=Math.max(1,o)}next(d){const{isStopped:o,_buffer:n,_infiniteTimeWindow:a,_timestampProvider:c,_windowTime:i}=this;o||(n.push(d),!a&&n.push(c.now()+i)),this._trimBuffer(),super.next(d)}_subscribe(d){this._throwIfClosed(),this._trimBuffer();const o=this._innerSubscribe(d),{_infiniteTimeWindow:n,_buffer:a}=this,c=a.slice();for(let i=0;i<c.length&&!d.closed;i+=n?1:2)d.next(c[i]);return this._checkFinalizedStatuses(d),o}_trimBuffer(){const{_bufferSize:d,_timestampProvider:o,_buffer:n,_infiniteTimeWindow:a}=this,c=(a?1:2)*d;if(d<1/0&&c<n.length&&n.splice(0,n.length-c),!a){const i=o.now();let g=0;for(let C=1;C<n.length&&n[C]<=i;C+=2)g=C;g&&n.splice(0,g+1)}}}var m=t(815);function p(h,d,o){let n,a=!1;return h&&"object"==typeof h?({bufferSize:n=1/0,windowTime:d=1/0,refCount:a=!1,scheduler:o}=h):n=h??1/0,(0,m.B)({connector:()=>new f(n,d,o),resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:a})}},4901:(Q,v,t)=>{var e=t(3366),D=t(9678),f=t(5278),m=t(5457),p=t(7594),h=t(9035),d=t(8507);d.alea=e,d.xor128=D,d.xorwow=f,d.xorshift7=m,d.xor4096=p,d.tychei=h,Q.exports=d},3366:function(Q,v,t){var e;!function(D,f,m){function p(n){var a=this,c=function o(){var n=4022871197;return function(c){c=String(c);for(var i=0;i<c.length;i++){var g=.02519603282416938*(n+=c.charCodeAt(i));g-=n=g>>>0,n=(g*=n)>>>0,n+=4294967296*(g-=n)}return 2.3283064365386963e-10*(n>>>0)}}();a.next=function(){var i=2091639*a.s0+2.3283064365386963e-10*a.c;return a.s0=a.s1,a.s1=a.s2,a.s2=i-(a.c=0|i)},a.c=1,a.s0=c(" "),a.s1=c(" "),a.s2=c(" "),a.s0-=c(n),a.s0<0&&(a.s0+=1),a.s1-=c(n),a.s1<0&&(a.s1+=1),a.s2-=c(n),a.s2<0&&(a.s2+=1),c=null}function h(n,a){return a.c=n.c,a.s0=n.s0,a.s1=n.s1,a.s2=n.s2,a}function d(n,a){var c=new p(n),i=a&&a.state,g=c.next;return g.int32=function(){return 4294967296*c.next()|0},g.double=function(){return g()+11102230246251565e-32*(2097152*g()|0)},g.quick=g,i&&("object"==typeof i&&h(i,c),g.state=function(){return h(c,{})}),g}f&&f.exports?f.exports=d:t.amdD&&t.amdO?void 0!==(e=function(){return d}.call(v,t,v,f))&&(f.exports=e):this.alea=d}(0,Q=t.nmd(Q))},9035:function(Q,v,t){var e;!function(D,f,m){function p(o){var n=this,a="";n.next=function(){var i=n.b,g=n.c,C=n.d,I=n.a;return i=i<<25^i>>>7^g,g=g-C|0,C=C<<24^C>>>8^I,I=I-i|0,n.b=i=i<<20^i>>>12^g,n.c=g=g-C|0,n.d=C<<16^g>>>16^I,n.a=I-i|0},n.a=0,n.b=0,n.c=-1640531527,n.d=1367130551,o===Math.floor(o)?(n.a=o/4294967296|0,n.b=0|o):a+=o;for(var c=0;c<a.length+20;c++)n.b^=0|a.charCodeAt(c),n.next()}function h(o,n){return n.a=o.a,n.b=o.b,n.c=o.c,n.d=o.d,n}function d(o,n){var a=new p(o),c=n&&n.state,i=function(){return(a.next()>>>0)/4294967296};return i.double=function(){do{var I=((a.next()>>>11)+(a.next()>>>0)/4294967296)/(1<<21)}while(0===I);return I},i.int32=a.next,i.quick=i,c&&("object"==typeof c&&h(c,a),i.state=function(){return h(a,{})}),i}f&&f.exports?f.exports=d:t.amdD&&t.amdO?void 0!==(e=function(){return d}.call(v,t,v,f))&&(f.exports=e):this.tychei=d}(0,Q=t.nmd(Q))},9678:function(Q,v,t){var e;!function(D,f,m){function p(o){var n=this,a="";n.x=0,n.y=0,n.z=0,n.w=0,n.next=function(){var i=n.x^n.x<<11;return n.x=n.y,n.y=n.z,n.z=n.w,n.w^=n.w>>>19^i^i>>>8},o===(0|o)?n.x=o:a+=o;for(var c=0;c<a.length+64;c++)n.x^=0|a.charCodeAt(c),n.next()}function h(o,n){return n.x=o.x,n.y=o.y,n.z=o.z,n.w=o.w,n}function d(o,n){var a=new p(o),c=n&&n.state,i=function(){return(a.next()>>>0)/4294967296};return i.double=function(){do{var I=((a.next()>>>11)+(a.next()>>>0)/4294967296)/(1<<21)}while(0===I);return I},i.int32=a.next,i.quick=i,c&&("object"==typeof c&&h(c,a),i.state=function(){return h(a,{})}),i}f&&f.exports?f.exports=d:t.amdD&&t.amdO?void 0!==(e=function(){return d}.call(v,t,v,f))&&(f.exports=e):this.xor128=d}(0,Q=t.nmd(Q))},7594:function(Q,v,t){var e;!function(D,f,m){function p(o){var n=this;n.next=function(){var C,I,c=n.w,i=n.X,g=n.i;return n.w=c=c+1640531527|0,I=i[g+34&127],C=i[g=g+1&127],I^=I<<13,C^=C<<17,I=i[g]=(I^=I>>>15)^(C^=C>>>12),n.i=g,I+(c^c>>>16)|0},function a(c,i){var g,C,I,S,K,z=[],H=128;for(i===(0|i)?(C=i,i=null):(i+="\0",C=0,H=Math.max(H,i.length)),I=0,S=-32;S<H;++S)i&&(C^=i.charCodeAt((S+32)%i.length)),0===S&&(K=C),C^=C<<10,C^=C>>>15,C^=C<<4,C^=C>>>13,S>=0&&(I=0==(g=z[127&S]^=C+(K=K+1640531527|0))?I+1:0);for(I>=128&&(z[127&(i&&i.length||0)]=-1),I=127,S=512;S>0;--S)C=z[I+34&127],g=z[I=I+1&127],C^=C<<13,g^=g<<17,z[I]=(C^=C>>>15)^(g^=g>>>12);c.w=K,c.X=z,c.i=I}(n,o)}function h(o,n){return n.i=o.i,n.w=o.w,n.X=o.X.slice(),n}function d(o,n){null==o&&(o=+new Date);var a=new p(o),c=n&&n.state,i=function(){return(a.next()>>>0)/4294967296};return i.double=function(){do{var I=((a.next()>>>11)+(a.next()>>>0)/4294967296)/(1<<21)}while(0===I);return I},i.int32=a.next,i.quick=i,c&&(c.X&&h(c,a),i.state=function(){return h(a,{})}),i}f&&f.exports?f.exports=d:t.amdD&&t.amdO?void 0!==(e=function(){return d}.call(v,t,v,f))&&(f.exports=e):this.xor4096=d}(0,Q=t.nmd(Q))},5457:function(Q,v,t){var e;!function(D,f,m){function p(o){var n=this;n.next=function(){var g,C,c=n.x,i=n.i;return g=c[i],C=(g^=g>>>7)^g<<24,C^=(g=c[i+1&7])^g>>>10,C^=(g=c[i+3&7])^g>>>3,C^=(g=c[i+4&7])^g<<7,g=c[i+7&7],c[i]=C^=(g^=g<<13)^g<<9,n.i=i+1&7,C},function a(c,i){var g,I=[];if(i===(0|i))I[0]=i;else for(i=""+i,g=0;g<i.length;++g)I[7&g]=I[7&g]<<15^i.charCodeAt(g)+I[g+1&7]<<13;for(;I.length<8;)I.push(0);for(g=0;g<8&&0===I[g];++g);for(8==g&&(I[7]=-1),c.x=I,c.i=0,g=256;g>0;--g)c.next()}(n,o)}function h(o,n){return n.x=o.x.slice(),n.i=o.i,n}function d(o,n){null==o&&(o=+new Date);var a=new p(o),c=n&&n.state,i=function(){return(a.next()>>>0)/4294967296};return i.double=function(){do{var I=((a.next()>>>11)+(a.next()>>>0)/4294967296)/(1<<21)}while(0===I);return I},i.int32=a.next,i.quick=i,c&&(c.x&&h(c,a),i.state=function(){return h(a,{})}),i}f&&f.exports?f.exports=d:t.amdD&&t.amdO?void 0!==(e=function(){return d}.call(v,t,v,f))&&(f.exports=e):this.xorshift7=d}(0,Q=t.nmd(Q))},5278:function(Q,v,t){var e;!function(D,f,m){function p(o){var n=this,a="";n.next=function(){var i=n.x^n.x>>>2;return n.x=n.y,n.y=n.z,n.z=n.w,n.w=n.v,(n.d=n.d+362437|0)+(n.v=n.v^n.v<<4^i^i<<1)|0},n.x=0,n.y=0,n.z=0,n.w=0,n.v=0,o===(0|o)?n.x=o:a+=o;for(var c=0;c<a.length+64;c++)n.x^=0|a.charCodeAt(c),c==a.length&&(n.d=n.x<<10^n.x>>>4),n.next()}function h(o,n){return n.x=o.x,n.y=o.y,n.z=o.z,n.w=o.w,n.v=o.v,n.d=o.d,n}function d(o,n){var a=new p(o),c=n&&n.state,i=function(){return(a.next()>>>0)/4294967296};return i.double=function(){do{var I=((a.next()>>>11)+(a.next()>>>0)/4294967296)/(1<<21)}while(0===I);return I},i.int32=a.next,i.quick=i,c&&("object"==typeof c&&h(c,a),i.state=function(){return h(a,{})}),i}f&&f.exports?f.exports=d:t.amdD&&t.amdO?void 0!==(e=function(){return d}.call(v,t,v,f))&&(f.exports=e):this.xorwow=d}(0,Q=t.nmd(Q))},8507:function(Q,v,t){var e;!function(D,f,m){var g,p=256,n=m.pow(p,6),a=m.pow(2,52),c=2*a,i=p-1;function C(N,W,k){var T=[],_=z(K((W=1==W?{entropy:!0}:W||{}).entropy?[N,ct(f)]:N??function H(){try{var N;return g&&(N=g.randomBytes)?N=N(p):(N=new Uint8Array(p),(D.crypto||D.msCrypto).getRandomValues(N)),ct(N)}catch{var W=D.navigator,k=W&&W.plugins;return[+new Date,D,k,D.screen,ct(f)]}}(),3),T),r=new I(T),y=function(){for(var x=r.g(6),w=n,V=0;x<a;)x=(x+V)*p,w*=p,V=r.g(1);for(;x>=c;)x/=2,w/=2,V>>>=1;return(x+V)/w};return y.int32=function(){return 0|r.g(4)},y.quick=function(){return r.g(4)/4294967296},y.double=y,z(ct(r.S),f),(W.pass||k||function(x,w,V,et){return et&&(et.S&&S(et,r),x.state=function(){return S(r,{})}),V?(m.random=x,w):x})(y,_,"global"in W?W.global:this==m,W.state)}function I(N){var W,k=N.length,T=this,_=0,r=T.i=T.j=0,y=T.S=[];for(k||(N=[k++]);_<p;)y[_]=_++;for(_=0;_<p;_++)y[_]=y[r=i&r+N[_%k]+(W=y[_])],y[r]=W;(T.g=function(x){for(var w,V=0,et=T.i,U=T.j,F=T.S;x--;)w=F[et=i&et+1],V=V*p+F[i&(F[et]=F[U=i&U+w])+(F[U]=w)];return T.i=et,T.j=U,V})(p)}function S(N,W){return W.i=N.i,W.j=N.j,W.S=N.S.slice(),W}function K(N,W){var _,k=[],T=typeof N;if(W&&"object"==T)for(_ in N)try{k.push(K(N[_],W-1))}catch{}return k.length?k:"string"==T?N:N+"\0"}function z(N,W){for(var T,k=N+"",_=0;_<k.length;)W[i&_]=i&(T^=19*W[i&_])+k.charCodeAt(_++);return ct(W)}function ct(N){return String.fromCharCode.apply(0,N)}if(z(m.random(),f),Q.exports){Q.exports=C;try{g=t(5042)}catch{}}else void 0!==(e=function(){return C}.call(v,t,v,Q))&&(Q.exports=e)}(typeof self<"u"?self:this,[],Math)},5410:()=>{},8628:()=>{},5042:()=>{}}]);