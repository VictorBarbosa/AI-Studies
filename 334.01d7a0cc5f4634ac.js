(self.webpackChunkapp=self.webpackChunkapp||[]).push([[334],{334:(Hz,ch,R)=>{"use strict";R.d(ch,{Xhn:()=>l.browser,ugM:()=>Kr,YLj:()=>OC,MB5:()=>l.losses,iD$:()=>l.scalar,Pel:()=>_x,XAC:()=>l.softmax,wOQ:()=>l.tensor3d,yXz:()=>l.tensor4d});var Kr={};R.r(Kr),R.d(Kr,{Layer:()=>ue,RNN:()=>wn,RNNCell:()=>ys,activation:()=>R0,add:()=>L0,alphaDropout:()=>Cb,average:()=>P0,averagePooling1d:()=>li,averagePooling2d:()=>ui,averagePooling3d:()=>ci,avgPool1d:()=>X0,avgPool2d:()=>q0,avgPool3d:()=>Y0,avgPooling1d:()=>K0,avgPooling2d:()=>Z0,avgPooling3d:()=>Q0,batchNormalization:()=>U0,bidirectional:()=>pb,categoryEncoding:()=>Nb,centerCrop:()=>Ib,concatenate:()=>V0,conv1d:()=>b0,conv2d:()=>C0,conv2dTranspose:()=>v0,conv3d:()=>S0,conv3dTranspose:()=>I0,convLstm2d:()=>lb,convLstm2dCell:()=>ub,cropping2D:()=>N0,dense:()=>A0,depthwiseConv2d:()=>k0,dot:()=>G0,dropout:()=>D0,elu:()=>h0,embedding:()=>z0,flatten:()=>E0,gaussianDropout:()=>bb,gaussianNoise:()=>xb,globalAveragePooling1d:()=>J0,globalAveragePooling2d:()=>eb,globalMaxPool1d:()=>fb,globalMaxPool2d:()=>mb,globalMaxPooling1d:()=>rc,globalMaxPooling2d:()=>ac,gru:()=>nb,gruCell:()=>sb,input:()=>Fx,inputLayer:()=>p0,layerNormalization:()=>H0,leakyReLU:()=>m0,lstm:()=>rb,lstmCell:()=>ab,masking:()=>vb,maxPool1d:()=>gb,maxPool2d:()=>yb,maxPooling1d:()=>ic,maxPooling2d:()=>oc,maxPooling3d:()=>tb,maximum:()=>B0,minimum:()=>M0,multiply:()=>W0,permute:()=>O0,prelu:()=>g0,randomWidth:()=>Tb,reLU:()=>f0,repeatVector:()=>_0,rescaling:()=>Sb,reshape:()=>F0,resizing:()=>wb,rnn:()=>cb,separableConv2d:()=>w0,simpleRNN:()=>ib,simpleRNNCell:()=>ob,softmax:()=>y0,spatialDropout1d:()=>$0,stackedRNNCells:()=>db,thresholdedReLU:()=>x0,timeDistributed:()=>hb,upSampling2d:()=>T0,zeroPadding2d:()=>j0});var qr={};R.r(qr),R.d(qr,{json:()=>Db});var Zr={};R.r(Zr),R.d(Zr,{json:()=>$b});var Yr={};R.r(Yr),R.d(Yr,{json:()=>Eb});var Qr={};R.r(Qr),R.d(Qr,{json:()=>_b});var Jr={};R.r(Jr),R.d(Jr,{json:()=>Fb});var ea={};R.r(ea),R.d(ea,{json:()=>Ob});var ta={};R.r(ta),R.d(ta,{json:()=>zb});var na={};R.r(na),R.d(na,{json:()=>Lb});var sa={};R.r(sa),R.d(sa,{json:()=>Pb});var ra={};R.r(ra),R.d(ra,{json:()=>Vb});var aa={};R.r(aa),R.d(aa,{json:()=>Bb});var ia={};R.r(ia),R.d(ia,{json:()=>Mb});var oa={};R.r(oa),R.d(oa,{json:()=>Wb});var la={};R.r(la),R.d(la,{json:()=>Gb});var ua={};R.r(ua),R.d(ua,{json:()=>Ub});var ca={};R.r(ca),R.d(ca,{json:()=>Hb});var da={};R.r(da),R.d(da,{json:()=>jb});var pa={};R.r(pa),R.d(pa,{json:()=>Xb});var ha={};R.r(ha),R.d(ha,{json:()=>Kb});var fa={};R.r(fa),R.d(fa,{addImpl:()=>Vc,bincountImpl:()=>Oi,bincountReduceImpl:()=>Hc,castImpl:()=>Pc,ceilImpl:()=>jc,concatImpl:()=>Xc,equalImpl:()=>Zc,expImpl:()=>Qc,expm1Impl:()=>ed,floorImpl:()=>sd,gatherNdImpl:()=>rd,gatherV2Impl:()=>ad,greaterEqualImpl:()=>od,greaterImpl:()=>id,lessEqualImpl:()=>ud,lessImpl:()=>ld,linSpaceImpl:()=>cd,logImpl:()=>dd,maxImpl:()=>pd,maximumImpl:()=>fd,minimumImpl:()=>md,multiplyImpl:()=>zi,negImpl:()=>yd,notEqualImpl:()=>xd,prodImpl:()=>Sd,raggedGatherImpl:()=>wd,raggedRangeImpl:()=>Td,raggedTensorToTensorImpl:()=>Ad,rangeImpl:()=>Dd,rsqrtImpl:()=>$d,scatterImpl:()=>Dn,sigmoidImpl:()=>vv,simpleAbsImpl:()=>Mc,sliceImpl:()=>Uc,sparseFillEmptyRowsImpl:()=>_d,sparseReshapeImpl:()=>Fd,sparseSegmentReductionImpl:()=>Wi,sqrtImpl:()=>qT,staticRegexReplaceImpl:()=>Od,stridedSliceImpl:()=>zd,stringNGramsImpl:()=>Ld,stringSplitImpl:()=>Pd,stringToHashBucketFastImpl:()=>Vd,subImpl:()=>td,tileImpl:()=>Bd,topKImpl:()=>Wd,transposeImpl:()=>_i,uniqueImpl:()=>Ud});var l=R(7575),M=R(6338),de=R(4879),Y=R(1300),zs=R(4429);const uo={kernelName:M.SYM,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,(0,zs.N)((0,de.p)(e,"float32"),-1))}}};var Le=R(8366),pt=R(181),Ke=R(8153),Ln=R(6900),qe=R(4463),it=R(3217);const dh={kernelName:M.VGw,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=(0,qe.h)((0,de.p)(e,"float32")),r=(0,Ln._)((0,it.l)((0,Ke.i)(1),s));return(0,pt.W)((0,Le.h)(n,r))}}}},ph={kernelName:M.SpW,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=(0,Ln._)((0,it.l)((0,qe.h)((0,de.p)(e,"float32")),1));return(0,Le.h)(n,s)}}}};var Ne=R(3469),se=R(3626),Te=R(7782);const hh={kernelName:M.mm_,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne.assertAndGetBroadcastShape(e.shape,s.shape);return{a:()=>{let o=n;const u=Ne.getReductionAxes(e.shape,r);return u.length>0&&(o=(0,Te.S)(o,u)),(0,se.X)(o,e.shape)},b:()=>{let o=n;const u=Ne.getReductionAxes(s.shape,r);return u.length>0&&(o=(0,Te.S)(o,u)),(0,se.X)(o,s.shape)}}}},fh={kernelName:M.Xze,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((s,r)=>{e[r]=()=>n.clone()}),e}};var _e=R(9314);const mh={kernelName:M.sJF,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,_e.P)(e)}}},gh={kernelName:M.aJk,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,_e.P)(e)}}},yh={kernelName:M.M2y,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,Ln._)((0,it.l)((0,Ke.i)(1),(0,qe.h)((0,de.p)(e,"float32")))))}}};var bt=R(319);const xh={kernelName:M.qw7,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=(0,Ln._)((0,bt.I)((0,Ke.i)(1),(0,qe.h)((0,de.p)(e,"float32"))));return(0,Le.h)(n,s)}}}},bh={kernelName:M.QCc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=(0,Ne.assertAndGetBroadcastShape)(e.shape,s.shape);return{a:()=>{const o=(0,bt.I)((0,qe.h)(e),(0,qe.h)(s));let u=(0,Y.d)(n,(0,Le.h)(s,o));const c=(0,Ne.getReductionAxes)(e.shape,r);return c.length>0&&(u=(0,Te.S)(u,c)),(0,se.X)(u,e.shape)},b:()=>{const o=(0,bt.I)((0,qe.h)(e),(0,qe.h)(s));let u=(0,pt.W)((0,Y.d)(n,(0,Le.h)(e,o)));const c=(0,Ne.getReductionAxes)(s.shape,r);return c.length>0&&(u=(0,Te.S)(u,c)),(0,se.X)(u,s.shape)}}}},Ch={kernelName:M.jMg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,bt.I)((0,qe.h)((0,de.p)(e,"float32")),1))}}},vh={kernelName:M.Oyi,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,it.l)((0,Ke.i)(1),(0,qe.h)((0,de.p)(e,"float32"))))}}};var Ct=R(2882),At=R(4810),fe=R(62),Kt=R(7202),Pn=R(5948);const Ih=(0,Pn.op)({avgPool3dGrad_:function Sh(n,t,e,s,r,a){const i=(0,At._1)(n,"dy","avgPool3dGrad"),o=(0,At._1)(t,"input","avgPool3dGrad");let u=i,c=o,d=!1;4===o.rank&&(d=!0,u=(0,se.X)(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=(0,se.X)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),fe.hu(5===u.rank,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),fe.hu(5===c.rank,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),(0,Kt.m)("avgPool3dGrad",r,a);const f=Ct.BV.runKernel(M.IMb,{dy:u,input:c},{filterSize:e,strides:s,pad:r,dimRoundingMode:a});return d?(0,se.X)(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}}),wh={kernelName:M._k9,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:a,pad:i,dimRoundingMode:o}=e;return{x:()=>Ih(n,s,r,a,i,o)}}},Th=(0,Pn.op)({avgPoolGrad_:function Nh(n,t,e,s,r){const a=(0,At._1)(n,"dy","avgPoolGrad"),i=(0,At._1)(t,"input","avgPoolGrad");fe.hu(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,u=a,c=!1;3===i.rank&&(c=!0,o=(0,se.X)(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=(0,se.X)(a,[1,a.shape[0],a.shape[1],a.shape[2]])),fe.hu(4===u.rank,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),fe.hu(4===o.rank,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const h=Ct.BV.runKernel(M.ROF,{dy:u,input:o},{filterSize:e,strides:s,pad:r});return c?(0,se.X)(h,[h.shape[1],h.shape[2],h.shape[3]]):h}}),kh={kernelName:M.JhU,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{filterSize:r,strides:a,pad:i}=e;return{x:()=>Th(n,s,r,a,i)}}};var Bt=R(4291);const Rh={kernelName:M.XLW,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[s,r]=t,{transposeA:a,transposeB:i}=e;return a||i?!a&&i?{a:()=>(0,Bt.O)(n,r,!1,!1),b:()=>(0,Bt.O)(n,s,!0,!1)}:a&&!i?{a:()=>(0,Bt.O)(r,n,!1,!0),b:()=>(0,Bt.O)(s,n,!1,!1)}:{a:()=>(0,Bt.O)(r,n,!0,!0),b:()=>(0,Bt.O)(n,s,!0,!0)}:{a:()=>(0,Bt.O)(n,r,!1,!0),b:()=>(0,Bt.O)(s,n,!0,!1)}}};var co=R(1705);const Ah={kernelName:M.zws,gradFunc:(n,t,e)=>{const{blockShape:s,crops:r}=e;return{x:()=>(0,co.f)(n,s,r)}}},Dh={kernelName:M.Ly9,gradFunc:(n,t,e)=>{const r=e.inputShape,a=e.shape,i=Array.from(a);for(let u=r.length-1;u>=0;u--)if(r[u]===a[u])i[u]=1;else if(1!==r[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${a}].`);const o=[];for(let u=0;u<i.length;u++)i[u]>1&&o.push(u);return{x:()=>(0,Te.S)(n,o,!0)}}},$h={kernelName:M.RFZ,gradFunc:n=>({x:()=>n.clone()})},Eh={kernelName:M.gJX,gradFunc:n=>({x:()=>(0,_e.P)(n)})};var Ls=R(4239),Ps=R(521),ma=R(7369),qt=R(8793);const _h={kernelName:M.xnO,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{clipValueMin:r,clipValueMax:a}=e;return{x:()=>(0,qt.a)((0,ma.H)((0,Ls.b)(s,r),(0,Ps.z)(s,a)),n,(0,_e.P)(n))}}},Fh={kernelName:M.yj2,inputsToSave:["x"],gradFunc:uo.gradFunc};var po=R(633);const Oh={kernelName:M.Eh3,saveAllInputs:!0,gradFunc:(n,t,e)=>{const s=t.map(u=>u.shape),{axis:r}=e,a=(0,fe.EC)(r,t[0].shape)[0],i=s.map(u=>u[a]);return(0,po.V)(n,i,a).map(u=>()=>u)}};var ho=R(4867),zh=R(8445);const Lh={kernelName:M.mhS,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{dilations:a,strides:i,pad:o,dataFormat:u}=e;return fe.hu(Kt.I0(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>(0,zh._)(s.shape,n,r,i,o,u),filter:()=>(0,ho.p)(s,n,r.shape,i,o,u)}}};var fo=R(6509);const Ph={kernelName:M.wm,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:u}=e;return{dy:()=>(0,fo.T)(n,r,a,i,o,1,u),filter:()=>(0,ho.p)(n,s,r.shape,a,i,o,u)}}},Bh=(0,Pn.op)({conv3DBackpropFilter_:function Vh(n,t,e,s,r){let a=n;4===n.rank&&(a=(0,se.X)(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let i=t;return 4===i.rank&&(i=(0,se.X)(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),fe.hu(5===a.rank,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),fe.hu(5===i.rank,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),fe.hu(5===e.length,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),fe.hu(a.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${e[3]}.`),fe.hu(i.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${e[4]}).`),Ct.BV.runKernel(M.o2y,{x:a,dy:i},{strides:s,pad:r,filterShape:e})}});var Mh=R(8921);const Wh={kernelName:M.x12,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:a}=e;fe.hu((0,Kt.I0)(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[i,o]=t;return{x:()=>(0,Mh._)(i.shape,n,o,r,a),filter:()=>Bh(i,n,o.shape,r,a)}}};var mo=R(1969);const Gh={kernelName:M.mc4,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)((0,pt.W)((0,mo.O)((0,de.p)(e,"float32"))),n)}}};var go=R(3981);const Uh={kernelName:M.TR1,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)((0,go.R)((0,de.p)(e,"float32")),n)}}};var Zt=R(2745),yo=R(5023),yn=R(3111);const Hh={kernelName:M.iHb,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r,exclusive:a,reverse:i}=e;return{x:()=>{const o=(0,Zt.Q3)([r],s.rank);let u=(0,yo.z)(n,r,a,!i);return null!=o&&(u=(0,yn.p)(u,o)),u}}}};var jh=R(527),Xh=R(3905);const Kh={kernelName:M.cie,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:s,strides:r,pad:a,dimRoundingMode:i}=e,o=s??[1,1];fe.hu(Kt.I0(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[u,c]=t;return fe.hu(4===u.rank,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),fe.hu(4===c.rank,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),fe.hu(u.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),fe.hu(Kt.jT(r,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`),Kt.m("depthwiseConv2d",a,i),{x:()=>(0,Xh.v)(u.shape,n,c,r,a,o,i),filter:()=>(0,jh.z)(u,n,c.shape,r,a,o,i)}}},qh={kernelName:M.p4S,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[s,r]=t,a={x:s,filter:r,dy:n},i={x:s,filter:r,dy:n};return{x:()=>Ct.BV.runKernel(M.ekb,a,e),filter:()=>Ct.BV.runKernel(M.Vn9,i,e)}}},Zh={kernelName:M.SX0,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,s={dy:n,y:e};return{x:()=>Ct.BV.runKernel(M.HEU,s)}}};var is=R(835);const Yh={kernelName:M.Omj,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=(0,Y.d)((0,is.Q)((0,pt.W)((0,qe.h)(e))),2/Math.sqrt(Math.PI));return{x:()=>(0,Y.d)(n,s)}}},Qh={kernelName:M.NEP,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,e)}}},Jh={kernelName:M.YFo,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>(0,se.X)(n,e.shape)}}},ef={kernelName:M.Y0y,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,(0,is.Q)(e))}}},nf={kernelName:M.OR,gradFunc:n=>({x:()=>(0,_e.P)(n)})},sf={kernelName:M.jeX,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=(0,Ne.assertAndGetBroadcastShape)(e.shape,s.shape);return{a:()=>{const o=(0,Le.h)(n,(0,de.p)(s,"float32")),u=(0,Ne.getReductionAxes)(e.shape,r);return u.length>0?(0,se.X)((0,Te.S)(o,u),e.shape):o},b:()=>{let o=(0,Y.d)(n,(0,de.p)(e,"float32"));const u=(0,Ne.getReductionAxes)(s.shape,r);u.length>0&&(o=(0,se.X)((0,Te.S)(o,u),s.shape));const c=(0,qe.h)(s);return(0,pt.W)((0,Le.h)(o,(0,de.p)(c,"float32")))}}}};var xo=R(242),bo=R(3063);const rf={kernelName:M.sHE,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:s}=e,[r,a,i,o]=t,u=o??(0,Ke.i)(1),c=(0,Ne.getReductionAxes)(a.shape,r.shape),d=[];if(1===a.rank){for(let v=0;v<r.shape.length-1;++v)d.push(r.shape[v]);d.push(1)}const p=(0,it.l)(r,a),h=(0,Y.d)(n,u),f=(0,xo.b)((0,bt.I)(i,(0,Ke.i)(s))),m=(0,Y.d)((0,Y.d)((0,Y.d)(f,f),f),(0,Ke.i)(-.5));return{x:()=>(0,se.X)((0,Y.d)((0,Y.d)(n,1===a.rank?(0,bo.G)((0,se.X)(f,[1,1,1,a.shape[0]]),d):f),u),r.shape),mean:()=>{let v=(0,Y.d)((0,Y.d)(f,(0,Ke.i)(-1)),h);return 1===a.rank&&(v=(0,Te.S)(v,c)),(0,se.X)(v,a.shape)},variance:()=>{let v=(0,Y.d)((0,Y.d)(m,p),h);return 1===a.rank&&(v=(0,Te.S)(v,c)),(0,se.X)(v,a.shape)},scale:()=>{const v=(0,Y.d)(p,f);let I=(0,Y.d)(n,v);return 1===a.rank&&(I=(0,Te.S)(I,c)),(0,se.X)(I,a.shape)},offset:()=>{let v=n;return 1===a.rank&&(v=(0,Te.S)(v,c)),(0,se.X)(v,a.shape)}}}};var Co=R(6442);const af={kernelName:M.qi_,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[s,r]=t,{axis:a}=e,i=(0,fe.EC)(a,s.shape)[0];return{x:()=>{const u=s.shape,c=r.size,d=u.slice(0,i),p=d.length,h=u.slice(a,u.length).slice(1),f=h.length,m=vo(0,p),y=vo(p+1,p+1+f),g=So([d,[c],h]),x=(0,se.X)(n,g),b=(0,se.X)(r,[c]),S=So([[p],m,y]),v=(0,yn.p)(x,S);let I=(0,Co.p)(v,b,s.shape[i]);const w=(0,Zt.LJ)(S);return I=(0,yn.p)(I,w),I},indices:()=>r}}};function vo(n,t){const e=[];for(let s=n;s<t;++s)e.push(s);return e}function So(n){const t=[];for(let e=0;e<n.length;++e)for(let s=0;s<n[e].length;++s)t.push(n[e][s]);return t}const of={kernelName:M.Acj,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>(0,_e.P)(e),b:()=>(0,_e.P)(s)}}},lf={kernelName:M.iJz,gradFunc:n=>({x:()=>(0,de.p)(n,"float32")})},uf={kernelName:M.avt,gradFunc:n=>({x:()=>(0,_e.P)(n)})},cf={kernelName:M.iWB,gradFunc:n=>({x:()=>(0,_e.P)(n)})},df={kernelName:M.r7n,gradFunc:n=>({x:()=>(0,_e.P)(n)})};var Vn=R(7844);const pf={kernelName:M.J$2,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{alpha:r}=e,a=(0,Vn.p)(s,0);return{x:()=>(0,qt.a)(a,n,(0,Y.d)(n,r))}}},hf={kernelName:M.kU,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,bt.I)(e,1))}}},ff={kernelName:M.ZbH,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,de.p)(e,"float32"))}}},mf={kernelName:M.qCd,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;return{logits:()=>{const i=(0,is.Q)(s);return(0,it.l)(n,(0,Y.d)((0,Te.S)(n,r,!0),i))}}}},yf=(0,Pn.op)({localResponseNormalizationBackprop_:function gf(n,t,e,s=5,r=1,a=1,i=.5){return Ct.BV.runKernel(M.Hhh,{x:n,y:t,dy:e},{depthRadius:s,bias:r,alpha:a,beta:i})}}),xf={kernelName:M.eZ0,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{depthRadius:a,bias:i,alpha:o,beta:u}=e;return{x:()=>yf(s,r,n,a,i,o,u)}}};var Io=R(5393);function wo(n,t,e,s){return t.rank<e.rank&&(t=(0,se.X)(t,Zt.rv(t.shape,s))),n.rank<e.rank&&(n=(0,se.X)(n,Zt.rv(n.shape,s))),{x:()=>(0,Y.d)(n,(0,de.p)((0,Io.D)(e,t),n.dtype))}}const No={kernelName:M.YoZ,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{reductionIndices:r}=s,a=t[0],u=wo(n,t[1],a,fe.EC(r,a.shape));return{x:()=>u.x()}}};var To=R(9027);const bf={kernelName:M.BMI,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>(0,Y.d)(n,(0,de.p)((0,Ls.b)(e,s),"float32")),b:()=>(0,Y.d)(n,(0,de.p)((0,To.d)(e,s),"float32"))}}},vf=(0,Pn.op)({maxPool3dGrad_:function Cf(n,t,e,s,r,a,i){const o=(0,At._1)(n,"dy","maxPool3dGrad"),u=(0,At._1)(t,"input","maxPool3dGrad"),c=(0,At._1)(e,"output","maxPool3dGrad");let d=o,p=u,h=c,f=!1;4===u.rank&&(f=!0,d=(0,se.X)(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),p=(0,se.X)(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),h=(0,se.X)(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),fe.hu(5===d.rank,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${d.rank}.`),fe.hu(5===p.rank,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),fe.hu(5===h.rank,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),(0,Kt.m)("maxPool3dGrad",a,i);const g=Ct.BV.runKernel(M.OU7,{dy:d,input:p,output:h},{filterSize:s,strides:r,pad:a,dimRoundingMode:i});return f?(0,se.X)(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),Sf={kernelName:M.OAf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=e;return{x:()=>vf(n,s,r,a,i,o,u)}}},wf=(0,Pn.op)({maxPoolGrad_:function If(n,t,e,s,r,a,i){const o=(0,At._1)(n,"dy","maxPoolGrad"),u=(0,At._1)(t,"input","maxPoolGrad"),c=(0,At._1)(e,"output","maxPoolGrad");return fe.hu(u.rank===o.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${o.rank})`),fe.hu(4===o.rank,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),fe.hu(4===u.rank,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Kt.m("maxPoolGrad",a,i),Ct.BV.runKernel(M.OV7,{dy:o,input:u,output:c},{filterSize:s,strides:r,pad:a,dimRoundingMode:i})}}),Nf={kernelName:M.mTV,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s,r]=t,{filterSize:a,strides:i,pad:o}=e;return{x:()=>wf(n,s,r,a,i,o)}}};var ga=R(6217);const Tf={kernelName:M.q2K,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e,a=fe.EC(r,s.shape),o=(0,Zt.kz)(s.shape,a)[1],u=fe.NA(o);return{x:()=>{const d=s.shape.slice();a.forEach(f=>{d[f]=1});const p=(0,se.X)(n,d);return(0,Le.h)((0,Y.d)(p,(0,ga.i)(s.shape,"float32")),u)}}}},kf={kernelName:M.c17,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const s=e,{axis:r}=s,[a,i]=t,u=wo(n,i,a,fe.EC(r,a.shape));return{x:()=>u.x()}}},Rf={kernelName:M.q8u,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t;return{a:()=>(0,Y.d)(n,(0,de.p)((0,Ps.z)(e,s),"float32")),b:()=>(0,Y.d)(n,(0,de.p)((0,Vn.p)(e,s),"float32"))}}};var xn=R(8577);const Af={kernelName:M.jQs,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,a=r.map(i=>i[0]);return{x:()=>(0,xn.t)(n,a,s.shape)}}};var ko=R(3849);const Df={kernelName:M.Vbg,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=(0,Ne.assertAndGetBroadcastShape)(e.shape,s.shape);return{a:()=>{const o=(0,Ne.getReductionAxes)(e.shape,r);return o.length>0?(0,se.X)((0,Te.S)(n,o),e.shape):n},b:()=>{const o=(0,Y.d)(n,(0,pt.W)((0,ko.G)((0,Le.h)(e,s)))),u=(0,Ne.getReductionAxes)(s.shape,r);return u.length>0?(0,se.X)((0,Te.S)(o,u),s.shape):o}}}},$f={kernelName:M.wYn,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=(0,Ne.assertAndGetBroadcastShape)(e.shape,s.shape);return{a:()=>{const o=(0,Y.d)(n,(0,de.p)(s,"float32")),u=(0,Ne.getReductionAxes)(e.shape,r);return u.length>0?(0,se.X)((0,Te.S)(o,u),e.shape):o},b:()=>{const o=(0,Y.d)(n,(0,de.p)(e,"float32")),u=(0,Ne.getReductionAxes)(s.shape,r);return u.length>0?(0,se.X)((0,Te.S)(o,u),s.shape):o}}}},Ef={kernelName:M.kuV,gradFunc:n=>({x:()=>(0,pt.W)(n)})};var _f=R(7799);const Ff={kernelName:M.we_,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>(0,_f.l)(e.shape,"float32")}}},Of={kernelName:M.qWM,gradFunc:n=>({x:()=>(0,_e.P)(n)})};var Ro=R(230);const zf={kernelName:M.QiL,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:s}=e;return(0,Ro.H)(n,s).map(a=>()=>a)}},Ao={kernelName:M.lyA,inputsToSave:["x"],gradFunc:(n,t,e)=>{const s=t[0],{paddings:r}=e,a=r.map(i=>i[0]);return{x:()=>(0,xn.t)(n,a,s.shape)}}};var Do=R(8873),ya=R(2293);const Lf={kernelName:M.pe_,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,s,r]=t,a=e,i=s,o=Ne.assertAndGetBroadcastShape(a.shape,i.shape);return{a:()=>{const d=(0,de.p)(i,"float32");let p=(0,Y.d)(n,(0,Y.d)(d,(0,ya.s)(a,(0,it.l)(d,(0,Ke.i)(1)))));const h=Ne.getReductionAxes(a.shape,o);return h.length>0&&(p=(0,Te.S)(p,h)),(0,se.X)(p,a.shape)},b:()=>{const d=(0,Vn.p)(a,0),p=(0,qt.a)(d,(0,Do.c)(a),(0,_e.P)(a));let h=(0,Y.d)(n,(0,Y.d)(r,p));const f=Ne.getReductionAxes(i.shape,o);return f.length>0&&(h=(0,Te.S)(h,f)),(0,se.X)(h,i.shape)}}}},Pf={kernelName:M.o0g,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,s]=t,r=(0,Vn.p)(e,0);return{x:()=>(0,qt.a)(r,n,(0,Y.d)(n,s)),alpha:()=>{let a=(0,qt.a)(r,(0,_e.P)(n),(0,Y.d)(n,e));const i=(0,Ne.getReductionAxes)(s.shape,n.shape);return i.length>0&&(a=(0,Te.S)(a,i)),(0,se.X)(a,s.shape)}}}};var xa=R(233);const Mf={kernelName:M.DlI,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{axis:r}=e;let a=[];return a=null==r?s.shape.map((i,o)=>o):"number"==typeof r?[r]:r,{x:()=>function Bf(n,t,e){const s=n.shape.length,r=s-e.length,a=Zt.Q3(e,s);let i=n;null!=a&&(i=(0,yn.p)(n,a));const o=i.shape.slice(),c=o.splice(s-e.length,e.length).reduce((h,f)=>h*f,1);o.push(c);let p=function Vf(n,t,e){const s=n.shape.slice();s[e]=1;const r=(0,se.X)(t,s),a=(0,xa.$)(n,e,!0,!1),i=(0,xa.$)(n,e,!0,!0),o=(0,Y.d)(a,i);return(0,Y.d)(r,o)}(i.reshape(o),t,r);if(p=p.reshape(i.shape),null!=a){const h=Zt.LJ(a);p=(0,yn.p)(p,h)}return p}(s,n,a)}}},Wf={kernelName:M.oHH,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne.assertAndGetBroadcastShape(e.shape,s.shape);return{a:()=>{const o=(0,Le.h)(n,(0,de.p)(s,"float32")),u=Ne.getReductionAxes(e.shape,r);return u.length>0?(0,se.X)((0,Te.S)(o,u),e.shape):o},b:()=>{let o=(0,Y.d)(n,(0,de.p)(e,"float32"));const u=Ne.getReductionAxes(s.shape,r);u.length>0&&(o=(0,se.X)((0,Te.S)(o,u),s.shape));const c=(0,qe.h)(s);return(0,pt.W)((0,Le.h)(o,(0,de.p)(c,"float32")))}}}},Gf={kernelName:M.$HU,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,pt.W)((0,qe.h)(e)))}}},Uf={kernelName:M.SbG,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,s=(0,Y.d)((0,Ps.z)(e,6),(0,zs.N)(e));return{x:()=>(0,Y.d)(n,(0,de.p)(s,"float32"))}}},Hf={kernelName:M.qkr,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,(0,de.p)((0,zs.N)(e),"float32"))}}},jf={kernelName:M.HZH,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,se.X)(n,e.shape)}}},Xf={kernelName:M._Yw,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>Ct.BV.runKernel(M.zbQ,r,e)}}},Kf={kernelName:M.dpD,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[s]=t,r={dy:n,images:s};return{images:()=>Ct.BV.runKernel(M.Hmb,r,e)}}};var $o=R(7661);const qf={kernelName:M.mKl,gradFunc:(n,t,e)=>{const{dims:s}=e,r=(0,fe.EC)(s,n.shape);return{x:()=>(0,$o.G)(n,r)}}},Zf={kernelName:M.e07,gradFunc:n=>({x:()=>(0,_e.P)(n)})},Yf={kernelName:M.bV0,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,pt.W)((0,Le.h)(n,(0,Y.d)((0,ya.s)(e,1.5),2)))}}};var Eo=R(5280);const Qf={kernelName:M.PhF,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>(0,de.p)((0,_e.P)(e),"float32"),t:()=>(0,Y.d)(n,(0,de.p)(e,n.dtype)),e:()=>(0,Y.d)(n,(0,de.p)((0,Eo.h)(e),n.dtype))}}};var _o=R(287);const Jf={kernelName:M.oFR,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const s=(0,Vn.p)(e,(0,Ke.i)(0)),r=(0,Ke.i)(_o.y),a=(0,Ke.i)(_o.$),i=(0,Y.d)(n,a),o=(0,Y.d)((0,Y.d)(n,r),(0,is.Q)((0,de.p)(e,"float32")));return(0,qt.a)(s,i,o)}}}},em={kernelName:M.a5O,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,(0,Y.d)(e,(0,it.l)((0,Ke.i)(1),e)))}}},tm={kernelName:M.i5y,gradFunc:n=>({x:()=>(0,_e.P)(n)})};var ba=R(1588);const nm={kernelName:M.RQH,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)((0,ba.m)((0,de.p)(e,"float32")),n)}}};var Fo=R(3538);const sm={kernelName:M.wYB,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)((0,Fo.f)((0,de.p)(e,"float32")),n)}}};var Oo=R(1824),rm=R(4361);const am={kernelName:M.p2w,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{begin:r,size:a}=e,i=s.shape,[o,u]=(0,rm.parseSliceParams)(s,r,a),c=[];for(let d=0;d<n.rank;d++)c.push([o[d],i[d]-o[d]-u[d]]);return{x:()=>(0,Oo.v)(n,c)}}},im={kernelName:M.Gcp,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[s]=t,{dim:r}=e,i=(0,Y.d)(n,s);return{logits:()=>(0,it.l)(i,(0,Y.d)((0,Te.S)(i,[r],!0),s))}}};var zo=R(4655);const om={kernelName:M.MRv,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,(0,zo.X)(e))}}};var Lo=R(1601);const Po={kernelName:M.TQc,gradFunc:(n,t,e)=>{const{blockShape:s,paddings:r}=e;return{x:()=>(0,Lo.E)(n,s,r)}}};var Vo=R(4664);const Bo={kernelName:M.L8s,gradFunc:(n,t,e)=>{const{axis:s}=e;return{x:()=>(0,Vo.z)(n,s)}}},lm={kernelName:M.FKq,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,Y.d)((0,Ln._)((0,de.p)(e,"float32")),2))}}},um={kernelName:M.bK0,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)(n,(0,Y.d)((0,de.p)(e,"float32"),2))}}},cm={kernelName:M._tC,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=(0,Ke.i)(2);return{a:()=>(0,Y.d)(n,(0,Y.d)(r,(0,it.l)(e,s))),b:()=>(0,Y.d)(n,(0,Y.d)(r,(0,it.l)(s,e)))}}},dm={kernelName:M.h8e,gradFunc:n=>({x:()=>(0,_e.P)(n)})},pm={kernelName:M.Tr8,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,s]=t,r=Ne.assertAndGetBroadcastShape(e.shape,s.shape);return{a:()=>{let o=n;const u=Ne.getReductionAxes(e.shape,r);return u.length>0&&(o=(0,Te.S)(o,u)),(0,se.X)(o,e.shape)},b:()=>{let o=n;const u=Ne.getReductionAxes(s.shape,r);return u.length>0&&(o=(0,Te.S)(o,u)),(0,se.X)((0,pt.W)(o),s.shape)}}}},hm={kernelName:M.GBy,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,r=s.shape.slice(),{axis:a}=e;(0,fe.EC)(a,s.shape).forEach(c=>{r[c]=1});const o=(0,se.X)(n,r),u=(0,Y.d)(o,(0,ga.i)(s.shape,"float32"));return{x:()=>u}}},fm={kernelName:M.sEM,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Le.h)(n,(0,qe.h)((0,ba.m)(e)))}}},mm={kernelName:M.MIZ,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>(0,Y.d)((0,it.l)((0,Ke.i)(1),(0,qe.h)(e)),n)}}},gm={kernelName:M.n9L,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[s]=t,{reps:r}=e;return{x:()=>{let i=(0,_e.P)(s);if(1===s.rank)for(let o=0;o<r[0];++o)i=(0,bt.I)(i,(0,xn.t)(n,[o*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)i=(0,bt.I)(i,(0,xn.t)(n,[o*s.shape[0],u*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let c=0;c<r[2];++c)i=(0,bt.I)(i,(0,xn.t)(n,[o*s.shape[0],u*s.shape[1],c*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let o=0;o<r[0];++o)for(let u=0;u<r[1];++u)for(let c=0;c<r[2];++c)for(let d=0;d<r[3];++d)i=(0,bt.I)(i,(0,xn.t)(n,[o*s.shape[0],u*s.shape[1],c*s.shape[2],d*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return i}}}},ym={kernelName:M.G3Y,gradFunc:(n,t,e)=>{const s=e,{perm:r}=s,a=Zt.LJ(r);return{x:()=>(0,yn.p)(n,a)}}};var Mo=R(1440);const xm={kernelName:M.ToN,gradFunc:(n,t,e)=>{const s=e,{axis:r}=s;return{value:()=>(0,Mo.k)(n,r)}}};var Wo=R(8457),Go=R(8181),Uo=R(8060);const bm={kernelName:M.Qvg,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>function Cm(n,t){const e=(0,Uo.g)(t,(0,_e.P)(t)),s=(0,Go.I)(n,e);let r=(0,Ls.b)(t,(0,Ke.i)(0,"int32"));const a=s.rank-r.rank;for(let o=0;o<a;++o)r=(0,Wo.d)(r,o+1);r=(0,ma.H)(r,(0,ga.i)(s.shape,"bool"));const i=(0,_e.P)(s);return(0,qt.a)(r,s,i)}(n,e)}}},vm={kernelName:M.RuY,gradFunc:n=>({x:()=>(0,_e.P)(n)})};var Sm=R(8415);const Im=[uo,dh,ph,hh,fh,mh,gh,yh,xh,bh,Ch,vh,wh,kh,Rh,Ah,Dh,$h,Eh,_h,Fh,Oh,Ph,Lh,Wh,Gh,Uh,Hh,Kh,qh,Wf,Zh,Yh,Qh,Jh,ef,sf,nf,rf,af,of,lf,uf,cf,df,pf,hf,ff,mf,xf,No,No,bf,Sf,Nf,Tf,kf,Rf,Af,Df,$f,Ef,Ff,Of,zf,Ao,Ao,Lf,Pf,Mf,Gf,Uf,Hf,jf,Xf,Kf,qf,Zf,Yf,Qf,Jf,em,tm,nm,sm,am,im,om,Po,Po,Bo,Bo,lm,cm,um,dm,pm,hm,fm,mm,gm,ym,xm,bm,vm];for(const n of Im)(0,Sm.Li)(n);var wm=R(2992),E=R(8106);(0,E.t3)().prototype.abs=function(){return this.throwIfDisposed(),(0,wm.W)(this)};var Nm=R(2485);(0,E.t3)().prototype.acos=function(){return this.throwIfDisposed(),(0,Nm.K)(this)};var Tm=R(6725);(0,E.t3)().prototype.acosh=function(){return this.throwIfDisposed(),(0,Tm._)(this)},(0,E.t3)().prototype.add=function(n){return this.throwIfDisposed(),(0,bt.I)(this,n)};var km=R(4187);(0,E.t3)().prototype.all=function(n,t){return this.throwIfDisposed(),(0,km.$)(this,n,t)};var Rm=R(2247);(0,E.t3)().prototype.any=function(n,t){return this.throwIfDisposed(),(0,Rm.Y)(this,n,t)};var Am=R(1257);(0,E.t3)().prototype.argMax=function(n){return this.throwIfDisposed(),(0,Am.N)(this,n)};var Dm=R(1019);(0,E.t3)().prototype.argMin=function(n){return this.throwIfDisposed(),(0,Dm.v)(this,n)},(0,E.t3)().prototype.asScalar=function(){return this.throwIfDisposed(),(0,fe.hu)(1===this.size,()=>"The array must have only 1 element."),(0,se.X)(this,[])},(0,E.t3)().prototype.asType=function(n){return this.throwIfDisposed(),(0,de.p)(this,n)},(0,E.t3)().prototype.as1D=function(){return this.throwIfDisposed(),(0,se.X)(this,[this.size])},(0,E.t3)().prototype.as2D=function(n,t){return this.throwIfDisposed(),(0,se.X)(this,[n,t])},(0,E.t3)().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),(0,se.X)(this,[n,t,e])},(0,E.t3)().prototype.as4D=function(n,t,e,s){return this.throwIfDisposed(),(0,se.X)(this,[n,t,e,s])},(0,E.t3)().prototype.as5D=function(n,t,e,s,r){return this.throwIfDisposed(),(0,se.X)(this,[n,t,e,s,r])};var $m=R(7194);(0,E.t3)().prototype.asin=function(){return this.throwIfDisposed(),(0,$m.Z)(this)};var Em=R(231);(0,E.t3)().prototype.asinh=function(){return this.throwIfDisposed(),(0,Em.V)(this)};var _m=R(1282);(0,E.t3)().prototype.atan=function(){return this.throwIfDisposed(),(0,_m.z)(this)};var Fm=R(9851);(0,E.t3)().prototype.atan2=function(n){return this.throwIfDisposed(),(0,Fm.f)(this,n)};var Om=R(9776);(0,E.t3)().prototype.atanh=function(){return this.throwIfDisposed(),(0,Om.C)(this)};var zm=R(282);(0,E.t3)().prototype.avgPool=function(n,t,e,s){return this.throwIfDisposed(),(0,zm.w)(this,n,t,e,s)},(0,E.t3)().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),(0,Lo.E)(this,n,t)};var Lm=R(5707);(0,E.t3)().prototype.batchNorm=function(n,t,e,s,r){return this.throwIfDisposed(),(0,Lm.t)(this,n,t,e,s,r)};var Pm=R(6172);(0,E.t3)().prototype.broadcastTo=function(n){return this.throwIfDisposed(),(0,Pm.U)(this,n)},(0,E.t3)().prototype.cast=function(n){return this.throwIfDisposed(),(0,de.p)(this,n)};var Vm=R(9249);(0,E.t3)().prototype.ceil=function(){return this.throwIfDisposed(),(0,Vm.m)(this)};var Bm=R(1935);(0,E.t3)().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),(0,Bm.i)(this,n,t)},(0,E.t3)().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof E.es&&(n=[n]),(0,Vo.z)([this,...n],t)};var Mm=R(7182);(0,E.t3)().prototype.conv1d=function(n,t,e,s,r,a){return this.throwIfDisposed(),(0,Mm.P)(this,n,t,e,s,r,a)};var Wm=R(9053);(0,E.t3)().prototype.conv2dTranspose=function(n,t,e,s,r){return this.throwIfDisposed(),(0,Wm.b)(this,n,t,e,s,r)},(0,E.t3)().prototype.conv2d=function(n,t,e,s,r,a){return this.throwIfDisposed(),(0,fo.T)(this,n,t,e,s,r,a)},(0,E.t3)().prototype.cos=function(){return this.throwIfDisposed(),(0,ba.m)(this)},(0,E.t3)().prototype.cosh=function(){return this.throwIfDisposed(),(0,Fo.f)(this)},(0,E.t3)().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),(0,xa.$)(this,n,t,e)},(0,E.t3)().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),(0,yo.z)(this,n,t,e)};var Gm=R(8663);(0,E.t3)().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),(0,Gm.n)(this,n,t)};var Um=R(2514);(0,E.t3)().prototype.depthwiseConv2d=function(n,t,e,s,r,a){return this.throwIfDisposed(),(0,Um.B)(this,n,t,e,s,r,a)};var Hm=R(7501);(0,E.t3)().prototype.dilation2d=function(n,t,e,s,r){return this.throwIfDisposed(),(0,Hm.W)(this,n,t,e,s,r)};var jm=R(8464);(0,E.t3)().prototype.divNoNan=function(n){return this.throwIfDisposed(),(0,jm.N)(this,n)},(0,E.t3)().prototype.div=function(n){return this.throwIfDisposed(),(0,Le.h)(this,n)};var Xm=R(4258);(0,E.t3)().prototype.dot=function(n){return this.throwIfDisposed(),(0,Xm.A)(this,n)};var Km=R(6818);(0,E.t3)().prototype.elu=function(){return this.throwIfDisposed(),(0,Km.p)(this)},(0,E.t3)().prototype.equal=function(n){return this.throwIfDisposed(),(0,Io.D)(this,n)};var qm=R(450);(0,E.t3)().prototype.erf=function(){return this.throwIfDisposed(),(0,qm.q)(this)};var Zm=R(2592);(0,E.t3)().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),(0,Zm.d)(this,n,t)},(0,E.t3)().prototype.exp=function(){return this.throwIfDisposed(),(0,is.Q)(this)},(0,E.t3)().prototype.expandDims=function(n){return this.throwIfDisposed(),(0,Wo.d)(this,n)};var Ym=R(5914);(0,E.t3)().prototype.expm1=function(){return this.throwIfDisposed(),(0,Ym.t)(this)};var Qm=R(5008);(0,E.t3)().prototype.fft=function(){return this.throwIfDisposed(),(0,Qm.k)(this)},(0,E.t3)().prototype.flatten=function(){return this.throwIfDisposed(),(0,se.X)(this,[this.size])},(0,E.t3)().prototype.floor=function(){return this.throwIfDisposed(),(0,ko.G)(this)};var Jm=R(4404);(0,E.t3)().prototype.floorDiv=function(n){return this.throwIfDisposed(),(0,Jm.q)(this,n)},(0,E.t3)().prototype.gather=function(n,t,e){return this.throwIfDisposed(),(0,Go.I)(this,n,t,e)},(0,E.t3)().prototype.greaterEqual=function(n){return this.throwIfDisposed(),(0,Ls.b)(this,n)},(0,E.t3)().prototype.greater=function(n){return this.throwIfDisposed(),(0,Vn.p)(this,n)};var eg=R(1132);(0,E.t3)().prototype.ifft=function(){return this.throwIfDisposed(),(0,eg.S)(this)};var tg=R(3176);(0,E.t3)().prototype.irfft=function(){return this.throwIfDisposed(),(0,tg.w)(this)};var ng=R(870);(0,E.t3)().prototype.isFinite=function(){return this.throwIfDisposed(),(0,ng.x)(this)};var sg=R(8620);(0,E.t3)().prototype.isInf=function(){return this.throwIfDisposed(),(0,sg.U)(this)};var rg=R(1491);(0,E.t3)().prototype.isNaN=function(){return this.throwIfDisposed(),(0,rg.i)(this)};var ag=R(8476);(0,E.t3)().prototype.leakyRelu=function(n){return this.throwIfDisposed(),(0,ag.h)(this,n)},(0,E.t3)().prototype.lessEqual=function(n){return this.throwIfDisposed(),(0,Ps.z)(this,n)},(0,E.t3)().prototype.less=function(n){return this.throwIfDisposed(),(0,To.d)(this,n)};var ig=R(5455);(0,E.t3)().prototype.localResponseNormalization=function(n,t,e,s){return this.throwIfDisposed(),(0,ig.G)(this,n,t,e,s)};var og=R(6071);(0,E.t3)().prototype.logSigmoid=function(){return this.throwIfDisposed(),(0,og.e)(this)};var lg=R(2803);(0,E.t3)().prototype.logSoftmax=function(n){return this.throwIfDisposed(),(0,lg.C)(this,n)};var ug=R(4494);(0,E.t3)().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),(0,ug.l)(this,n,t)},(0,E.t3)().prototype.log=function(){return this.throwIfDisposed(),(0,Do.c)(this)};var cg=R(6357);(0,E.t3)().prototype.log1p=function(){return this.throwIfDisposed(),(0,cg.K)(this)},(0,E.t3)().prototype.logicalAnd=function(n){return this.throwIfDisposed(),(0,ma.H)(this,n)},(0,E.t3)().prototype.logicalNot=function(){return this.throwIfDisposed(),(0,Eo.h)(this)};var dg=R(4712);(0,E.t3)().prototype.logicalOr=function(n){return this.throwIfDisposed(),(0,dg.K)(this,n)};var pg=R(694);(0,E.t3)().prototype.logicalXor=function(n){return this.throwIfDisposed(),(0,pg.e)(this,n)},(0,E.t3)().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),(0,Bt.O)(this,n,t,e)};var hg=R(7542);(0,E.t3)().prototype.maxPool=function(n,t,e,s){return this.throwIfDisposed(),(0,hg._)(this,n,t,e,s)};var fg=R(8890);(0,E.t3)().prototype.max=function(n,t){return this.throwIfDisposed(),(0,fg.F)(this,n,t)},(0,E.t3)().prototype.maximum=function(n){return this.throwIfDisposed(),(0,Uo.g)(this,n)};var mg=R(317);(0,E.t3)().prototype.mean=function(n,t){return this.throwIfDisposed(),(0,mg.J)(this,n,t)};var gg=R(2451);(0,E.t3)().prototype.min=function(n,t){return this.throwIfDisposed(),(0,gg.V)(this,n,t)};var yg=R(1563);(0,E.t3)().prototype.minimum=function(n){return this.throwIfDisposed(),(0,yg.L)(this,n)};var xg=R(4326);(0,E.t3)().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),(0,xg.V)(this,n,t)};var bg=R(3832);(0,E.t3)().prototype.mod=function(n){return this.throwIfDisposed(),(0,bg.w)(this,n)},(0,E.t3)().prototype.mul=function(n){return this.throwIfDisposed(),(0,Y.d)(this,n)},(0,E.t3)().prototype.neg=function(){return this.throwIfDisposed(),(0,pt.W)(this)};var Cg=R(8788);(0,E.t3)().prototype.norm=function(n,t,e){return this.throwIfDisposed(),(0,Cg.K)(this,n,t,e)};var vg=R(2684);(0,E.t3)().prototype.notEqual=function(n){return this.throwIfDisposed(),(0,vg.Q)(this,n)};var Sg=R(8598);(0,E.t3)().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),(0,Sg.l)(this,n,t,e)};var Ig=R(3583);(0,E.t3)().prototype.onesLike=function(){return this.throwIfDisposed(),(0,Ig.J)(this)},(0,E.t3)().prototype.pad=function(n,t){return this.throwIfDisposed(),(0,Oo.v)(this,n,t)};var wg=R(5415);(0,E.t3)().prototype.pool=function(n,t,e,s,r,a){return this.throwIfDisposed(),(0,wg.d)(this,n,t,e,s,r,a)},(0,E.t3)().prototype.pow=function(n){return this.throwIfDisposed(),(0,ya.s)(this,n)};var Ng=R(4845);(0,E.t3)().prototype.prelu=function(n){return this.throwIfDisposed(),(0,Ng.A)(this,n)};var Tg=R(9357);(0,E.t3)().prototype.prod=function(n,t){return this.throwIfDisposed(),(0,Tg.W)(this,n,t)};var kg=R(9372);(0,E.t3)().prototype.reciprocal=function(){return this.throwIfDisposed(),(0,kg.M)(this)};var Rg=R(2047);(0,E.t3)().prototype.relu=function(){return this.throwIfDisposed(),(0,Rg.U)(this)};var Ag=R(1095);(0,E.t3)().prototype.relu6=function(){return this.throwIfDisposed(),(0,Ag.b)(this)},(0,E.t3)().prototype.reshapeAs=function(n){return this.throwIfDisposed(),(0,se.X)(this,n.shape)},(0,E.t3)().prototype.reshape=function(n){return this.throwIfDisposed(),(0,se.X)(this,n)};var Dg=R(4849);(0,E.t3)().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),(0,Dg.I)(this,n,t,e)};var $g=R(2653);(0,E.t3)().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),(0,$g.j)(this,n,t,e)},(0,E.t3)().prototype.reverse=function(n){return this.throwIfDisposed(),(0,$o.G)(this,n)};var Eg=R(4636);(0,E.t3)().prototype.rfft=function(){return this.throwIfDisposed(),(0,Eg.Q)(this)};var _g=R(2688);(0,E.t3)().prototype.round=function(){return this.throwIfDisposed(),(0,_g.N)(this)},(0,E.t3)().prototype.rsqrt=function(){return this.throwIfDisposed(),(0,xo.b)(this)};var Fg=R(5484);(0,E.t3)().prototype.selu=function(){return this.throwIfDisposed(),(0,Fg.U)(this)};var Og=R(6020);(0,E.t3)().prototype.separableConv2d=function(n,t,e,s,r,a){return this.throwIfDisposed(),(0,Og.U)(this,n,t,e,s,r,a)},(0,E.t3)().prototype.sigmoid=function(){return this.throwIfDisposed(),(0,zo.X)(this)};var zg=R(184);(0,E.t3)().prototype.sign=function(){return this.throwIfDisposed(),(0,zg.X)(this)},(0,E.t3)().prototype.sin=function(){return this.throwIfDisposed(),(0,mo.O)(this)},(0,E.t3)().prototype.sinh=function(){return this.throwIfDisposed(),(0,go.R)(this)},(0,E.t3)().prototype.slice=function(n,t){return this.throwIfDisposed(),(0,xn.t)(this,n,t)};var Lg=R(2187);(0,E.t3)().prototype.softmax=function(n){return this.throwIfDisposed(),(0,Lg.X)(this,n)};var Pg=R(7246);(0,E.t3)().prototype.softplus=function(){return this.throwIfDisposed(),(0,Pg.W)(this)},(0,E.t3)().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),(0,co.f)(this,n,t)},(0,E.t3)().prototype.split=function(n,t){return this.throwIfDisposed(),(0,po.V)(this,n,t)},(0,E.t3)().prototype.sqrt=function(){return this.throwIfDisposed(),(0,Ln._)(this)},(0,E.t3)().prototype.square=function(){return this.throwIfDisposed(),(0,qe.h)(this)};var Vg=R(3629);(0,E.t3)().prototype.squaredDifference=function(n){return this.throwIfDisposed(),(0,Vg.$)(this,n)};var Bg=R(6458);(0,E.t3)().prototype.squeeze=function(n){return this.throwIfDisposed(),(0,Bg.L)(this,n)},(0,E.t3)().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof E.es?[this,n]:[this,...n];return(0,Mo.k)(e,t)},(0,E.t3)().prototype.step=function(n){return this.throwIfDisposed(),(0,zs.N)(this,n)};var Mg=R(92);(0,E.t3)().prototype.stridedSlice=function(n,t,e,s,r,a,i,o){return this.throwIfDisposed(),(0,Mg.N)(this,n,t,e,s,r,a,i,o)},(0,E.t3)().prototype.sub=function(n){return this.throwIfDisposed(),(0,it.l)(this,n)},(0,E.t3)().prototype.sum=function(n,t){return this.throwIfDisposed(),(0,Te.S)(this,n,t)};var Wg=R(3992);(0,E.t3)().prototype.tan=function(){return this.throwIfDisposed(),(0,Wg.O)(this)};var Gg=R(8892);(0,E.t3)().prototype.tanh=function(){return this.throwIfDisposed(),(0,Gg.A)(this)},(0,E.t3)().prototype.tile=function(n){return this.throwIfDisposed(),(0,bo.G)(this,n)},(0,E.t3)().prototype.toBool=function(){return this.throwIfDisposed(),(0,de.p)(this,"bool")},(0,E.t3)().prototype.toFloat=function(){return this.throwIfDisposed(),(0,de.p)(this,"float32")},(0,E.t3)().prototype.toInt=function(){return this.throwIfDisposed(),(0,de.p)(this,"int32")};var Ug=R(3187);(0,E.t3)().prototype.topk=function(n,t){return this.throwIfDisposed(),(0,Ug.h)(this,n,t)},(0,E.t3)().prototype.transpose=function(n){return this.throwIfDisposed(),(0,yn.p)(this,n)};var Hg=R(5403);(0,E.t3)().prototype.unique=function(n){return this.throwIfDisposed(),(0,Hg.T)(this,n)},(0,E.t3)().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),(0,Co.p)(this,n,t)},(0,E.t3)().prototype.unstack=function(n){return this.throwIfDisposed(),(0,Ro.H)(this,n)},(0,E.t3)().prototype.where=function(n,t){return this.throwIfDisposed(),(0,qt.a)(n,this,t)},(0,E.t3)().prototype.zerosLike=function(){return this.throwIfDisposed(),(0,_e.P)(this)};class Dt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Dt.prototype)}}class ht extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ht.prototype)}}class k extends Error{constructor(t){super(t),Object.setPrototypeOf(this,k.prototype)}}class oe extends Error{constructor(t){super(t),Object.setPrototypeOf(this,oe.prototype)}}class Ca extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ca.prototype)}}class Ho extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ho.prototype)}}class jo{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=t}}function bn(n,t){if(Array.isArray(n)){let e=[];for(let s=0;s<t;s++)e=e.concat(n);return e}{const e=new Array(t);return e.fill(n),e}}function ot(n,t){if(!n)throw new Ca(t)}function Xo(n,t){let e=0;for(const s of n)s===t&&e++;return e}function et(n){return 1===n.length?n[0]:n}function ve(n){return Array.isArray(n)?n:[n]}function Mt(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==e[0]?e:"private"+e}function Cn(n){return n.length<=1||-1===n.indexOf("_")?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let ft={};function va(n){if(null==n)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function Sa(n){if(null!=n&&"object"==typeof n)if(Array.isArray(n))n.forEach(t=>Sa(t));else{const t=Object.keys(n);for(const e of t){const s=n[e];null!=s&&"object"==typeof s&&(Array.isArray(s)||"ndarray"!==s.type||"number"!=typeof s.value?Sa(s):n[e]=s.value)}}}function os(n,t={},e={},s="object",r=!1){if("string"==typeof n){let i;if(n in e)i=e[n];else if(n in ft)i=ft[n];else if(i=t[n],null==i)throw new k(`Unknown ${s}: ${n}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const a=n;if(null==a.className||null==a.config)throw new k(`${s}: Improper config format: ${JSON.stringify(a)}.\n'className' and 'config' must set.`);const i=a.className;let o,u;if(i in e?[o,u]=e[i]:i in ft?[o,u]=ft.className:i in t&&([o,u]=t[i]),null==o)throw new k(`Unknown ${s}: ${i}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=u){const c={};for(const f of Object.keys(ft))c[f]=ft[f];for(const f of Object.keys(e))c[f]=e[f];a.config.customObjects=c;const p=Object.assign({},ft);for(const f of Object.keys(e))ft[f]=e[f];Sa(a.config);const h=u(o,a.config,e,r);return ft=Object.assign({},p),h}{const c=Object.assign({},ft);for(const p of Object.keys(e))ft[p]=e[p];const d=new o(a.config);return ft=Object.assign({},c),d}}}function Vs(n,t){return-1*function jg(n,t){return n<t?-1:n>t?1:0}(n,t)}function Yt(n){if(null==n)return n;const t=[];for(const e of n)-1===t.indexOf(e)&&t.push(e);return t}function Xg(n){if(null==n)throw new k(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function vn(n,t,e){if(null!=e&&n.indexOf(e)<0)throw new k(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function Ia(n,t,e=0,s=1/0){return ot(e>=0),ot(s>=e),Array.isArray(n)&&n.length>=e&&n.length<=s&&n.every(r=>typeof r===t)}function Ge(n,t){Array.isArray(n)?(l.util.assert(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,s)=>Ge(e,`element ${s+1} of ${t}`))):l.util.assert(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${Ko(n)}.`)}function Ko(n){return null===n?"null":Array.isArray(n)?"["+n.map(t=>Ko(t)).join(",")+"]":"string"==typeof n?`"${n}"`:`${n}`}function qo(n){return"relu"===n?"relu":"linear"===n?"linear":"elu"===n?"elu":null}let qg=0;function Zo(){return qg++}const Bs={};function Ms(n=""){return n in Bs||(Bs[n]=0),Bs[n]+=1,n+Bs[n].toString()}const Zg=["channelsFirst","channelsLast"],Yg=["nearest","bilinear"],Qg=["valid","same","causal"],Jg=["max","avg"],ey=["sum","mul","concat","ave"],Bn=new Map;function Fe(n){vn(Zg,"DataFormat",n)}function lt(n){vn(Qg,"PaddingMode",n)}function Yo(n){vn(Jg,"PoolMode",n)}const ls=[];function Sn(n,t){ls.push(n);try{const e=t();return ls.pop(),e}catch(e){throw ls.pop(),e}}function Jo(n){if(!tl(n))throw new Error("Not a valid tensor name: '"+n+"'");return function ny(){return 0===ls.length?"":ls.join("/")+"/"}()+n}function el(n){if(!tl(n))throw new Error("Not a valid tensor name: '"+n+"'");Bn.has(n)||Bn.set(n,0);const t=Bn.get(n);if(Bn.set(n,Bn.get(n)+1),t>0){const e=`${n}_${t}`;return Bn.set(e,1),e}return n}const sy=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function tl(n){return!!n.match(sy)}function ry(n){return n===parseInt(n.toString(),10)}function Qt(n,t,e){null==t&&(t=0),null==e&&(e=n.length);let s=1;for(let r=t;r<e;++r)s*=n[r];return s}function Mn(n){if(0===n.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s<t&&(t=s)}return t}function Jt(n){if(0===n.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const s=n[e];s>t&&(t=s)}return t}function vt(n,t){if(t<n)throw new k(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let s=n;s<t;++s)e.push(s);return e}let Ws;function Pe(){return null==Ws&&(Ws=(0,l.backend)().epsilon()),Ws}function $t(n,t){return l.cast(n,t)}function us(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),l.reshape(n,e)}function In(n,t,e){return(0,l.tidy)(()=>{switch(n.rank){case 1:return l.slice1d(n,t,e);case 2:return l.slice2d(n,[t,0],[e,n.shape[1]]);case 3:return l.slice3d(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return l.slice4d(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return l.slice(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return l.slice(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new k(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function wa(n,t,e){return(0,l.tidy)(()=>{switch(n.rank){case 1:return l.slice1d(n,t,e);case 2:return l.slice2d(n,[0,t],[n.shape[0],e]);case 3:return l.slice3d(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return l.slice4d(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new k(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Gs(n,t,e,s){return(0,l.tidy)(()=>{switch(n.rank){case 1:return l.slice1d(n,t,e);case 2:switch(s){case 1:return In(n,t,e);case 2:return wa(n,t,e);default:throw new k(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return In(n,t,e);case 2:return l.slice3d(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return wa(n,t,e);default:throw new k(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return In(n,t,e);case 2:return l.slice4d(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return l.slice4d(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return wa(n,t,e);default:throw new k(`The axis is not within the rank of the tensor ${s}`)}default:throw new k(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Na(n,t=-1){let e;return t<0&&(e=n[0].rank,t=0!==e?e:0),t===n[0].rank&&(t=-1),l.concat(n,t)}function sl(n,t){switch(n.rank){case 1:return l.concat1d([n,t]);case 2:return l.concat2d([n,t],0);case 3:return l.concat3d([n,t],0);case 4:return l.concat4d([n,t],0);default:throw new k(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Ta(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new k(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return l.tile(n,t)}function Us(n,t=0,e=1,s,r){return l.randomNormal(n,t,e,s,r)}function Et(n,t,e,s){if(n.rank<2||t.rank<2)throw new oe(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3&&n.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new oe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`);if(2===n.rank&&2===t.rank)return l.fused.matMul({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?ka(n.rank,s,"channelsLast"):null,activation:e});{const r=n.shape.slice(),a=r.pop();n=l.reshape(n,[-1,a]);const i=t.shape.slice(),o=i.pop(),u=i.pop(),c=[...i,o],d=Array.from({length:t.rank},(m,y)=>0===y?t.rank-2:y<=t.rank-2?y-1:y);t=l.reshape(l.transpose(t,d),[u,-1]);const p=[...r,...c];return l.reshape(l.fused.matMul({a:n,b:t,transposeA:!1,transposeB:!1,bias:s?ka(n.rank,s,"channelsLast"):null,activation:e}),p)}}function rl(n,t,e){return(0,l.tidy)(()=>(t=Array.isArray(t)?(0,l.tensor1d)(t,"int32"):l.cast(t,"int32"),l.gather(n,t,e)))}function cs(n){return l.mul(n,n)}function ka(n,t,e){const s=t.shape;if(1!==t.rank&&t.rank!==n)throw new k(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(5===n){if("channelsFirst"===e)return l.reshape(t,1===s.length?[1,s[0],1,1,1]:[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===e)return l.reshape(t,1===s.length?[1,1,1,1,s[0]]:[1].concat(s))}else if(4===n){if("channelsFirst"===e)return l.reshape(t,1===s.length?[1,s[0],1,1]:[1,s[2],s[0],s[1]]);if("channelsLast"===e)return l.reshape(t,1===s.length?[1,1,1,s[0]]:[1].concat(s))}else if(3===n){if("channelsFirst"===e)return l.reshape(t,1===s.length?[1,s[0],1]:[1,s[1],s[0]]);if("channelsLast"===e)return l.reshape(t,1===s.length?[1,1,s[0]]:[1].concat(s))}else if(n<3)return t;throw new k(`Unsupported input rank by biasAdd: ${t.rank}`)}function It(n,t,e){return(0,l.tidy)(()=>(null==e&&(e="channelsLast"),Fe(e),l.add(n,ka(n.rank,t,e))))}function al(n,t,e,s){return(0,l.tidy)(()=>l.dropout(n,t,e,s))}function ds(n,t,e=!1){return e?n():t()}const hy=["fanIn","fanOut","fanAvg"],fy=["normal","uniform","truncatedNormal"];class mt extends l.serialization.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}l.serialization.registerClass((()=>{class n extends mt{apply(e,s){return(0,l.zeros)(e,s)}}return n.className="Zeros",n})());let il=(()=>{class n extends mt{apply(e,s){return(0,l.ones)(e,s)}}return n.className="Ones",n})();l.serialization.registerClass(il),l.serialization.registerClass((()=>{class n extends mt{constructor(e){if(super(),"object"!=typeof e)throw new k(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new k(`config must have value set but got ${e}`);this.value=e.value}apply(e,s){return(0,l.tidy)(()=>(0,l.mul)((0,l.scalar)(this.value),(0,l.ones)(e,s)))}getConfig(){return{value:this.value}}}return n.className="Constant",n})()),l.serialization.registerClass((()=>{class n extends mt{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,s){return(0,l.randomUniform)(e,this.minval,this.maxval,s,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}return n.className="RandomUniform",n})()),l.serialization.registerClass((()=>{class n extends mt{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new oe(`randomNormal does not support dType ${s}.`);return Us(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="RandomNormal",n})()),l.serialization.registerClass((()=>{class n extends mt{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,s){if("float32"!==(s=s||"float32")&&"int32"!==s)throw new oe(`truncatedNormal does not support dType ${s}.`);return(0,l.truncatedNormal)(e,this.mean,this.stddev,s,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}return n.className="TruncatedNormal",n})()),l.serialization.registerClass((()=>{class n extends mt{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,s){return(0,l.tidy)(()=>{if(2!==e.length||e[0]!==e[1])throw new k("Identity matrix initializer can only be used for 2D square matrices.");return(0,l.mul)(this.gain,(0,l.eye)(e[0]))})}getConfig(){return{gain:this.gain}}}return n.className="Identity",n})());let ut=(()=>{class n extends mt{constructor(e){if(super(),e.scale<0)throw new k(`scale must be a positive float. Got: ${e.scale}`);this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,function my(n){vn(hy,"FanMode",n)}(this.mode),this.distribution=null==e.distribution?"normal":e.distribution,function gy(n){vn(fy,"Distribution",n)}(this.distribution),this.seed=e.seed}apply(e,s){const r=function Iy(n,t="channelsLast"){let e,s;if(Fe(t),2===n.length)e=n[0],s=n[1];else if(-1!==[3,4,5].indexOf(n.length)){if("channelsFirst"===t){const r=Qt(n,2);e=n[1]*r,s=n[0]*r}else if("channelsLast"===t){const r=Qt(n,0,n.length-2);e=n[n.length-2]*r,s=n[n.length-1]*r}}else{const r=Qt(n);e=Math.sqrt(r),s=Math.sqrt(r)}return[e,s]}(e),a=r[0],i=r[1];let o=this.scale;if(o/="fanIn"===this.mode?Math.max(1,a):"fanOut"===this.mode?Math.max(1,i):Math.max(1,(a+i)/2),"normal"===this.distribution){const u=Math.sqrt(o);if("float32"!==(s=s||"float32")&&"int32"!==s)throw new oe(`${this.getClassName()} does not support dType ${s}.`);return(0,l.truncatedNormal)(e,0,u,s,this.seed)}{const u=Math.sqrt(3*o);return(0,l.randomUniform)(e,-u,u,s,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}return n.className="VarianceScaling",n})();l.serialization.registerClass(ut);let ol=(()=>{class n extends ut{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ut.className}}return n.className="GlorotUniform",n})();l.serialization.registerClass(ol);let ll=(()=>{class n extends ut{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ut.className}}return n.className="GlorotNormal",n})();l.serialization.registerClass(ll);let ul=(()=>{class n extends ut{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ut.className}}return n.className="HeNormal",n})();l.serialization.registerClass(ul);let cl=(()=>{class n extends ut{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ut.className}}return n.className="HeUniform",n})();l.serialization.registerClass(cl);let dl=(()=>{class n extends ut{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return ut.className}}return n.className="LeCunNormal",n})();l.serialization.registerClass(dl);let pl=(()=>{class n extends ut{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return ut.className}}return n.className="LeCunUniform",n})();l.serialization.registerClass(pl);let wy=(()=>{class n extends mt{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,s){return(0,l.tidy)(()=>{if(e.length<2)throw new oe("Shape must be at least 2D.");if("int32"!==s&&"float32"!==s&&void 0!==s)throw new TypeError(`Unsupported data type ${s}.`);const r=l.util.sizeFromShape(e.slice(0,-1)),a=e[e.length-1],i=r*a;i>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${i}) elements: Slowness may result.`);const u=Us([Math.max(a,r),Math.min(a,r)],0,1,s,this.seed),c=l.linalg.qr(u,!1);let d=c[0];const h=c[1].flatten().stridedSlice([0],[Math.min(a,r)*Math.min(a,r)],[Math.min(a,r)+1]);return d=(0,l.mul)(d,h.sign()),r<a&&(d=d.transpose()),(0,l.mul)((0,l.scalar)(this.gain),d.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}return n.className="Orthogonal",n})();l.serialization.registerClass(wy);const hl={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function fl(n,t={}){return os(n,l.serialization.SerializationMap.getMap().classNameMap,t,"initializer")}function De(n){return va(n)}function ke(n){if("string"==typeof n){const t=n in hl?hl[n]:n;if("GlorotNormal"===t)return new ll;if("GlorotUniform"===t)return new ol;if("HeNormal"===t)return new ul;if("HeUniform"===t)return new cl;if("LeCunNormal"===t)return new dl;if("LeCunUniform"===t)return new pl;{const e={};return e.className=t,e.config={},fl(e)}}return n instanceof mt?n:fl(n)}function Ra(n){return Array.isArray(n)&&Array.isArray(n[0])}function Hs(n){return 0===n.length?[]:Array.isArray(n[0])?n:[n]}function ie(n){let t;if(Array.isArray(n)){if(1!==n.length)throw new k(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function he(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(1===n.length)return n[0];throw new k(`Expected exactly 1 Shape; got ${n.length}`)}return n}function js(n){let t=0;for(const e of n)t+=0===e.shape.length?1:e.shape.reduce((s,r)=>s*r);return t}const ml="Variable";class _t{constructor(t,e="float32",s=ml,r=!0,a=null){this.dtype=e??"float32",this.shape=t.shape,this.id=Zo(),this.originalName=Jo(s=s??ml),this.name=el(this.originalName),this.trainable_=r,this.constraint=a,this.val=l.variable(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),function Ny(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,t),this.val.id!==t.id&&(this.val.assign(t),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Aa(n){return n.map(t=>t.read())}function Da(n){n.forEach(t=>{t[0].write(t[1])})}class Ve{constructor(t){this.dtype=t.dtype,this.shape=t.shape,this.ndim=null!=t.shape?t.shape.length:t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Ft{constructor(t,e,s,r,a,i,o){this.dtype=t,this.shape=e,this.sourceLayer=s,this.inputs=r,this.callArgs=a,this.outputTensorIndex=o,this.id=Zo(),null!=i&&(this.originalName=Jo(i),this.name=el(this.originalName)),this.rank=e.length}}let Ty=0;class Xs{constructor(t,e){this.callArgs=e,this.id=Ty++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const s of t.inboundLayers)s?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)t.push(null!=e?e.name:null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let ky=0;class ue extends l.serialization.Serializable{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=ky++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const s=this.getClassName();e=Mt(s)+"_"+Ms(s)}if(this.name=e,this.trainable_=null==t.trainable||t.trainable,null!=t.inputShape||null!=t.batchInputShape){let s;if(null!=t.batchInputShape)s=t.batchInputShape;else if(null!=t.inputShape){let a=null;null!=t.batchSize&&(a=t.batchSize),s=[a].concat(t.inputShape)}this.batchInputShape=s;let r=t.dtype;null==r&&(r=t.inputDType),null==r&&(r="float32"),this.dtype=r}this.initialWeights=null!=t.weights?t.weights:null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(0===this.inboundNodes.length)throw new ht(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new k(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return et(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return et(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Dt(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Dt(`Layer ${this.name} is not connected, no input to return.`);return et(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Dt(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Dt(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return et(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=ve(t),null==this.inputSpec||0===this.inputSpec.length)return;const e=ve(this.inputSpec);if(t.length!==e.length)throw new k(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let s=0;s<t.length;s++){const r=t[s],a=e[s];if(null==a)continue;const i=r.rank;if(null!=a.ndim&&i!==a.ndim)throw new k(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(null!=a.maxNDim&&i>a.maxNDim)throw new k(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(null!=a.minNDim&&i<a.minNDim)throw new k(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(null!=a.dtype&&r.dtype!==a.dtype)throw new k(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${r.dtype}.`);if(a.axes){const o=r.shape;for(const u in a.axes){const c=Number(u),d=a.axes[u];if(null!=d&&-1===[d,null].indexOf(c>=0?o[c]:o[o.length+c]))throw new k(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${o}.`)}}if(null!=a.shape)for(let o=0;o<a.shape.length;++o){const u=a.shape[o],c=r.shape[o];if(null!=u&&null!=c&&u!==c)throw new k(`Input ${s} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${r.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){null!=this._callHook&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const s=ve(t);let r=!0;for(const i of s)if(!(i instanceof Ft)){r=!1;break}let a=!0;for(const i of s)if(i instanceof Ft){a=!1;break}if(r===a)throw new k("Arguments to apply() must be all SymbolicTensors or all Tensors");return Sn(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const o of ve(t))i.push(o.shape);this.build(et(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let i=this.call(t,e);const o=ve(i),u=[];for(let c of o)-1!==s.indexOf(c)&&(c=c.clone()),u.push(c);if(i=et(u),null!=this.activityRegularizer)throw new oe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}{const i=function Ry(n){n=ve(n);const t=[];for(const e of n)t.push(e.shape);return et(t)}(t),o=this.computeOutputShape(i);let u;const c="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),u=null!=o&&o.length>0&&Array.isArray(o[0])?o.map((d,p)=>new Ft(c,d,this,ve(t),e,this.name,p)):new Ft(c,o,this,ve(t),e,this.name),this.addInboundNode(t,u,null,null,i,o,e),this._refCount++,null!=this.activityRegularizer)throw new oe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(null!=this.batchInputShape)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((s,r)=>{null!=s&&null!=t[r]&&t[r]!==s&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Dt(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const s=JSON.stringify(e.outputShapes);-1===t.indexOf(s)&&t.push(s)}if(1===t.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Dt(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ht(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return js(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Aa(t?this.trainableWeights:this.weights)}setWeights(t){(0,l.tidy)(()=>{const e=this.weights;if(e.length!==t.length)throw new k(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(0===e.length)return;const s=[],r=Aa(e);for(let a=0;a<r.length;++a){const i=r[a],o=e[a],u=t[a];if(!l.util.arraysEqual(i.shape,u.shape))throw new k(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);s.push([o,u])}Da(s)})}addWeight(t,e,s,r,a,i,o,u){if(-1!==this._addedWeightNames.indexOf(t))throw new k(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),null==s&&(s="float32"),this.fastWeightInitDuringBuild&&(r=null!=u?u():ke("zeros"));const c=r.apply(e,s),d=new _t(c,s,t,i,o);return c.dispose(),null!=a&&this.addLoss(()=>a.apply(d.read())),null==i&&(i=!0),i?this._trainableWeights.push(d):this._nonTrainableWeights.push(d),d}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){null==t||Array.isArray(t)&&0===t.length||(t=ve(t),null!=this._losses&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(null!=e){if(!Array.isArray(e))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);e.forEach(s=>{if(null!=s)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)})}return null}return e}addInboundNode(t,e,s,r,a,i,o=null){const u=ve(t);e=ve(e),s=ve(s),r=ve(r),a=Hs(a),i=Hs(i);const c=[],d=[],p=[];for(const h of u)c.push(h.sourceLayer),d.push(h.nodeIndex),p.push(h.tensorIndex);new Xs({outboundLayer:this,inboundLayers:c,nodeIndices:d,tensorIndices:p,inputTensors:u,outputTensors:e,inputMasks:s,outputMasks:r,inputShapes:a,outputShapes:i},o);for(let h=0;h<e.length;h++)e[h].sourceLayer=this,e[h].nodeIndex=this.inboundNodes.length-1,e[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(t.batchInputShape=this.batchInputShape),null!=this.dtype&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return 0==--this._refCount&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function gl(n,t,e){if((null==t||null!=e&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),0===t.inboundNodes.length)return[n];{const s=t.inboundNodes[e];if(0===s.inboundLayers.length)return s.inputTensors;{const r=[];for(let a=0;a<s.inboundLayers.length;a++){const c=gl(s.inputTensors[a],s.inboundLayers[a],s.nodeIndices[a]);for(const d of c)-1===r.indexOf(d)&&r.push(d)}return r}}}let ps=(()=>{class n extends ue{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Ms("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new k("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let s=e.batchInputShape;if(null==s){if(null==e.inputShape)throw new k("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");s=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new k("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=s,this.dtype=r,this.inputSpec=[{shape:s}];const a=new Ft(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new Xs({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[s],outputShapes:[s]})}apply(e,s){throw new k(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}return n.className="InputLayer",n})();function yl(n){if(null==n.batchShape&&null==n.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=n.batchShape&&null!=n.shape)throw new k("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;null!=n.shape&&null==t&&(t=[null].concat(n.shape));let e=n.dtype;return null==e&&(e="float32"),new ps({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}l.serialization.registerClass(ps);class en{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof en)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(null==t)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,s){if(null!=this.id2Value[t.id])throw new k(`Duplicate key: name=${t.name}, id=${t.id}`);return this.id2Value[t.id]=function Dy(n,t){if(null==n.dtype||n.dtype===t.dtype)return t;try{return(0,l.cast)(t,n.dtype)}catch{throw new k(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}(t,e),this.name2Id[t.name]=t.id,null!=s&&(this.id2Mask[t.id]=s),this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return null!=this.id2Value[t.id]}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ft){if(null==this.id2Value[t.id])throw new k(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}{const e=this.name2Id[t];if(null==e)throw new k(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof Ft){if(null==this.id2Value[t.id])throw new k(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}{const e=this.name2Id[t];if(null==e)throw new k(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){null!=this.id2Mask&&(0,l.dispose)(this.id2Mask)}}const Ks=new jo,qs=new jo;function hs(n,t,e,s){const r=null!=e&&e.training,a=Array.isArray(n),i=a?n:[n],o=i.map(m=>m.name),u=[],c=t.names();for(const m of o)-1!==c.indexOf(m)?u.push(t.getValue(m)):u.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const d=o.join(",")+"|"+t.names().sort().join(",");let h,p=Ks.get(d);if(null==p){const m=function Ey(n,t){l.util.assert(null!=n&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],s={};if(1===n.length){const r=xl(n[0],t);e=r.sorted,s=r.recipientMap}else{const r=new Set;for(const a of n){const{sorted:i,recipientMap:o}=xl(a,t);for(const u of i)r.has(u.name)||(e.push(u),r.add(u.name));for(const u in o)null==s[u]&&(s[u]=new Set),o[u].forEach(c=>s[u].add(c))}}return{sorted:e,recipientCounts:_y(s)}}(i,t);p=m.sorted,h=m.recipientCounts,Ks.put(d,p),qs.put(d,h)}h={},r||Object.assign(h,qs.get(d));const f=new en(t);for(let m=0;m<p.length;++m){if(null!=s){const D=(0,l.memory)().numTensors;D>s.maxNumTensors&&(s.maxNumTensors=D),D<s.minNumTensors&&(s.minNumTensors=D)}const y=p[m],g=y.sourceLayer;if(g instanceof ps)continue;const x=[],b=[],S=[];let v=!1;for(const D of y.inputs){const A=f.getValue(D),$=f.getMask(D);x.push(A),b.push($),null!=$&&(v=!0),r||(h[D.name]--,0===h[D.name]&&!t.hasKey(D)&&-1===o.indexOf(D.name)&&!A.isDisposed&&!0!==D.sourceLayer.stateful&&S.push(A))}v&&((e=e||{}).mask=b[0]);const I=ve(g.apply(x,e));let w=null;g.supportsMasking&&(w=g.computeMask(x,b));const N=Fy(y),T=Array.isArray(N)?N:[N];for(let D=0;D<T.length;++D){f.hasKey(T[D])||f.add(T[D],I[D],Array.isArray(w)?w[0]:w);const A=o.indexOf(T[D].name);-1!==A&&(u[A]=I[D])}r||(0,l.dispose)(S)}return f.disposeMasks(),a?u:u[0]}function _y(n){const t={};for(const e in n)t[e]=n[e].size;return t}function xl(n,t){const e=new Set,s=[],r={};for(const o of t.names())e.add(o);const a=[],i=[];for(a.push(n);a.length>0;){const o=a[a.length-1];if(e.has(o.name)){a.pop();continue}const u=i[i.length-1]===a.length-1;if(0===o.inputs.length||u)a.pop(),s.push(o),e.add(o.name),u&&i.pop();else{i.push(a.length-1);for(const c of o.inputs)null==r[c.name]&&(r[c.name]=new Set),r[c.name].add(o.name),!e.has(c.name)&&a.push(c)}}return{sorted:s,recipientMap:r}}function Fy(n){let t;if(1===n.sourceLayer.inboundNodes.length)t=n.sourceLayer.output;else{let e=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const r of n.sourceLayer.inboundNodes[s].outputTensors)if(r.id===n.id){e=s;break}t=n.sourceLayer.getOutputAt(e)}return t}function $a(n,t){return(0,l.tidy)(()=>l.sqrt(l.sum(l.mul(n,n),t,!0)))}(0,l.env)().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,function $y(n){Ks?.setMaxEntries(n),qs?.setMaxEntries(n)});class fs extends l.serialization.Serializable{getConfig(){return{}}}let Oy=(()=>{class n extends fs{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,l.tidy)(()=>{const s=$a(e,this.axis),r=l.clipByValue(s,0,this.maxValue);return l.mul(e,l.div(r,l.add(Pe(),s)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}return n.className="MaxNorm",n})();l.serialization.registerClass(Oy);let zy=(()=>{class n extends fs{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,l.tidy)(()=>l.div(e,l.add(Pe(),$a(e,this.axis))))}getConfig(){return{axis:this.axis}}}return n.className="UnitNorm",n})();l.serialization.registerClass(zy);let Ly=(()=>{class n extends fs{apply(e){return l.relu(e)}}return n.className="NonNeg",n})();l.serialization.registerClass(Ly);let Py=(()=>{class n extends fs{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return(0,l.tidy)(()=>{const s=$a(e,this.axis),r=l.add(l.mul(this.rate,l.clipByValue(s,this.minValue,this.maxValue)),l.mul(1-this.rate,s));return l.mul(e,l.div(r,l.add(Pe(),s)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}return n.className="MinMaxNorm",n})();l.serialization.registerClass(Py);const bl={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Be(n){return va(n)}function Cl(n,t={}){return os(n,l.serialization.SerializationMap.getMap().classNameMap,t,"constraint")}function Me(n){return null==n?null:"string"==typeof n?Cl({className:n in bl?bl[n]:n,config:{}}):n instanceof fs?n:Cl(n)}var J=R(8239);function tn(n){return Ea.apply(this,arguments)}function Ea(){return(Ea=(0,J.Z)(function*(n){if(null==n)return;const t=[],e=[],s=[];for(const r in n){const a=n[r];if("number"!=typeof a){const i=a;t.push(i.data()),e.push(r),s.push(i)}}if(t.length>0){const r=yield Promise.all(t);for(let a=0;a<r.length;++a)n[e[a]]=r[a][0];(0,l.dispose)(s)}})).apply(this,arguments)}function vl(n){if(null!=n)for(const t in n){const e=n[t];"number"!=typeof e&&e.dispose()}}class Wn{constructor(){this.validationData=null}setParams(t){this.params=t}onEpochBegin(t,e){return(0,J.Z)(function*(){})()}onEpochEnd(t,e){return(0,J.Z)(function*(){})()}onBatchBegin(t,e){return(0,J.Z)(function*(){})()}onBatchEnd(t,e){return(0,J.Z)(function*(){})()}onTrainBegin(t){return(0,J.Z)(function*(){})()}onTrainEnd(t){return(0,J.Z)(function*(){})()}setModel(t){}}class By{constructor(t,e=10){null==t&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}onEpochBegin(t,e){var s=this;return(0,J.Z)(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onEpochBegin(t,e)})()}onEpochEnd(t,e){var s=this;return(0,J.Z)(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onEpochEnd(t,e)})()}onBatchBegin(t,e){var s=this;return(0,J.Z)(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onBatchBegin(t,e)})()}onBatchEnd(t,e){var s=this;return(0,J.Z)(function*(){null==e&&(e={});for(const r of s.callbacks)yield r.onBatchEnd(t,e)})()}onTrainBegin(t){var e=this;return(0,J.Z)(function*(){null==t&&(t={});for(const s of e.callbacks)yield s.onTrainBegin(t)})()}onTrainEnd(t){var e=this;return(0,J.Z)(function*(){null==t&&(t={});for(const s of e.callbacks)yield s.onTrainEnd(t)})()}}class My extends Wn{constructor(){super()}onEpochBegin(t){var e=this;return(0,J.Z)(function*(){e.seen=0,e.totals={}})()}onBatchEnd(t,e){var s=this;return(0,J.Z)(function*(){null==e&&(e={});const r=null==e.size?0:e.size;s.seen+=r;for(const a in e){const i=e[a];if("number"==typeof i)s.totals.hasOwnProperty(a)||(s.totals[a]=0),s.totals[a]=s.totals[a]+i*r;else{let o;a in s.totals?o=s.totals[a]:s.totals[a]=0;const u=(0,l.tidy)(()=>(0,l.add)(s.totals[a],(0,l.mul)(i,r)));s.totals[a]=u,o?.dispose()}}})()}onEpochEnd(t,e){var s=this;return(0,J.Z)(function*(){if(null!=e)for(const r of s.params.metrics)null!=s.totals[r]&&("number"==typeof s.totals[r]?e[r]=s.totals[r]/s.seen:(0,l.tidy)(()=>{const a=(0,l.mul)((0,l.div)(1,s.seen),s.totals[r]);e[r]=a,s.totals[r].dispose(),(0,l.keep)(e[r])}))})()}}class Wy extends Wn{onTrainBegin(t){var e=this;return(0,J.Z)(function*(){e.epoch=[],e.history={}})()}onEpochEnd(t,e){var s=this;return(0,J.Z)(function*(){null==e&&(e={}),s.epoch.push(t);for(const r in e)null==s.history[r]&&(s.history[r]=[]),s.history[r].push(e[r])})()}syncData(){var t=this;return(0,J.Z)(function*(){const e=[],s=[],r=[];for(const i in t.history){const o=t.history[i];for(let u=0;u<o.length;++u)"number"!=typeof o[u]&&(e.push(o[u].data()),s.push(i),r.push(u))}const a=yield Promise.all(e);for(let i=0;i<a.length;++i)t.history[s[i]][r[i]].dispose(),t.history[s[i]][r[i]]=a[i][0]})()}}class Gy extends Wn{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||l.nextFrame,this.yieldEvery=e||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=t.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");l.util.isNumber(this.yieldEvery)&&(this.maybeWait=function Kg(n,t,e){let r,s=null!=e?e():l.util.now();return(...i)=>{const o=null!=e?e():l.util.now();return o-s<t||(s=o,r=n(...i)),r}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}maybeWait(t,e,s){var r=this;return(0,J.Z)(function*(){const a=[];null!=r.yield&&(yield tn(s),a.push(r.yield(t,e,s))),a.push(r.nextFrameFunc()),yield Promise.all(a)})()}onEpochBegin(t,e){var s=this;return(0,J.Z)(function*(){s.currentEpoch=t,null!=s.epochBegin&&(yield tn(e),yield s.epochBegin(t,e))})()}onEpochEnd(t,e){var s=this;return(0,J.Z)(function*(){const r=[];null!=s.epochEnd&&(yield tn(e),r.push(s.epochEnd(t,e))),"epoch"===s.yieldEvery&&r.push(s.nextFrameFunc()),yield Promise.all(r)})()}onBatchBegin(t,e){var s=this;return(0,J.Z)(function*(){null!=s.batchBegin&&(yield tn(e),yield s.batchBegin(t,e))})()}onBatchEnd(t,e){var s=this;return(0,J.Z)(function*(){const r=[];null!=s.batchEnd&&(yield tn(e),r.push(s.batchEnd(t,e))),"batch"===s.yieldEvery?r.push(s.nextFrameFunc()):l.util.isNumber(s.yieldEvery)&&r.push(s.maybeWait(s.currentEpoch,t,e)),yield Promise.all(r)})()}onTrainBegin(t){var e=this;return(0,J.Z)(function*(){null!=e.trainBegin&&(yield tn(t),yield e.trainBegin(t))})()}onTrainEnd(t){var e=this;return(0,J.Z)(function*(){null!=e.trainEnd&&(yield tn(t),yield e.trainEnd(t))})()}}function Sl(n,t){return null==n&&(n={}),n instanceof Wn?[n]:Array.isArray(n)&&n[0]instanceof Wn?n:ve(n).map(s=>new Gy(s,t))}let Uy=(()=>{class n{constructor(){}static registerCallbackConstructor(e,s){l.util.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),n.checkForDuplicate(s),null==n.constructors[e]&&(n.constructors[e]=[]),n.constructors[e].push(s)}static checkForDuplicate(e){for(const s in n.constructors)n.constructors[+s].forEach(a=>{if(a===e)throw new k("Duplicate callback constructor.")})}static clear(){n.constructors={}}static createCallbacks(e){const s=[];for(const r in n.constructors){const a=+r;e>=a&&s.push(...n.constructors[a])}return s.map(r=>new r)}}return n.constructors={},n})();function Il(n,t,e,s,r,a,i,o,u){const c=new Wy,d=[new My,...Uy.createCallbacks(t)];null!=n&&d.push(...n),d.push(c);const p=new By(d);return p.setParams({epochs:e,initialEpoch:s,samples:r,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:u}),{callbackList:p,history:c}}function Wt(n,t={},e=!1){return os(n,l.serialization.SerializationMap.getMap().classNameMap,t,"layer",e)}function Zs(n,t){return(0,l.tidy)(()=>{"float32"!==n.dtype&&(n=l.cast(n,"float32"));const e=l.sum(cs(n),t,!0),s=l.fill(e.shape,Pe()),r=l.sqrt(l.maximum(e,s));return l.div(n,r)})}function Ys(n,t){return(0,l.tidy)(()=>l.mean(cs(l.sub(t,n)),-1))}function _a(n,t){return(0,l.tidy)(()=>l.mean(l.abs(l.sub(t,n)),-1))}function Fa(n,t){return(0,l.tidy)(()=>{const e=l.sub(n,t),s=l.clipByValue(l.abs(n),Pe(),Number.MAX_VALUE),r=l.abs(l.div(e,s));return l.mul(100,l.mean(r,-1))})}function ms(n,t,e=!1){return(0,l.tidy)(()=>{if(e)t=l.softmax(t);else{const s=l.sum(t,t.shape.length-1,!0);t=l.div(t,s)}return t=l.clipByValue(t,Pe(),1-Pe()),l.neg(l.sum(l.mul(l.cast(n,"float32"),l.log(t)),t.shape.length-1))})}function Qs(n,t,e=!1){return(0,l.tidy)(()=>{const s=l.cast(l.floor(function ly(n){const t=[Qt(n.shape)];return l.reshape(n,t)}(n)),"int32"),r=(t=l.clipByValue(t,Pe(),1-Pe())).shape;return ms(l.reshape(l.oneHot(s,r[r.length-1]),r),t,e)})}function Js(n,t){return(0,l.tidy)(()=>{let e;return e=l.clipByValue(t,Pe(),1-Pe()),e=l.log(l.div(e,l.sub(1,e))),l.mean(function Zy(n,t){if(!l.util.arraysEqual(n.shape,t.shape))throw new k(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return(0,l.tidy)(()=>{const e=l.relu(t),s=l.neg(l.abs(t));return l.add(l.sub(e,l.mul(t,n)),l.log1p(l.exp(s)))})}(n,e),-1)})}function wl(n,t){return(0,l.tidy)(()=>{const e=Zs(n,-1),s=Zs(t,-1),r=l.mul(e,s);return l.neg(l.sum(r,-1))})}const er={meanSquaredError:Ys,meanAbsoluteError:_a,meanAbsolutePercentageError:Fa,meanSquaredLogarithmicError:function Hy(n,t){return(0,l.tidy)(()=>{const e=l.clipByValue(t,Pe(),Number.MAX_VALUE),s=l.log(l.add(1,e)),r=l.clipByValue(n,Pe(),Number.MAX_VALUE),a=l.log(l.add(1,r));return l.mean(cs(l.sub(s,a)),-1)})},squaredHinge:function jy(n,t){return(0,l.tidy)(()=>{const e=l.maximum(0,l.sub(1,l.mul(n,t)));return l.mean(cs(e),-1)})},hinge:function Xy(n,t){return(0,l.tidy)(()=>{const e=l.maximum(0,l.sub(1,l.mul(n,t)));return l.mean(e,-1)})},categoricalHinge:function Ky(n,t){return(0,l.tidy)(()=>{const e=l.sum(l.mul(n,t),-1),s=l.max(l.mul(l.sub(1,n),t),-1);return l.maximum(0,l.add(1,l.sub(s,e)))})},logcosh:function qy(n,t){return(0,l.tidy)(()=>{const e=Math.log(2),s=l.sub(t,n),r=l.sub(l.add(s,l.softplus(l.mul(-2,s))),e);return l.mean(r,-1)})},categoricalCrossentropy:ms,sparseCategoricalCrossentropy:Qs,binaryCrossentropy:Js,kullbackLeiblerDivergence:function Yy(n,t){return(0,l.tidy)(()=>{const e=l.clipByValue(n,Pe(),1),s=l.clipByValue(t,Pe(),1);return l.sum(l.mul(n,l.log(l.div(e,s))),-1)})},poisson:function Qy(n,t){return(0,l.tidy)(()=>{const e=l.log(l.add(Pe(),t));return l.mean(l.sub(t,l.mul(n,e)),-1)})},cosineProximity:wl};function Oa(n){if("string"==typeof n){if(n in er)return er[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new k(t)}return n}function Nl(n,t){return(0,l.tidy)(()=>{const e=l.mul(.5,l.onesLike(t)),s=$t(l.greater(t,e),n.dtype);return l.mean(l.equal(n,s),-1)})}function Tl(n,t){return(0,l.tidy)(()=>$t(l.equal(l.argMax(n,-1),l.argMax(t,-1)),"float32"))}function nx(n,t){return Js(n,t)}function sx(n,t){return n.rank===t.rank&&(n=l.squeeze(n,[n.rank-1])),(t=l.argMax(t,-1)).dtype!==n.dtype&&(t=l.cast(t,n.dtype)),l.cast(l.equal(n,t),"float32")}const Rl=ms,Al=Qs,tr={binaryAccuracy:Nl,categoricalAccuracy:Tl,precision:function tx(n,t){return(0,l.tidy)(()=>{const e=function kl(n,t){return(0,l.tidy)(()=>l.cast(l.sum(l.logicalAnd(l.equal(n,1),l.equal(t,1))),"float32"))}(n,t),s=function ex(n,t){return(0,l.tidy)(()=>l.cast(l.sum(l.logicalAnd(l.equal(n,0),l.equal(t,1))),"float32"))}(n,t),r=l.add(e,s);return l.cast(l.where(l.greater(r,0),l.div(e,r),0),"float32")})},categoricalCrossentropy:Rl,sparseCategoricalCrossentropy:Al,mse:Ys,MSE:Ys,mae:_a,MAE:_a,mape:Fa,MAPE:Fa,cosine:wl};function dx(n){if("string"==typeof n&&n in tr)return tr[n];if("string"!=typeof n&&null!=n)return n;throw new k(`Unknown metric ${n}`)}function nr(n){if(ot(null!==n,`Unknown LossOrMetricFn ${n}`),"string"==typeof n)return n;{let t;for(const e of Object.keys(er))if(er[e]===n){t=e;break}if(void 0!==t)return t;for(const e of Object.keys(tr))if(tr[e]===n){t=e;break}return void 0!==t?t:n.name}}function $l(n,t,e=!1){if(null==n||"object"!=typeof n||Object.getPrototypeOf(n)!==Object.prototype||!za(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const s=JSON.stringify(n);s.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function za(n){if(null===n)return!0;if("object"==typeof n){if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if("string"!=typeof e||!za(n[e]))return!1;return!0}if(Array.isArray(n)){for(const t of n)if(!za(t))return!1;return!0}return!1}{const t=typeof n;return"string"===t||"number"===t||"boolean"===t}}function sr(n,t,e=console.log){let s="";for(let r=0;r<n.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=n[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);e(s)}function gx(n,t,e){let s,r;try{r=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{r="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}sr([`${n.name} (${n.getClassName()})`,r,s,n.countParams().toString()],t,e)}function yx(n,t,e,s){let r,a;try{a=n.inboundNodes.map(p=>JSON.stringify(p.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const i=[];for(const p of n.inboundNodes)if(!(null!=e&&e.length>0&&-1===e.indexOf(p)))for(let h=0;h<p.inboundLayers.length;++h)i.push(`${p.inboundLayers[h].name}[${p.nodeIndices[h]}][${p.tensorIndices[h]}]`);const o=n.name,u=n.getClassName(),c=0===i.length?"":i[0];sr([`${o} (${u})`,a,r,n.countParams().toString(),c],t,s);for(let p=1;p<i.length;++p)sr(["","","","",i[p]],t,s)}function El(n,t,e){return("inboundNodes"===n||"outputLayers"===n||"inputLayers"===n)&&0===t&&"string"==typeof e}function La(n,t){if(null===n)return null;if("string"==typeof n)return Cn(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const a=n[r];El(t,r,a)?e.push(a):e.push(La(a,t))}return e}{const e={};for(const s of Object.keys(n)){const r=n[s];if("name"===s&&"string"==typeof r)e[s]=r;else{const a=Cn(s);e[a]=La(r,a)}}return e}}function Pa(n,t){if(null==n)return null;if("string"==typeof n)return Mt(n);if("number"==typeof n||"boolean"==typeof n)return n;if(n instanceof Array){const e=[],s=n.length;for(let r=0;r<s;++r){const a=n[r];El(t,r,a)?e.push(a):e.push(Pa(a,t))}return e}{const e={};for(const s of Object.keys(n)){const r=n[s];e[Mt(s)]="name"!==s&&"className"!==s||"string"!=typeof r?Pa(r,s):r}return e}}class wt extends ue{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,null==this.name){const b=this.getClassName().toLowerCase();this.name=Ms(b)}if(this.supportsMasking=!1,this.trainable_=!0,this.inputs=Array.isArray(t.inputs)?t.inputs.slice():[t.inputs],this.outputs=Array.isArray(t.outputs)?t.outputs.slice():[t.outputs],Yt(this.inputs).length!==this.inputs.length)throw new k(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Yt(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const v=b.nodeIndex,I=b.tensorIndex;this.outputLayers.push(b.sourceLayer),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(I)}for(const b of this.inputs){const S=b.sourceLayer,v=b.nodeIndex,I=b.tensorIndex;ot(0===v,"input layer has >1 nodes"),ot(0===I,"input layer has >1 tensors"),this.inputLayers.push(S),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(I)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const S=this.inputLayers[b];if(!(S instanceof ps))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${S.getClassName()}.`);this.inputNames.push(S.name),this.feedInputShapes.push(S.batchInputShape),this.feedInputNames.push(S.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const e={},s={},r={},a={},i={},o=[],u=(b,S,v,I,w,N)=>{(null==I||null==w||null==N)&&(I=b.sourceLayer,w=b.nodeIndex,N=b.tensorIndex);const T=I.inboundNodes[w];if(-1!==v.indexOf(T))throw new ht(`The tensor ${b.name} at layer "${I.name}" is part of a cycle.`);if(-1!==S.indexOf(T))return;this.containerNodes.add(wt.nodeKey(I,w)),I.id in i||(i[I.id]=Object.keys(i).length),-1===v.indexOf(T)&&v.push(T);const D=T.inboundLayers.length;for(let A=0;A<D;A++)u(T.inputTensors[A],S,v,T.inboundLayers[A],T.nodeIndices[A],T.tensorIndices[A]);for(S.push(T);v.indexOf(T)>=0;)v.splice(v.indexOf(T),1);o.push(T)},c=[],d=[];for(const b of this.outputs)u(b,c,d);const p=o.slice().reverse();for(const b of p){s[b.id]=b,b.id in e||(e[b.id]=0);let S=e[b.id];S=Math.max(S,null==r[b.outboundLayer.id]?0:r[b.outboundLayer.id]),r[b.outboundLayer.id]=S,a[b.outboundLayer.id]=b.outboundLayer,e[b.id]=S;for(let I=0;I<b.inboundLayers.length;I++){const T=b.inboundLayers[I].inboundNodes[b.nodeIndices[I]];e[T.id]=Math.max(S+1,null==e[T.id]?0:e[T.id]),s[T.id]=T}}const h={};for(const b in e){const S=e[b];S in h||(h[S]=[]),h[S].push(s[b])}const f={};for(const b in r){const S=r[b];S in f||(f[S]=[]),f[S].push(a[b])}let m=Object.keys(f).map(b=>parseInt(b,10)).sort(Vs);this.layers=[];for(const b of m){const S=f[b];S.sort((v,I)=>{const w=i[v.id],N=i[I.id];return w<N?-1:w>N?1:0});for(const v of S)v instanceof wt&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=f,m=Object.keys(h).map(b=>parseInt(b,10)).sort(Vs);const y=this.inputs.slice(),g=[];for(const b of m)for(const S of h[b]){const v=S.outboundLayer;if(null!=v){for(const I of S.inputTensors)if(-1===y.indexOf(I))throw new ht(`Graph disconnected: cannot obtain value for tensor ${I} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const I of S.outputTensors)y.push(I);g.push(v.name)}}this.nodesByDepth=h;const x=this.layers.map(b=>b.name);for(const b of x){const S=x.filter(v=>v===b).length;if(1!==S)throw new ht(`The name "${b}" is used ${S} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new Xs({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(0==--this._refCount){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(s=>s.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new k("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const s of this.layers)e.push(...s.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const s={};let r=0;for(const i of this.layers)for(const o of i.weights){if(null!=s[o.originalName])throw new k(`Duplicate weight name: ${o.originalName}`);s[o.originalName]=o,r++}const a=[];for(const i in t){let o=i;if(null==s[i]){const u=i.split("/");o=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(null!=s[o])a.push([s[o],t[i]]);else if(e)throw new k(`Provided weight data has no target variable: ${i}`);delete s[o]}if(e){const i=[];for(const o in s)i.push(o);if(i.length>0)throw new k(`${i.length} of ${r} weights are not set: ${i}`)}Da(a)}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion="tfjs-layers 4.5.0",e.backend="TensorFlow.js",e}toJSON(t,e=!0){const s=Pa(this.updatedConfig());return e?JSON.stringify(s):s}call(t,e){return(0,l.tidy)(()=>{t=ve(t);const s=new en;for(let r=0;r<this.inputs.length;++r)s.add(this.inputs[r],t[r]);return hs(this.outputs,s,e)})}computeMask(t,e){return(0,l.tidy)(()=>{let s;return t=ve(t),s=null==e?bn(null,t.length):ve(e),this.runInternalGraph(t,s)[1]})}computeOutputShape(t){const e=Hs(t);if(e.length!==this.inputLayers.length)throw new k(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<e.length;o++)s[this.inputLayers[o].name+"_0_0"]=e[o];const r=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Vs);if(r.length>1)for(const o of r){const u=this.nodesByDepth[o];for(const c of u){const d=c.outboundLayer;if(-1!==this.inputLayers.map(y=>y.id).indexOf(d.id))continue;const p=[];for(let y=0;y<c.inboundLayers.length;y++)p.push(s[`${c.inboundLayers[y].name}_${c.nodeIndices[y]}_${c.tensorIndices[y]}`]);const f=Hs(d.computeOutputShape(et(p))),m=d.inboundNodes.indexOf(c);for(let y=0;y<f.length;y++)s[`${d.name}_${m}_${y}`]=f[y]}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++)i.push(`${this.outputLayers[o].name}_${this.outputLayersNodeIndices[o]}_${this.outputLayersTensorIndices[o]}`);for(let o=0;o<i.length;o++){const u=i[o];ot(u in s),a.push(s[u])}return et(a)}runInternalGraph(t,e){null==e&&(e=bn(null,t.length));const s={};for(let u=0;u<this.inputs.length;++u)s[this.inputs[u].id]=[t[u],e[u]];const r=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Vs);for(const u of r){const c=this.nodesByDepth[u];for(const d of c){const p=d.outboundLayer,h=d.inputTensors,f=d.outputTensors,m=new Array;for(const y of h)y.id in s&&m.push(s[y.id]);if(m.length===h.length){let g,x,b,S,y={};if(null!=d.callArgs&&(y=d.callArgs),1===m.length){const[v,I]=m[0];null==y.mask&&(y.mask=I),b=ve(p.call(v,y)),S=ve(p.computeMask(v,I)),g=[v],x=[I]}else g=m.map(v=>v[0]),x=m.map(v=>v[1]),null==y.mask&&(y.mask=x),b=ve(p.call(g,y)),S=ve(p.computeMask(g,x));if(p.activityRegularizer)throw new oe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<f.length;++v)s[f[v].id]=[b[v],S[v]]}}}const a=[],i=[],o=[];for(const u of this.outputs){ot(u.id in s,`Could not compute output ${u.name} : ${u.id}`);const[c,d]=s[u.id];o.push(c.shape),a.push(c),i.push(d)}return[a,i,o]}buildNodeConversionMap(t){const e={};let s;for(const r of this.layers){s=r instanceof wt?1:0;for(let a=0;a<r.inboundNodes.length;a++){const i=wt.nodeKey(r,a);this.containerNodes.has(i)&&(e[i]=s,s+=1)}}return e}getLayer(t,e){if(null!=e){if(this.layers.length<=e)throw new k(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}if(null==t)throw new k("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===t)return s;throw new k(`No such layer: ${t}`)}calculateLosses(){return(0,l.tidy)(()=>{const t=[];for(const e of this.layers)for(let s=0;s<e.inboundNodes.length;++s){const r=wt.nodeKey(e,s);this.containerNodes.has(r)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),s=[];for(const i of this.layers){const o=i.getClassName(),u=i.getConfig(),c=[];for(let p=0;p<i.inboundNodes.length;p++){const h=i.inboundNodes[p],f=wt.nodeKey(i,p);let m={};if(this.containerNodes.has(f)){if(h.callArgs)try{JSON.stringify(h.callArgs),m=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),m={}}if(h.inboundLayers.length>0){const y=[];for(let g=0;g<h.inboundLayers.length;g++){const x=h.inboundLayers[g],S=h.tensorIndices[g];let I=e[wt.nodeKey(x,h.nodeIndices[g])];null==I&&(I=0),y.push([x.name,I,S,m])}c.push(y)}}}const d={};d.name=i.name,d.className=o,d.config=u,d.inboundNodes=c,s.push(d)}t.layers=s;const r=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],c=wt.nodeKey(o,this.inputLayersNodeIndices[i]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),r.push([o.name,d,this.inputLayersTensorIndices[i]])}t.inputLayers=r;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],c=wt.nodeKey(o,this.outputLayersNodeIndices[i]);if(!this.containerNodes.has(c))continue;let d=e[c];null==d&&(d=0),a.push([o.name,d,this.outputLayersTensorIndices[i]])}return t.outputLayers=a,t}static fromConfig(t,e,s={},r=!1){const a={},i={};function o(g,x){g.name in i?i[g.name].push(x):i[g.name]=[x]}function u(g,x){const b=[];let S;for(const v of x){const I=v[0],w=v[1],N=v[2];if(S=null==v[3]?{}:v[3],!(I in a))return void o(g,x);const T=a[I];if(T.inboundNodes.length<=w)return void o(g,x);b.push(T.inboundNodes[w].outputTensors[N])}b.length>0&&g.apply(et(b),S)}function c(g){const x=g.name,b=Wt(g,null!=e.customObjects?e.customObjects:{});b.setFastWeightInitDuringBuild(r),a[x]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new k(`Corrupted configuration, expected array for nodeData: ${v}`);o(b,v)})}const d=e.name,p=e.layers;for(const g of p)c(g);for(;!Xg(i);)for(const g of p){const x=a[g.name];if(x.name in i){const b=i[x.name];delete i[x.name];for(const S of b)u(x,S)}}const h=[],f=[],m=e.inputLayers;for(const g of m){const x=g[0],b=g[1],S=g[2];ot(x in a),h.push(a[x].inboundNodes[b].outputTensors[S])}const y=e.outputLayers;for(const g of y){const x=g[0],b=g[1],S=g[2];ot(x in a),f.push(a[x].inboundNodes[b].outputTensors[S])}return new t({inputs:h,outputs:f,name:d})}get stateful(){if(this._stateful)throw new k("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){(0,l.tidy)(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Fl(n,t){return function _l(n,t,e){const s=t.length;if(null==n||Array.isArray(n)&&0===n.length)return t.map(r=>null);if(1===s)return Array.isArray(n)&&1===n.length?n:"object"==typeof n&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}if("object"==typeof n&&Object.keys(n).length>0&&"object"==typeof n[Object.keys(n)[0]]){const r=[];return t.forEach(a=>{r.push(a in n?n[a]:null)}),r}throw new Error(`The model has multiple (${s}) outputs, so ${e} must be either an array with ${s} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}(n,t,"classWeight")}function Ol(n,t,e,s){return Ba.apply(this,arguments)}function Ba(){return(Ba=(0,J.Z)(function*(n,t,e,s){if(null!=t||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=e){const r=(0,l.tidy)(()=>{if(1===n.shape.length)return(0,l.clone)(n);if(2===n.shape.length){if(n.shape[1]>1)return(0,l.argMax)(n,1);if(1===n.shape[1])return(0,l.reshape)(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(yield r.data());(0,l.dispose)(r);const i=[];return a.forEach(o=>{if(null==e[o])throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(e[o])}),(0,l.tensor1d)(i,"float32")}return null})).apply(this,arguments)}function xx(n,t){return(0,l.mul)(n,t)}function zl(n,t){let e,s;e=t.xs,s=t.ys,l.util.assert(null!=e&&null!=s,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=Ll("input",n.inputNames,e),i=Ll("output",n.outputNames,s),o=a[0].shape[0];l.util.assert(a.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),l.util.assert(i.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<a.length;u++)l.util.assert(a[u].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${a[u].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let u=0;u<i.length;u++)l.util.assert(i[u].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${i[u].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:a,ys:i}}function Ll(n,t,e){if(e instanceof l.Tensor)return[e];if(Array.isArray(e))return l.util.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const s=[];for(const r of t){if(null==e[r])throw new k(`The feature data generated by the dataset lacks the required ${n} key '${r}'.`);s.push(e[r])}return s}}function Ma(){return(Ma=(0,J.Z)(function*(n,t,e){const s=null!=e.batchesPerEpoch;if(l.util.assert(null!=n.optimizer,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),l.util.assert(null!=e,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),l.util.assert(null!=e.epochs&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),l.util.assert(!s||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),l.util.assert(null==e.validationSplit,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const r=null!=e.validationData;let a,i;if(r)if(Pl(e.validationData))l.util.assert(null==e.validationBatches||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const g=function Cx(n){if(3===n.length)throw new oe("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}(e.validationData);a=g.xs,i=g.ys}const o=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let c;c=r?u.slice().concat(u.map(g=>"val_"+g)):u.slice();const d=Sl(e.callbacks,e.yieldEvery),p=null==e.verbose?1:e.verbose,{callbackList:h,history:f}=Il(d,p,e.epochs,null,null,function Sx(n,t){let e=null;return null!=t.batchesPerEpoch?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}(t,e),null,r,c);h.setModel(n),n.history=f,yield h.onTrainBegin(),n.stopTraining_=!1;let m=null==e.initialEpoch?0:e.initialEpoch,y=yield t.iterator();for(;m<e.epochs;){const g={};yield h.onEpochBegin(m);let x=0,b=0;for(s||(y=yield t.iterator());!s||x<e.batchesPerEpoch;){const S=yield y.next();if(s&&S.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(null!=S.value){const{xs:v,ys:I}=zl(n,S.value),w={};w.batch=b,w.size=v[0].shape[0],yield h.onBatchBegin(b,w);const N=[];if(null!=e.classWeight){const A=Fl(e.classWeight,n.outputNames);for(let $=0;$<A.length;++$)N.push(yield Ol(I[$],null,A[$]))}const T=v.concat(I).concat(N),D=o(T);l.dispose(T);for(let A=0;A<u.length;++A){const F=D[A];w[u[A]]=F,l.keep(F)}yield h.onBatchEnd(b,w),vl(w),b++,x++}if(s?x>=e.batchesPerEpoch:S.done){if(r){let v;v=Pl(e.validationData)?ve(yield n.evaluateDataset(e.validationData,{batches:e.validationBatches})):ve(n.evaluate(a,i,{batchSize:null==e.validationBatchSize?32:e.validationBatchSize,verbose:0}));for(let I=0;I<n.metricsNames.length;++I)g[`val_${n.metricsNames[I]}`]=v[I]}break}if(n.stopTraining_)break}if(yield h.onEpochEnd(m,g),m++,n.stopTraining_)break}return yield h.onTrainEnd(),yield n.history.syncData(),n.history}finally{n.isTraining=!1}})).apply(this,arguments)}function Pl(n){return"function"==typeof n.iterator}function Wa(){return(Wa=(0,J.Z)(function*(n,t,e){const s=null!=(e=e||{}).batches,r=n.testFunction;let a=[];if(e.verbose>0)throw new oe("Verbose mode is not implemented yet.");l.util.assert(!s||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const i=function Ix(n){return"function"==typeof n.next}(t)?t:yield t.iterator();let o=0,u=0;for(;!s||u<e.batches;){const c=yield i.next();if(a=l.tidy(()=>{if(c.value){const{xs:d,ys:p}=zl(n,c.value),h=d.concat(p),f=l.tidy(()=>r(h));if(l.dispose(h),0===u)for(let y=0;y<f.length;++y)a.push((0,l.scalar)(0));const m=h[0].shape[0];for(let y=0;y<f.length;++y){const g=f[y],x=a[y];a[y]=l.tidy(()=>l.add(a[y],l.mul(m,g))),u>0&&l.dispose(x)}l.dispose(f),o+=m,++u}return a}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<a.length;++c){const d=a[c];a[c]=l.div(a[c],o),l.dispose(d)}return et(a)})).apply(this,arguments)}function Ga(n){l.util.assert(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function gs(n,t,e){return null==n?[null]:Array.isArray(n)?n.map(s=>In(s,t,e-t)):In(n,t,e-t)}function Ua(n,t){return l.tidy(()=>null==n?null:Array.isArray(n)?n.map(e=>Ua(e,t)):rl(n,"int32"===t.dtype?t:l.cast(t,"int32")))}function Ha(n,t){const e=[];let s=0,r=null;for(;s<n;)r=s+t,r>=n&&(r=n),e.push([s,r]),s=r;return e}function Vl(n){const t=[];n instanceof l.Tensor&&(n=[n]);for(let e=0;e<n.length;++e){const s=n[e];if(1===s.rank)t.push(us(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function Nt(n,t){if(null==n)return;const e=[];if(t instanceof l.Tensor)e.push(t.id);else if(Array.isArray(t))t.forEach(r=>e.push(r.id));else if(null!=t)for(const r in t)e.push(t[r].id);const s=[];if(n instanceof l.Tensor)-1===e.indexOf(n.id)&&s.push(n);else if(Array.isArray(n))n.forEach(r=>{-1===e.indexOf(r.id)&&s.push(r)});else if(null!=n)for(const r in n){const a=n[r];-1===e.indexOf(a.id)&&s.push(a)}s.forEach(r=>{r.isDisposed||r.dispose()})}function ja(n){return Array.isArray(n)}function Bl(n){return!function Nx(n){return n instanceof l.Tensor}(n)&&!ja(n)}function Ml(n,t,e,s=!0,r=""){if(null==t||0===t.length){if(null!=n){let i=!1;if(ja(n)&&n.length>0)i=!0;else if(Bl(n)){for(const o in n)if(n.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new k(`Error when checking model ${r} expected no data, but got ${n}`)}return[]}if(null==n)return t.map(i=>null);let a;if(Bl(n)){a=[];for(const i of t){if(null==n[i])throw new k(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(n[i])}}else if(ja(n)){if(n.length!==t.length)throw new k(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);a=n}else{if(t.length>1)throw new k(`The model ${r} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);a=[n]}if(a=Vl(a),null!=e)for(let i=0;i<t.length;++i){if(null==e[i])continue;const o=a[i];if(o.shape.length!==e[i].length)throw new k(`Error when checking ${r}: expected ${t[i]} to have ${e[i].length} dimension(s). but got array with shape ${o.shape}`);for(let u=0;u<e[i].length;++u){if(0===u&&!s)continue;const d=e[i][u];if(null!=d&&d>=0&&o.shape[u]!==d)throw new k(`${r} expected a batch of elements where each example has shape [${e[i].slice(1,e[i].length)}] (i.e.,tensor shape [*,${e[i].slice(1,e[i].length)}]) but the ${r} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function Wl(n,t,e,s=!0,r=""){let a;if(Array.isArray(n)){if(n.length!==t.length)throw new k(`Error when checking model ${r}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);a=n}else{if(t.length>1)throw new k(`The model expects ${t.length} ${r} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);a=[n]}if(null!=e)for(let i=0;i<t.length;++i){if(null==e[i])continue;const o=a[i];if(o.shape.length!==e[i].length)throw new k(`Error when checking ${r}: expected ${t[i]} to have ${e[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let u=0;u<e[i].length;++u){if(0===u&&!s)continue;const d=e[i][u];if(null!=d&&d!==o.shape[u])throw new k(`Error when checking ${r}: expected ${t[i]} to have shape ${JSON.stringify(e[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}let Gn=(()=>{class n extends wt{constructor(e){super(e),this.isTraining=!1}summary(e,s,r=console.log){if(!this.built)throw new k("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");!function hx(n,t,e,s=console.log){const r=function mx(n){let t=!0;const e=[],s=[];for(const r in n.nodesByDepth)e.push(n.nodesByDepth[r]);for(const r of e){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of n.layers){let a=!1;for(const i of r.inboundNodes)if(-1!==s.indexOf(i)){if(a){t=!1;break}a=!0}if(!t)break}return t}(n),a=["Layer (type)","Input Shape","Output shape","Param #"];let i;if(r?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(d=>Math.floor(t*d))),!r){a.push("Receives inputs"),i=[];for(const d in n.nodesByDepth)i.push(...n.nodesByDepth[d])}s("_".repeat(t)),sr(a,e,s),s("=".repeat(t));const o=n.layers;for(let d=0;d<o.length;++d)r?gx(o[d],e,s):yx(o[d],e,i,s),s((d===o.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const u=function fx(n){let t;return t=js(null!=n.collectedTrainableWeights?n.collectedTrainableWeights:n.trainableWeights),t}(n),c=js(n.nonTrainableWeights);s(`Total params: ${u+c}`),s(`Trainable params: ${u}`),s(`Non-trainable params: ${c}`),s("_".repeat(t))}(this,e,s,r)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"==typeof e.optimizer)this.optimizer_=function px(n){const t={Adagrad:()=>l.train.adagrad(.01),Adadelta:()=>l.train.adadelta(1,.95,Pe()),Adam:()=>l.train.adam(.001,.9,.999,Pe()),Adamax:()=>l.train.adamax(.002,.9,.999,Pe(),0),RMSProp:()=>l.train.rmsprop(.001,.9,0,Pe()),SGD:()=>l.train.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new k(`Unknown Optimizer ${n}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof l.Optimizer))throw new k("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let s=[];if(Array.isArray(e.loss)||"string"==typeof e.loss||"function"==typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new k(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);s=e.loss.map(u=>Oa(u))}else{const o=Oa(e.loss);this.outputs.forEach(u=>{s.push(o)})}else{e.loss=e.loss;for(const o in e.loss)if(-1===this.outputNames.indexOf(o))throw new k(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)null==e.loss[o]&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),s.push(Oa(e.loss[o]))}this.lossFunctions=s,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const u=this.internalOutputShapes[o];this.feedOutputNames.push(this.outputNames[o]),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Sn("loss",()=>{for(let o=0;o<this.outputs.length;++o)-1===r.indexOf(o)&&this.outputs.length>1&&(this.metricsTensors.push([this.lossFunctions[o],o]),this.metricsNames.push(this.outputNames[o]+"_loss"))});const a=function Rx(n,t){if(null==n||Array.isArray(n)&&0===n.length)return t.map(s=>[]);let e;if("string"==typeof n||"function"==typeof n)e=[n];else{if(!Array.isArray(n)&&"object"!=typeof n)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);e=n}if(Array.isArray(e))return t.map(s=>e);{const s=[];for(const r of t){let a=e.hasOwnProperty(r)?e[r]:[];Array.isArray(a)||(a=[a]),s.push(a)}return s}}(e.metrics,this.outputNames),i=(o,u,c)=>{this.outputNames.length>1&&(u=this.outputNames[o]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([c,o])};Sn("metric",()=>{for(let o=0;o<this.outputs.length;++o)-1===r.indexOf(o)&&(d=>{let h,f,m;for(const y of d){if("string"==typeof y&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(y)){const x=this.internalOutputShapes[o];let b;1===x[x.length-1]||this.lossFunctions[o]===Js?-1!==["accuracy","acc"].indexOf(y)?f=Nl:-1!==["crossentropy","ce"].indexOf(y)&&(f=nx):this.lossFunctions[o]===Qs?-1!==["accuracy","acc"].indexOf(y)?f=sx:-1!==["crossentropy","ce"].indexOf(y)&&(f=Al):-1!==["accuracy","acc"].indexOf(y)?f=Tl:-1!==["crossentropy","ce"].indexOf(y)&&(f=Rl),-1!==["accuracy","acc"].indexOf(y)?b="acc":-1!==["crossentropy","ce"].indexOf(y)&&(b="ce"),m=f,h=""+b}else m=dx(y),h=""+nr(y);let g;Sn(h,()=>{g=m}),i(o,h,g)}})(a[o])}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,s,r={}){const a=null==r.batchSize?32:r.batchSize;Ga(a);const o=this.standardizeUserDataXY(e,s,!0,a);try{const u=o[0].concat(o[1]);return this.makeTestFunction(),et(this.testLoop(this.testFunction,u,a,r.verbose,r.steps))}finally{Nt(o[0],e),Nt(o[1],s)}}evaluateDataset(e,s){var r=this;return(0,J.Z)(function*(){return r.makeTestFunction(),function wx(n,t,e){return Wa.apply(this,arguments)}(r,e,s)})()}checkNumSamples(e,s,r,a="steps"){let i;if(null!=r){if(i=null,null!=s)throw new k(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${s}`)}else{if(null==e)throw new k(`Either the input data should have a defined shape, or ${a} shoud be specified.`);i=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return i}execute(e,s){if(Array.isArray(s)&&0===s.length)throw new k("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(s),i=this.retrieveSymbolicTensors(r?s:[s]),o=new en;if(e instanceof l.Tensor&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new k(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)o.add(this.inputs[c],e[c])}else for(const c of this.inputs){const d=e[c.name];if(null==d)throw new k(`No value is provided for the model's input ${c.name}`);o.add(c,d)}const u=hs(i,o);return r?u:u[0]}retrieveSymbolicTensors(e){const s=bn(null,e.length);let r=e.length;for(const a of this.layers){const i=Array.isArray(a.output)?a.output:[a.output],o=i.map(u=>u.name);for(let u=0;u<e.length;++u){const c=o.indexOf(e[u]);if(-1!==c&&(s[u]=i[c],r--),0===r)break}if(0===r)break}if(r>0){const a=[];throw s.forEach((i,o)=>{null==i&&a.push(e[o])}),new k(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return s}predictLoop(e,s=32,r=!1){return l.tidy(()=>{const a=this.checkNumSamples(e);if(r)throw new oe("Verbose predictLoop() is not implemented yet.");const i=Ha(a,s),o=this.outputs.map(u=>[]);for(let u=0;u<i.length;++u)l.tidy(()=>{const h=gs(e,i[u][0],i[u][1]),f=[];if(Array.isArray(h))for(let y=0;y<h.length;++y)f.push({key:this.inputs[y],value:h[y]});else f.push({key:this.inputs[0],value:h});const m=new en(f);return hs(this.outputs,m)}).forEach((d,p)=>o[p].push(d));return et(o.map(u=>l.concat(u,0)))})}predict(e,s={}){const r=Vl(e);Wl(r,this.inputNames,this.feedInputShapes,!1);try{const a=null==s.batchSize?32:s.batchSize;return Ga(a),this.predictLoop(r,a)}finally{Nt(r,e)}}predictOnBatch(e){Wl(e,this.inputNames,this.feedInputShapes,!0);const s=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,s)}standardizeUserDataXY(e,s,r=!0,a){if(null==this.optimizer_)throw new ht("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const i=[];for(let o=0;o<this.feedOutputShapes.length;++o){const u=this.feedOutputShapes[o];i.push(this.feedLossFns[o]===Qs?u.slice(0,u.length-1).concat([1]):u)}if(function Tx(n,t,e){const s=Yt(n.map(a=>a.shape[0]));s.sort();const r=Yt(t.map(a=>a.shape[0]));if(r.sort(),s.length>1)throw new k(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(a=>a.shape))}`);if(r.length>1)throw new k(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(s.length>0&&r.length>0&&!l.util.arraysEqual(s,r))throw new k(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${r[0]} target sample(s).`)}(e=Ml(e,this.feedInputNames,this.feedInputShapes,!1,"input"),s=Ml(s,this.feedOutputNames,i,!1,"target")),function kx(n,t,e){const s=[Ys,Js,ms];for(let r=0;r<n.length;++r){const a=n[r],i=t[r],o=e[r];if(null!=i){if(i===ms&&1===a.shape[a.shape.length-1])throw new k(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(i)){const u=a.shape.slice(1),c=o.slice(1);for(let d=0;d<u.length;++d){const h=c[d];if(null!=h&&u[d]!==h)throw new k(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(s,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=a&&a>0&&e[0].shape[0]%a!=0)throw new k(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${e[0].shape[0]} sample(s).`);return[e,s]}standardizeUserData(e,s,r,a,i=!0,o){var u=this;return(0,J.Z)(function*(){const[c,d]=u.standardizeUserDataXY(e,s,i,o);if(null!=r)throw new Error("sample weight is not supported yet.");let p=null;if(null!=a){const h=Fl(a,u.outputNames);p=[];for(let f=0;f<h.length;++f)p.push(yield Ol(d[f],null,h[f]))}return[c,d,p]})()}testLoop(e,s,r,a=0,i){return l.tidy(()=>{const o=this.checkNumSamples(s,r,i,"steps"),u=[];if(a>0)throw new oe("Verbose mode is not implemented yet.");if(null!=i)throw new oe("steps mode in testLoop() is not implemented yet");{const c=Ha(o,r),d=(0,l.tensor1d)(vt(0,o));for(let p=0;p<c.length;++p){const h=c[p][0],f=c[p][1],m=In(d,h,f-h),y=Ua(s,m),g=e(y);if(0===p)for(let x=0;x<g.length;++x)u.push((0,l.scalar)(0));for(let x=0;x<g.length;++x)u[x]=l.add(u[x],l.mul(f-h,g[x]))}for(let p=0;p<u.length;++p)u[p]=l.div(u[p],o)}return u})}getDedupedMetricsNames(){const e=this.metricsNames,s=[];for(let r=0;r<e.length;++r){const a=e[r];let i=a;Xo(e,a)>1&&(i+=`_${Xo(e.slice(0,r),a)}`),s.push(i)}return s}makeTrainFunction(){return e=>{const s=[],r=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),o=[],c=this.collectedTrainableWeights.map(h=>h.read());return[this.optimizer_.minimize(()=>{const h=[];for(let g=0;g<this.inputs.length;++g)h.push({key:this.inputs[g],value:r[g]});const f=new en(h),m=hs(this.outputs,f,{training:!0});let y;for(let g=0;g<this.lossFunctions.length;++g){let b=(0,this.lossFunctions[g])(a[g],m[g]);null!=i[g]&&(b=xx(b,i[g]));const S=l.mean(b);s.push(S),y=0===g?b:l.add(y,b)}for(let g=0;g<this.metricsTensors.length;++g){let x;if(this.outputs.length>1&&g<this.outputs.length)x=s[g];else{const S=this.metricsTensors[g][1];x=l.mean((0,this.metricsTensors[g][0])(a[S],m[S]))}l.keep(x),o.push(x)}return y=l.mean(y),this.calculateLosses().forEach(g=>{y=l.add(y,g)}),y},!0,c)].concat(o)}}makeTestFunction(){this.testFunction=e=>l.tidy(()=>{const s=[];let r;const a=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let d=0;d<this.inputs.length;++d)o.push({key:this.inputs[d],value:a[d]});const u=new en(o),c=hs(this.outputs,u);for(let d=0;d<this.lossFunctions.length;++d){const h=l.mean((0,this.lossFunctions[d])(i[d],c[d]));r=0===d?h:l.add(r,h),s.push(r)}for(let d=0;d<this.metricsTensors.length;++d){const h=this.metricsTensors[d][1],f=l.mean((0,this.metricsTensors[d][0])(i[h],c[h]));s.push(f)}return s})}fit(e,s,r={}){var a=this;return(0,J.Z)(function*(){if(a.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");let i,o,u,c,d,p,h,f,m;a.isTraining=!0;try{const y=null==r.batchSize?32:r.batchSize;Ga(y);const g=!1,x=yield a.standardizeUserData(e,s,r.sampleWeight,r.classWeight,g,y);i=x[0],o=x[1],m=x[2];let S,b=!1;if(null!=r.validationData&&r.validationData.length>0){if(b=!0,2!==r.validationData.length)throw 3===r.validationData.length?new oe("validationData including sample weights is not supported yet."):new k(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);d=r.validationData[0],p=r.validationData[1];const $=!0,F=yield a.standardizeUserData(d,p,null,null,$,y);h=F[0],f=F[1],S=h.concat(f)}else if(null!=r.validationSplit&&r.validationSplit>0&&r.validationSplit<1){b=!0;const $=Math.floor(i[0].shape[0]*(1-r.validationSplit)),F=i[0].shape[0];h=gs(i,$,F),u=i,i=gs(i,0,$),f=gs(o,$,F),c=o,o=gs(o,0,$),S=h.concat(f)}else null!=r.validationSteps&&(b=!0);const v=i.concat(o).concat(m);a.checkTrainableWeightsConsistency();const I=a.makeTrainFunction(),w=a.getDedupedMetricsNames();let N,T;b?(a.makeTestFunction(),N=a.testFunction,T=w.slice().concat(w.map($=>"val_"+$))):(N=null,S=[],T=w.slice());const D=Sl(r.callbacks,r.yieldEvery);return yield a.fitLoop(I,v,w,y,r.epochs,r.verbose,D,N,S,r.shuffle,T,r.initialEpoch,null,null)}finally{a.isTraining=!1,Nt(i,e),Nt(o,s),Nt(u,e),Nt(c,s),Nt(h,d),Nt(f,p),null!=m&&l.dispose(m)}})()}fitLoop(e,s,r,a,i,o,u,c,d,p,h,f,m,y){var g=this;return(0,J.Z)(function*(){null==a&&(a=32),null==i&&(i=1),null==p&&(p=!0),null==f&&(f=0);let x=!1;if(null!=c&&null!=d&&(x=!0),null!=y&&(x=!0,null==m))throw new k("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=g.checkNumSamples(s,a,m,"steps_per_epoch");let S;null!=b&&(S=vt(0,b)),null==o&&(o=1);const{callbackList:v,history:I}=Il(u,o,i,f,b,m,a,x,h);v.setModel(g),g.history=I,yield v.onTrainBegin(),g.stopTraining_=!1;for(let w=f;w<i;++w){yield v.onEpochBegin(w);const N={};if(null!=m)throw new oe("stepsPerEpoch mode is not implemented yet.");{if("batch"===p)throw new oe("batch shuffling is not implemneted yet");p&&l.util.shuffle(S);const T=(0,l.tensor1d)(S),D=Ha(b,a);for(let A=0;A<D.length;++A){const $={};if(yield v.onBatchBegin(A,$),l.tidy(()=>{const F=D[A][0],O=D[A][1],L=In(T,F,O-F);$.batch=A,$.size=O-F;const z=Ua(s,L),P=e(z);for(let B=0;B<r.length;++B){const V=P[B];$[r[B]]=V,l.keep(V)}if(A===D.length-1&&x){const B=g.testLoop(c,d,a);for(let _=0;_<r.length;++_){const V=r[_],G=B[_];l.keep(G),N["val_"+V]=G}}}),yield v.onBatchEnd(A,$),vl($),g.stopTraining_)break}T.dispose()}if(yield v.onEpochEnd(w,N),g.stopTraining_)break}return yield v.onTrainEnd(),yield g.history.syncData(),g.history})()}fitDataset(e,s){var r=this;return(0,J.Z)(function*(){return function vx(n,t,e){return Ma.apply(this,arguments)}(r,e,s)})()}trainOnBatch(e,s){var r=this;return(0,J.Z)(function*(){const a=yield r.standardizeUserData(e,s),i=a[0],o=a[1],c=r.makeTrainFunction()(i.concat(o)),d=[];for(const p of c){const h=yield p.data();d.push(h[0])}return l.dispose(c),Nt(a[0],e),Nt(a[1],s),et(d)})()}getNamedWeights(e){const s=[],r=null!=e&&e.trainableOnly,a=r?this.trainableWeights:this.weights,i=this.getWeights(r);for(let o=0;o<a.length;++o)r&&!a[o].trainable||s.push({name:a[o].originalName,tensor:i[o]});return s}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const s=l.memory().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=s-l.memory().numTensors}return e}getLossIdentifiers(){let e;if("string"==typeof this.loss)e=Mt(this.loss);else if(Array.isArray(this.loss)){for(const s of this.loss)if("string"!=typeof s)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(s=>Mt(s))}else{const s=Object.keys(this.loss);e={};const r=this.loss;for(const a of s){if("string"!=typeof r[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=Mt(r[a])}}return e}getMetricIdentifiers(){if("string"==typeof this.metrics||"function"==typeof this.metrics)return[Mt(nr(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Mt(nr(e)));{const e={};for(const s in this.metrics)e[s]=Mt(nr(this.metrics[s]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const r=Wt(La(e.optimizer_config));let a,i;if("string"==typeof e.loss)a=Cn(e.loss);else if(Array.isArray(e.loss))a=e.loss.map(o=>Cn(o));else if(null!=e.loss){a={};for(const o in e.loss)a[o]=Cn(e.loss[o])}if(Array.isArray(e.metrics))i=e.metrics.map(o=>Cn(o));else if(null!=e.metrics){i={};for(const o in e.metrics)i[o]=Cn(e.metrics[o])}this.compile({loss:a,metrics:i,optimizer:r})}save(e,s){var r=this;return(0,J.Z)(function*(){if("string"==typeof e){const p=l.io.getSaveHandlers(e);if(0===p.length)throw new k(`Cannot find any save handlers for URL '${e}'`);if(p.length>1)throw new k(`Found more than one (${p.length}) save handlers for URL '${e}'`);e=p[0]}if(null==e.save)throw new k("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=yield l.io.encodeWeights(r.getNamedWeights(s)),c={modelTopology:r.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v4.5.0",convertedBy:null};if(null!=s&&s.includeOptimizer&&null!=r.optimizer){c.trainingConfig=r.getTrainingConfig();const p="optimizer",{data:h,specs:f}=yield l.io.encodeWeights(yield r.optimizer.getWeights(),p);a.specs.push(...f),a.data=l.io.concatenateArrayBuffers([a.data,h])}return null!=r.userDefinedMetadata&&($l(r.userDefinedMetadata,r.name,!0),c.userDefinedMetadata=r.userDefinedMetadata),c.weightData=a.data,c.weightSpecs=a.specs,e.save(c)})()}setUserDefinedMetadata(e){$l(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}return n.className="Model",n})();l.serialization.registerClass(Gn),l.serialization.registerClass((()=>{class n extends Gn{}return n.className="Functional",n})());let Gl=(()=>{class n extends Gn{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Ms("sequential_"),null!=e.layers)for(const s of e.layers)this.add(s)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new k(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const s=e instanceof n||e instanceof Gn;let r;if(s){if(r=e,1!==r.outputs.length)throw new k("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==r.inputs.length)throw new k("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new k("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const a=yl({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(a)}if(s)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==e.inboundNodes.length)throw new k(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new k("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=gl(this.outputs[0])}this.inboundNodes=[],new Xs({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:bn(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{const a=e.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,s){return null==this.model&&this.build(),this.model.call(e,s)}build(e){if(he(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Gn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,s,r=console.log){this.built||this.build(),super.summary(e,s,r)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,s,r={}){if(!this.built)throw new ht("The model needs to be compiled before being used.");return this.model.evaluate(e,s,r)}evaluateDataset(e,s){var r=this;return(0,J.Z)(function*(){if(!r.built)throw new ht("The model needs to be compiled before being used.");return r.model.evaluateDataset(e,s)})()}predict(e,s={}){return null==this.model&&this.build(),this.model.predict(e,s)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}fit(e,s,r={}){var a=this;return(0,J.Z)(function*(){if(!a.built)throw new ht("The model needs to be compiled before being used.");return a.model.fit(e,s,r)})()}fitDataset(e,s){var r=this;return(0,J.Z)(function*(){if(!r.built)throw new ht("The model needs to be compiled before being used.");return r.model.fitDataset(e,s)})()}trainOnBatch(e,s){var r=this;return(0,J.Z)(function*(){return r.model.trainOnBatch(e,s)})()}static fromConfig(e,s,r={},a=!1){let i,o={};if(s instanceof Array){if(null==s[0].className||"Merge"===s[0].className)throw new k("Legacy serialization format not supported yet.");i=s}else l.util.assert(null!=s.layers,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),i=s.layers,delete s.layers,o=s;const u=new e(o);if(!(u instanceof n))throw new oe(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const c of i){const p=Wt(c,void 0,a);a&&p.setFastWeightInitDuringBuild(!0),u.add(p)}return u}set stopTraining(e){if(null==this.model)throw new k("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new k("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const s of this.layers){const r={};r.className=s.getClassName(),r.config=s.getConfig(),e.push(r)}return{name:this.name,layers:e}}}return n.className="Sequential",n})();function _x(n){return new Gl(n)}function Fx(n){return yl(n)}l.serialization.registerClass(Gl);class tt extends l.serialization.Serializable{getConfig(){return{}}}let Ox=(()=>{class n extends tt{apply(e,s=1){return function cy(n,t=1){if(1!==t)throw new oe(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return l.elu(n)}(e,s)}}return n.className="elu",n})();l.serialization.registerClass(Ox);let zx=(()=>{class n extends tt{apply(e){return l.selu(e)}}return n.className="selu",n})();l.serialization.registerClass(zx);let Lx=(()=>{class n extends tt{apply(e){return l.relu(e)}}return n.className="relu",n})();l.serialization.registerClass(Lx);let Px=(()=>{class n extends tt{apply(e){return(0,l.tidy)(()=>l.minimum(6,l.relu(e)))}}return n.className="relu6",n})();l.serialization.registerClass(Px),l.serialization.registerClass((()=>{class n extends tt{apply(e){return e}}return n.className="linear",n})());let Bx=(()=>{class n extends tt{apply(e){return l.sigmoid(e)}}return n.className="sigmoid",n})();l.serialization.registerClass(Bx);let Mx=(()=>{class n extends tt{apply(e){return function py(n){return(0,l.tidy)(()=>{const t=l.add(.5,l.mul(.2,n));return l.clipByValue(t,0,1)})}(e)}}return n.className="hardSigmoid",n})();l.serialization.registerClass(Mx);let Wx=(()=>{class n extends tt{apply(e){return l.softplus(e)}}return n.className="softplus",n})();l.serialization.registerClass(Wx);let Gx=(()=>{class n extends tt{apply(e){return function dy(n){return(0,l.tidy)(()=>l.div(n,l.add(l.abs(n),1)))}(e)}}return n.className="softsign",n})();l.serialization.registerClass(Gx);let Ux=(()=>{class n extends tt{apply(e){return l.tanh(e)}}return n.className="tanh",n})();l.serialization.registerClass(Ux);let Ul=(()=>{class n extends tt{apply(e,s=-1){return l.softmax(e,s)}}return n.className="softmax",n})();l.serialization.registerClass(Ul);let Hx=(()=>{class n extends tt{apply(e,s=-1){return l.logSoftmax(e,s)}}return n.className="logSoftmax",n})();l.serialization.registerClass(Hx);let jx=(()=>{class n extends tt{apply(e,s=1){return(0,l.tidy)(()=>l.mul(l.sigmoid(l.mul(e,s)),e))}}return n.className="swish",n})();l.serialization.registerClass(jx);let Xx=(()=>{class n extends tt{apply(e){return(0,l.tidy)(()=>l.mul(e,l.tanh(l.softplus(e))))}}return n.className="mish",n})();function nn(n){return n.getClassName()}function Za(n,t={}){return os(n,l.serialization.SerializationMap.getMap().classNameMap,t,"activation")}function sn(n){if(null==n){return Za({className:"linear",config:{}})}if("string"==typeof n){const t={};return t.className=n,t.config={},Za(t)}return n instanceof tt?n:Za(n)}l.serialization.registerClass(Xx);class Hl extends l.serialization.Serializable{}let Qa=(()=>{class n extends Hl{constructor(e){super(),function Ya(n){if(null!=n&&"object"!=typeof n)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return(0,l.tidy)(()=>{let s=(0,l.zeros)([1]);return this.hasL1&&(s=(0,l.add)(s,(0,l.sum)(l.mul(this.l1,(0,l.abs)(e))))),this.hasL2&&(s=(0,l.add)(s,(0,l.sum)(l.mul(this.l2,cs(e))))),l.reshape(s,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,s){return new e({l1:s.l1,l2:s.l2})}}return n.className="L1L2",n})();l.serialization.registerClass(Qa);const jl={l1l2:"L1L2"};function Ce(n){return va(n)}function Xl(n,t={}){return os(n,l.serialization.SerializationMap.getMap().classNameMap,t,"regularizer")}function Re(n){return null==n?null:"string"==typeof n?Xl({className:n in jl?jl[n]:n,config:{}}):n instanceof Hl?n:Xl(n)}let Kl=(()=>{class n extends ue{constructor(e){super(e??{}),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,s){e=ie(e);let r=(0,l.relu)(e);return null!=this.maxValue&&(r=(0,l.clipByValue)(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ReLU",n})();l.serialization.registerClass(Kl);let ql=(()=>{class n extends ue{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,s){const r=ie(e);return(0,l.leakyRelu)(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},s=super.getConfig();return Object.assign(e,s),e}}return n.className="LeakyReLU",n})();l.serialization.registerClass(ql);let Zl=(()=>{class n extends ue{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=ke(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Re(e.alphaRegularizer),this.alphaConstraint=Me(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!=typeof e.sharedAxes)throw new k(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const s=(e=he(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)s[a-1]=1;this.alpha=this.addWeight("alpha",s,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)r[a]=e[a];this.inputSpec=[new Ve({ndim:e.length,axes:r})],this.built=!0}call(e,s){return e=ie(e),(0,l.prelu)(e,this.alpha.read())}getConfig(){const e={alphaInitializer:De(this.alphaInitializer),alphaRegularizer:Ce(this.alphaRegularizer),alphaConstraint:Be(this.alphaConstraint),sharedAxes:this.sharedAxes},s=super.getConfig();return Object.assign(e,s),e}}return n.className="PReLU",n})();l.serialization.registerClass(Zl);let Yl=(()=>{class n extends ue{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new oe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,s){const r=ie(e);return(0,l.elu)(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ELU",n})();l.serialization.registerClass(Yl);let Ql=(()=>{class n extends ue{constructor(e){super(e??{}),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,s){const r=ie(e);return(0,l.mul)(r,(0,l.cast)((0,l.greater)(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ThresholdedReLU",n})();l.serialization.registerClass(Ql);let Jl=(()=>{class n extends ue{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new Ul).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,s){const r=ie(e);return this.softmax(r,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Softmax",n})();function Un(n,t,e){if("number"==typeof n)return bn(n,t);if(n.length!==t)throw new k(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let s=0;s<t;++s){const r=n[s];if(!ry(r))throw new k(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${r}`)}return n}function Tt(n,t,e,s,r=1){if(null==n)return n;let i;return i="same"===e?n:n-(t+(t-1)*(r-1))+1,Math.floor((i+s-1)/s)}function Ot(n,t,e,s){if(null==n)return null;if("valid"===s)n=n*t+Jt([e-t,0]);else{if("same"!==s)throw new k(`Unsupport padding mode: ${s}.`);n*=t}return n}function Ja(n,t){return(0,l.tidy)(()=>(Fe(t),"channelsFirst"===t?l.transpose(n,[0,2,3,1]):n))}function eu(n,t){return(0,l.tidy)(()=>(Fe(t),"channelsFirst"===t?l.transpose(n,[0,2,3,4,1]):n))}function ei(n,t,e,s=[1,1],r="valid",a,i,o=null){return(0,l.tidy)(()=>{if(null==a&&(a="channelsLast"),Fe(a),3!==n.rank&&4!==n.rank)throw new k(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(3!==t.rank&&4!==t.rank)throw new k(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=Ja(n,a);if("causal"===r)throw new oe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=l.fused.conv2d({x:u,filter:t,strides:s,pad:"same"===r?"same":"valid",dilations:i,dataFormat:"NHWC",bias:e,activation:o}),"channelsFirst"===a&&(u=l.transpose(u,[0,3,1,2])),u})}l.serialization.registerClass(Jl);class rr extends ue{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",rr.verifyArgs(e),this.rank=t,Ge(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new oe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Un(e.kernelSize,t,"kernelSize"),this.strides=Un(null==e.strides?1:e.strides,t,"strides"),this.padding=null==e.padding?"valid":e.padding,lt(this.padding),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Fe(this.dataFormat),this.activation=sn(e.activation),this.useBias=null==e.useBias||e.useBias,this.biasInitializer=ke(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Me(e.biasConstraint),this.biasRegularizer=Re(e.biasRegularizer),this.activityRegularizer=Re(e.activityRegularizer),this.dilationRate=Un(null==e.dilationRate?1:e.dilationRate,t,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new k(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new k(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"==typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new k(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(t){if(ot("kernelSize"in t,"required key 'kernelSize' not in config"),"number"!=typeof t.kernelSize&&!Ia(t.kernelSize,"number",1,3))throw new k(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:nn(this.activation),useBias:this.useBias,biasInitializer:De(this.biasInitializer),biasRegularizer:Ce(this.biasRegularizer),activityRegularizer:Ce(this.activityRegularizer),biasConstraint:Be(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class Hn extends rr{constructor(t,e){super(t,e),this.kernel=null,Hn.verifyArgs(e),this.filters=e.filters,Ge(this.filters,"filters"),this.kernelInitializer=ke(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Me(e.kernelConstraint),this.kernelRegularizer=Re(e.kernelRegularizer)}build(t){t=he(t);const e="channelsFirst"===this.dataFormat?1:t.length-1;if(null==t[e])throw new k(`The channel dimension of the input should be defined. Found ${t[e]}`);const s=t[e],r=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:s}}],this.built=!0}call(t,e){return(0,l.tidy)(()=>{let s;t=ie(t);const r=null==this.bias?null:this.bias.read(),a=qo(this.activation.getClassName());if(null!=a&&2===this.rank)s=ei(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)s=function tu(n,t,e,s=1,r="valid",a,i=1){return(0,l.tidy)(()=>{if(null==a&&(a="channelsLast"),Fe(a),3!==n.shape.length)throw new k(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(3!==t.shape.length)throw new k(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=e&&1!==e.shape.length)throw new k(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if("channelsFirst"===a&&(n=l.transpose(n,[0,2,1])),"causal"===r)throw new oe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=l.conv1d(n,t,s,"same"===r?"same":"valid","NWC",i);return null!=e&&(o=It(o,e)),o})}(t,this.kernel.read(),r,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)s=ei(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new oe("convolutions greater than 3D are not implemented yet.");s=function nu(n,t,e,s=[1,1,1],r="valid",a,i){return(0,l.tidy)(()=>{if(null==a&&(a="channelsLast"),Fe(a),4!==n.rank&&5!==n.rank)throw new k(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(4!==t.rank&&5!==t.rank)throw new k(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=eu(n,a);if("causal"===r)throw new oe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=l.conv3d(o,t,s,"same"===r?"same":"valid","NDHWC",i),null!=e&&(o=It(o,e)),"channelsFirst"===a&&(o=l.transpose(o,[0,4,1,2,3])),o})}(t,this.kernel.read(),r,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(s=this.activation.apply(s))}return s})}computeOutputShape(t){t=he(t);const e=[],s="channelsLast"===this.dataFormat?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<s.length;++a){const i=Tt(s[a],this.kernelSize[a],this.padding,this.strides[a],"number"==typeof this.dilationRate?this.dilationRate:this.dilationRate[a]);e.push(i)}let r=[t[0]];return"channelsLast"===this.dataFormat?(r=r.concat(e),r.push(this.filters)):(r.push(this.filters),r=r.concat(e)),r}getConfig(){const t={filters:this.filters,kernelInitializer:De(this.kernelInitializer),kernelRegularizer:Ce(this.kernelRegularizer),kernelConstraint:Be(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||"number"!=typeof t.filters||t.filters<1)throw new k(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}let ti=(()=>{class n extends Hn{constructor(e){super(2,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Ia(e.kernelSize,"number",1,2))throw new k(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv2D",n})();l.serialization.registerClass(ti);let ni=(()=>{class n extends Hn{constructor(e){super(3,e),n.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new k(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv3D",n})();l.serialization.registerClass(ni);let su=(()=>{class n extends ti{constructor(e){if(super(e),this.inputSpec=[new Ve({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new k(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=he(e)).length)throw new k("Input should have rank 4; Received input shape: "+JSON.stringify(e));const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new k("The channel dimension of the inputs should be defined. Found `None`.");const r=e[s],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ve({ndim:4,axes:{[s]:r}})],this.built=!0}call(e,s){return l.tidy(()=>{let r=ie(e);if(4!==r.shape.length)throw new k(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const a=r.shape;let o,u;"channelsFirst"===this.dataFormat?(o=2,u=3):(o=1,u=2);const d=a[u],h=this.kernelSize[1],m=this.strides[1],x=[a[0],Ot(a[o],this.strides[0],this.kernelSize[0],this.padding),Ot(d,m,h,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=l.transpose(r,[0,2,3,1]));let b=l.conv2dTranspose(r,this.kernel.read(),x,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=l.transpose(b,[0,3,1,2])),null!=this.bias&&(b=It(b,this.bias.read(),this.dataFormat)),null!=this.activation&&(b=this.activation.apply(b)),b})}computeOutputShape(e){const s=(e=he(e)).slice();let r,a,i;"channelsFirst"===this.dataFormat?(r=1,a=2,i=3):(r=3,a=1,i=2);const o=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],d=this.strides[1];return s[r]=this.filters,s[a]=Ot(s[a],c,o,this.padding),s[i]=Ot(s[i],d,u,this.padding),s}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv2DTranspose",n})();l.serialization.registerClass(su);let ru=(()=>{class n extends ni{constructor(e){if(super(e),this.inputSpec=[new Ve({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new k(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=he(e)).length)throw new k("Input should have rank 5; Received input shape: "+JSON.stringify(e));const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s])throw new k("The channel dimension of the inputs should be defined. Found `None`.");const r=e[s],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ve({ndim:5,axes:{[s]:r}})],this.built=!0}call(e,s){return l.tidy(()=>{let r=ie(e);if(5!==r.shape.length)throw new k(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const a=r.shape;let o,u,c;"channelsFirst"===this.dataFormat?(c=2,o=3,u=4):(c=1,o=2,u=3);const p=a[o],h=a[u],m=this.kernelSize[1],y=this.kernelSize[2],x=this.strides[1],b=this.strides[2],w=[a[0],Ot(a[c],this.strides[0],this.kernelSize[0],this.padding),Ot(p,x,m,this.padding),Ot(h,b,y,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(r=l.transpose(r,[0,2,3,4,1]));let N=l.conv3dTranspose(r,this.kernel.read(),w,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(N=l.transpose(N,[0,4,1,2,3])),null!==this.bias&&(N=It(N,this.bias.read(),this.dataFormat)),null!==this.activation&&(N=this.activation.apply(N)),N})}computeOutputShape(e){const s=(e=he(e)).slice();let r,a,i,o;"channelsFirst"===this.dataFormat?(r=1,a=2,i=3,o=4):(r=4,a=1,i=2,o=3);const u=this.kernelSize[0],c=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],h=this.strides[1],f=this.strides[2];return s[r]=this.filters,s[a]=Ot(s[a],p,u,this.padding),s[i]=Ot(s[i],h,c,this.padding),s[o]=Ot(s[o],f,d,this.padding),s}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}return n.className="Conv3DTranspose",n})();l.serialization.registerClass(ru);let Kx=(()=>{class n extends Hn{constructor(e,s){if(super(e,s),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==s.filters)throw new k("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=s.kernelInitializer||null!=s.kernelRegularizer||null!=s.kernelConstraint)throw new k("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=s.padding&&"same"!==s.padding&&"valid"!==s.padding)throw new k(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(s.padding)}`);this.depthMultiplier=null==s.depthMultiplier?1:s.depthMultiplier,this.depthwiseInitializer=ke(s.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Re(s.depthwiseRegularizer),this.depthwiseConstraint=Me(s.depthwiseConstraint),this.pointwiseInitializer=ke(s.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Re(s.pointwiseRegularizer),this.pointwiseConstraint=Me(s.pointwiseConstraint)}build(e){if((e=he(e)).length<this.rank+2)throw new k(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const s="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[s]||e[s]<0)throw new k(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[s])}`);const r=e[s],a=this.kernelSize.concat([r,this.depthMultiplier]),i=[];for(let u=0;u<this.rank;++u)i.push(1);i.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",i,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):null,this.inputSpec=[new Ve({ndim:this.rank+2,axes:{[s]:r}})],this.built=!0}call(e,s){return(0,l.tidy)(()=>{let r;if(e=ie(e),1===this.rank)throw new oe("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=l.transpose(e,[0,2,3,1])),r=l.separableConv2d(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=It(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),"channelsFirst"===this.dataFormat&&(r=l.transpose(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=De(this.depthwiseInitializer),e.pointwiseInitializer=De(this.pointwiseInitializer),e.depthwiseRegularizer=Ce(this.depthwiseRegularizer),e.pointwiseRegularizer=Ce(this.pointwiseRegularizer),e.depthwiseConstraint=Be(this.depthwiseConstraint),e.pointwiseConstraint=Be(this.pointwiseConstraint),e}}return n.className="SeparableConv",n})(),au=(()=>{class n extends Kx{constructor(e){super(2,e)}}return n.className="SeparableConv2D",n})();l.serialization.registerClass(au);let iu=(()=>{class n extends Hn{constructor(e){super(1,e),n.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!=typeof e.kernelSize&&!Ia(e.kernelSize,"number",1,1))throw new k(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}return n.className="Conv1D",n})();l.serialization.registerClass(iu);let ou=(()=>{class n extends ue{constructor(e){super(e),this.cropping="number"==typeof e.cropping?[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"==typeof e.cropping[0]?[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,s){return(0,l.tidy)(()=>{if(e=ie(e),"channelsLast"===this.dataFormat){const r=Gs(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Gs(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const r=Gs(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Gs(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Cropping2D",n})();l.serialization.registerClass(ou);let lu=(()=>{class n extends ue{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,Fe(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,function ty(n){vn(Yg,"InterpolationFormat",n)}(this.interpolation)}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],null==e[2]?null:this.size[0]*e[2],null==e[3]?null:this.size[1]*e[3]]:[e[0],null==e[1]?null:this.size[0]*e[1],null==e[2]?null:this.size[1]*e[2],e[3]]}call(e,s){return l.tidy(()=>{let r=ie(e);const a=r.shape;if("channelsFirst"===this.dataFormat){r=l.transpose(r,[0,2,3,1]);const i=this.size[0]*a[2],o=this.size[1]*a[3],u="nearest"===this.interpolation?l.image.resizeNearestNeighbor(r,[i,o]):l.image.resizeBilinear(r,[i,o]);return l.transpose(u,[0,3,1,2])}{const i=this.size[0]*a[1],o=this.size[1]*a[2];return"nearest"===this.interpolation?l.image.resizeNearestNeighbor(r,[i,o]):l.image.resizeBilinear(r,[i,o])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},s=super.getConfig();return Object.assign(e,s),e}}return n.className="UpSampling2D",n})();l.serialization.registerClass(lu);let uu=(()=>{class n extends rr{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=ke(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Me(e.depthwiseConstraint),this.depthwiseRegularizer=Re(e.depthwiseRegularizer)}build(e){if((e=he(e)).length<4)throw new k(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const s="channelsFirst"===this.dataFormat?1:3;if(null==e[s]||e[s]<0)throw new k(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[s]}).`);const r=e[s];this.depthwiseKernel=this.addWeight("depthwise_kernel",[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier],null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.bias=this.useBias?this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return(0,l.tidy)(()=>{let r=function qx(n,t,e=[1,1],s="valid",r,a){return(0,l.tidy)(()=>{null==r&&(r="channelsLast"),Fe(r);let i=Ja(n,r);if(4!==n.rank)throw new k(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(4!==t.rank)throw new k(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=l.depthwiseConv2d(i,t,e,"same"===s?"same":"valid","NHWC",a),"channelsFirst"===r&&(i=l.transpose(i,[0,3,1,2])),i})}(e=ie(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=It(r,this.bias.read(),this.dataFormat)),null!=this.activation&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=he(e);const r="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,i=Tt("channelsFirst"===this.dataFormat?e[2]:e[1],this.kernelSize[0],this.padding,this.strides[0]),o=Tt(r,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,i,o]:[e[0],i,o,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=De(this.depthwiseInitializer),e.depthwiseRegularizer=Ce(this.depthwiseRegularizer),e.depthwiseConstraint=Be(this.depthwiseRegularizer),e}}return n.className="DepthwiseConv2D",n})();function cu(n,t,e,s){if(Array.isArray(n)){if(null!=t||null!=e)throw new k("When inputs is an array, neither initialState or constants should be provided");null!=s&&(e=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function r(a){return null==a||Array.isArray(a)?a:[a]}return{inputs:n,initialState:t=r(t),constants:e=r(e)}}function du(n,t,e,s=!1,r,a,i=!1,o=!1){return l.tidy(()=>{const u=t.shape.length;if(u<3)throw new k(`Input should be at least 3D, but is ${u}D.`);const c=[1,0].concat(vt(2,u));if(t=l.transpose(t,c),null!=a)throw new oe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&((r=l.cast(l.cast(r,"bool"),"float32")).rank===u-1&&(r=l.expandDims(r,-1)),r=l.transpose(r,c)),s&&(t=l.reverse(t,0),null!=r&&(r=l.reverse(r,0)));const d=[];let p,h=e;const f=t.shape[0],m=l.unstack(t);let y,g;null!=r&&(y=l.unstack(r));for(let x=0;x<f;++x){const b=m[x],S=l.tidy(()=>n(b,h));if(null==r)p=S[0],h=S[1];else{const v=l.tidy(()=>{const I=y[x],w=l.sub(l.onesLike(I),I);return{output:l.add(l.mul(S[0],I),l.mul(h[0],w)),newStates:h.map((D,A)=>l.add(l.mul(S[1][A],I),l.mul(D,w)))}});p=v.output,h=v.newStates}o&&d.push(p)}return o&&(g=l.stack(d,1)),[p,g,h]})}l.serialization.registerClass(uu);let wn=(()=>{class n extends ue{constructor(e){let s;if(super(e),null==e.cell)throw new k("cell property is missing for the constructor of RNN.");if(s=Array.isArray(e.cell)?new ai({cells:e.cell}):e.cell,null==s.stateSize)throw new k("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=s,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ve({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){return null==this.states_?vt(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map(s=>null):this.states_}setStates(e){this.states_=e}computeOutputShape(e){Ra(e)&&(e=e[0]);let s=this.cell.stateSize;Array.isArray(s)||(s=[s]);const r=s[0];let a;if(a=this.returnSequences?[e[0],e[1],r]:[e[0],r],this.returnState){const i=[];for(const o of s)i.push([e[0],o]);return[a].concat(i)}return a}computeMask(e,s){return l.tidy(()=>{Array.isArray(s)&&(s=s[0]);const r=this.returnSequences?s:null;if(this.returnState){const a=this.states.map(i=>null);return[r].concat(a)}return r})}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,s=[];for(let r=0;r<e;++r)s.push(null);return s}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new oe("Constants support is not implemented in RNN yet.");Ra(e)&&(e=e[0]);const r=this.stateful?e[0]:null,a=e.slice(2);this.inputSpec[0]=new Ve({shape:[r,null,...a]});const i=[e[0]].concat(e.slice(2));let o;if(this.cell.build(i),o=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!l.util.arraysEqual(this.stateSpec.map(u=>u.shape[u.shape.length-1]),o))throw new k(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=o.map(u=>new Ve({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,s=!1){(0,l.tidy)(()=>{if(!this.stateful)throw new Dt("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(null==r)throw new k("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(a=>l.zeros([r,a])):[l.zeros([r,this.cell.stateSize])];else if(null==e)l.dispose(this.states_),null!=this.keptStates&&(l.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>l.zeros([r,a])):this.states_[0]=l.zeros([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new k(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===s?this.keptStates.push(this.states_.slice()):l.dispose(this.states_);for(let a=0;a<this.states_.length;++a){const i=e[a],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,u=[r,o];if(!l.util.arraysEqual(i.shape,u))throw new k(`State ${a} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${i.shape}`);this.states_[a]=i}}this.states_=this.states_.map(a=>l.keep(a.clone()))})}apply(e,s){let r=null==s?null:s.initialState,a=null==s?null:s.constants;null==s&&(s={});const i=cu(e,r,a,this.numConstants);e=i.inputs,r=i.initialState,a=i.constants;let o=[],u=[];if(null!=r){s.initialState=r,o=o.concat(r),this.stateSpec=[];for(const d of r)this.stateSpec.push(new Ve({shape:d.shape}));u=u.concat(this.stateSpec)}if(null!=a&&(s.constants=a,o=o.concat(a),this.numConstants=a.length),o[0]instanceof Ft){const d=[e].concat(o),p=this.inputSpec.concat(u),h=this.inputSpec;this.inputSpec=p;const f=super.apply(d,s);return this.inputSpec=h,f}return super.apply(e,s)}call(e,s){return(0,l.tidy)(()=>{const r=null==s?null:s.mask,a=null==s?null:s.training;let i=null==s?null:s.initialState;e=ie(e),null==i&&(i=this.stateful?this.states_:this.getInitialState(e));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(i.length!==o)throw new k(`RNN Layer has ${o} state(s) but was passed ${i.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const u={training:a},d=du((y,g)=>{const x=this.cell.call([y].concat(g),u);return[x[0],x.slice(1)]},e,i,this.goBackwards,r,null,this.unroll,this.returnSequences),p=d[0],h=d[1],f=d[2];this.stateful&&this.resetStates(f,a);const m=this.returnSequences?h:p;return this.returnState?[m].concat(f):m})}getInitialState(e){return(0,l.tidy)(()=>{let s=l.zeros(e.shape);return s=l.sum(s,[1,2]),s=us(s),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?Ta(s,[1,r]):s):this.cell.stateSize>1?[Ta(s,[1,this.cell.stateSize])]:[s]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),s={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(s.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===n.className&&(s.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),s)}static fromConfig(e,s,r={}){const i=Wt(s.cell,r);return new e(Object.assign(s,{cell:i}))}}return n.className="RNN",n})();l.serialization.registerClass(wn);class ys extends ue{}let si=(()=>{class n extends ys{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ge(this.units,"units"),this.activation=sn(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ke(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ke(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ke(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Re(e.kernelRegularizer),this.recurrentRegularizer=Re(e.recurrentRegularizer),this.biasRegularizer=Re(e.biasRegularizer),this.kernelConstraint=Me(e.kernelConstraint),this.recurrentConstraint=Me(e.recurrentConstraint),this.biasConstraint=Me(e.biasConstraint),this.dropout=Mn([1,Jt([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Mn([1,Jt([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=he(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return(0,l.tidy)(()=>{if(2!==e.length)throw new k(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const a=null!=s.training&&s.training;let i;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rn({ones:()=>l.onesLike(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rn({ones:()=>l.onesLike(r),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,u=this.recurrentDropoutMask;i=Et(null!=o?l.mul(e,o):e,this.kernel.read()),null!=this.bias&&(i=It(i,this.bias.read())),null!=u&&(r=l.mul(r,u));let c=l.add(i,Et(r,this.recurrentKernel.read()));return null!=this.activation&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:nn(this.activation),useBias:this.useBias,kernelInitializer:De(this.kernelInitializer),recurrentInitializer:De(this.recurrentInitializer),biasInitializer:De(this.biasInitializer),kernelRegularizer:Ce(this.kernelRegularizer),recurrentRegularizer:Ce(this.recurrentRegularizer),biasRegularizer:Ce(this.biasRegularizer),activityRegularizer:Ce(this.activityRegularizer),kernelConstraint:Be(this.kernelConstraint),recurrentConstraint:Be(this.recurrentConstraint),biasConstraint:Be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),s)}}return n.className="SimpleRNNCell",n})();l.serialization.registerClass(si);let pu=(()=>{class n extends wn{constructor(e){e.cell=new si(e),super(e)}call(e,s){return(0,l.tidy)(()=>(null!=this.cell.dropoutMask&&(l.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return new e(s)}}return n.className="SimpleRNN",n})();l.serialization.registerClass(pu);let ri=(()=>{class n extends ys{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new k("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Ge(this.units,"units"),this.activation=sn(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sn(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ke(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ke(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ke(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Re(e.kernelRegularizer),this.recurrentRegularizer=Re(e.recurrentRegularizer),this.biasRegularizer=Re(e.biasRegularizer),this.kernelConstraint=Me(e.kernelConstraint),this.recurrentConstraint=Me(e.recurrentConstraint),this.biasConstraint=Me(e.biasConstraint),this.dropout=Mn([1,Jt([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Mn([1,Jt([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=he(e),this.kernel=this.addWeight("kernel",[e[e.length-1],3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.bias=this.useBias?this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):null,this.built=!0}call(e,s){return(0,l.tidy)(()=>{if(2!==e.length)throw new k(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=null!=s.training&&s.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rn({ones:()=>l.onesLike(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rn({ones:()=>l.onesLike(a),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const o=this.recurrentDropoutMask;let u,c,d;0<this.dropout&&this.dropout<1&&(e=l.mul(e,this.dropoutMask[0]));let p=Et(e,this.kernel.read());this.useBias&&(p=It(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=l.mul(a,o[0]));const h=this.recurrentKernel.read(),[f,m]=l.split(h,[2*this.units,this.units],h.rank-1),y=Et(a,f),[g,x,b]=l.split(p,3,p.rank-1),[S,v]=l.split(y,2,y.rank-1);u=this.recurrentActivation.apply(l.add(g,S)),c=this.recurrentActivation.apply(l.add(x,v));const I=Et(l.mul(c,a),m);d=this.activation.apply(l.add(b,I));const w=l.add(l.mul(u,a),l.mul(l.add(1,l.neg(u)),d));return[w,w]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:nn(this.activation),recurrentActivation:nn(this.recurrentActivation),useBias:this.useBias,kernelInitializer:De(this.kernelInitializer),recurrentInitializer:De(this.recurrentInitializer),biasInitializer:De(this.biasInitializer),kernelRegularizer:Ce(this.kernelRegularizer),recurrentRegularizer:Ce(this.recurrentRegularizer),biasRegularizer:Ce(this.biasRegularizer),activityRegularizer:Ce(this.activityRegularizer),kernelConstraint:Be(this.kernelConstraint),recurrentConstraint:Be(this.recurrentConstraint),biasConstraint:Be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),s)}}return n.className="GRUCell",n})();l.serialization.registerClass(ri);let hu=(()=>{class n extends wn{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ri(e),super(e)}call(e,s){return(0,l.tidy)(()=>(null!=this.cell.dropoutMask&&(l.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return 0===s.implmentation&&(s.implementation=1),new e(s)}}return n.className="GRU",n})();l.serialization.registerClass(hu);let ar=(()=>{class n extends ys{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Ge(this.units,"units"),this.activation=sn(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=sn(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=ke(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=ke(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=ke(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Re(e.kernelRegularizer),this.recurrentRegularizer=Re(e.recurrentRegularizer),this.biasRegularizer=Re(e.biasRegularizer),this.kernelConstraint=Me(e.kernelConstraint),this.recurrentConstraint=Me(e.recurrentConstraint),this.biasConstraint=Me(e.biasConstraint),this.dropout=Mn([1,Jt([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Mn([1,Jt([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var s;let a;if(e=he(e),this.kernel=this.addWeight("kernel",[e[e.length-1],4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const i=this.biasInitializer,o=this.units;a=new((s=class extends mt{apply(c,d){const p=i.apply([o]),h=(new il).apply([o]),f=i.apply([2*o]);return sl(sl(p,h),f)}}).className="CustomInit",s)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,s){return(0,l.tidy)(()=>{const r=null!=s.training&&s.training;if(3!==e.length)throw new k(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let a=e[1];const i=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rn({ones:()=>l.onesLike(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rn({ones:()=>l.onesLike(a),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const u=this.recurrentDropoutMask;let c,d,p,h;0<this.dropout&&this.dropout<1&&(e=l.mul(e,this.dropoutMask[0]));let f=Et(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=l.mul(a,u[0])),f=l.add(f,Et(a,this.recurrentKernel.read())),this.useBias&&(f=It(f,this.bias.read()));const[m,y,g,x]=l.split(f,4,f.rank-1);c=this.recurrentActivation.apply(m),d=this.recurrentActivation.apply(y),p=l.add(l.mul(d,i),l.mul(c,this.activation.apply(g))),h=this.recurrentActivation.apply(x);const b=l.mul(h,this.activation.apply(p));return[b,b,p]})}getConfig(){const e=super.getConfig(),s={units:this.units,activation:nn(this.activation),recurrentActivation:nn(this.recurrentActivation),useBias:this.useBias,kernelInitializer:De(this.kernelInitializer),recurrentInitializer:De(this.recurrentInitializer),biasInitializer:De(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Ce(this.kernelRegularizer),recurrentRegularizer:Ce(this.recurrentRegularizer),biasRegularizer:Ce(this.biasRegularizer),activityRegularizer:Ce(this.activityRegularizer),kernelConstraint:Be(this.kernelConstraint),recurrentConstraint:Be(this.recurrentConstraint),biasConstraint:Be(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),s)}}return n.className="LSTMCell",n})();l.serialization.registerClass(ar);let fu=(()=>{class n extends wn{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ar(e),super(e)}call(e,s){return(0,l.tidy)(()=>(null!=this.cell.dropoutMask&&(l.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})))}static fromConfig(e,s){return 0===s.implmentation&&(s.implementation=1),new e(s)}}return n.className="LSTM",n})();l.serialization.registerClass(fu);let ai=(()=>{class n extends ys{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const s of this.cells.slice().reverse())Array.isArray(s.stateSize)?e.push(...s.stateSize):e.push(s.stateSize);return e}call(e,s){return(0,l.tidy)(()=>{let r=e.slice(1);const a=[];for(const u of this.cells.slice().reverse())Array.isArray(u.stateSize)?a.push(r.splice(0,u.stateSize.length)):a.push(r.splice(0,1));a.reverse();const i=[];let o;for(let u=0;u<this.cells.length;++u){const c=this.cells[u];r=a[u],o=0===u?[e[0]].concat(r):[o[0]].concat(r),o=c.call(o,s),i.push(o.slice(1))}r=[];for(const u of i.slice().reverse())r.push(...u);return[o[0]].concat(r)})}build(e){let s;Ra(e)&&(e=e[0]),this.cells.forEach((r,a)=>{Sn(`RNNCell_${a}`,()=>{r.build(e),s=Array.isArray(r.stateSize)?r.stateSize[0]:r.stateSize,e=[e[0],s]})}),this.built=!0}getConfig(){const e=super.getConfig(),a={cells:this.cells.map(i=>({className:i.getClassName(),config:i.getConfig()}))};return Object.assign(Object.assign({},e),a)}static fromConfig(e,s,r={}){const a=[];for(const i of s.cells)a.push(Wt(i,r));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const s of this.cells)e.push(...s.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const s of this.cells)e.push(...s.nonTrainableWeights);if(!this.trainable){const s=[];for(const r of this.cells)s.push(...r.trainableWeights);return s.concat(e)}return e}getWeights(){const e=[];for(const s of this.cells)e.push(...s.weights);return Aa(e)}setWeights(e){const s=[];for(const r of this.cells){const i=e.splice(r.weights.length);for(let o=0;o<r.weights.length;++o)s.push([r.weights[o],i[o]])}Da(s)}}return n.className="StackedRNNCells",n})();function rn(n){const{ones:t,rate:e,training:s=!1,count:r=1,dropoutFunc:a}=n,i=()=>null!=a?a(t(),e):al(t(),e),o=()=>ds(i,t,s);return!r||r<=1?l.keep(o().clone()):Array(r).fill(void 0).map(o).map(c=>l.keep(c.clone()))}l.serialization.registerClass(ai);let Yx=(()=>{class n extends wn{constructor(e){if(e.unroll)throw new oe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new oe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Ve({ndim:5})]}call(e,s){return l.tidy(()=>{if(null!=this.cell.dropoutMask&&(l.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(l.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),s&&s.constants)throw new k("ConvRNN2D cell does not support constants");return super.call(e,{mask:null==s?null:s.mask,training:null==s?null:s.training,initialState:null==s?null:s.initialState})})}computeOutputShape(e){let s=this.computeSingleOutputShape(e);return this.returnSequences||(s=[s[0],...s.slice(2)]),this.returnState&&(s=[s,...Array(2).fill([e[0],...s.slice(-3)])]),s}getInitialState(e){return l.tidy(()=>{const{stateSize:s}=this.cell,a=this.computeSingleOutputShape(e.shape),i=[a[0],...a.slice(2)],o=l.zeros(i);return Array.isArray(s)?Array(s.length).fill(o):[o]})}resetStates(e,s=!1){l.tidy(()=>{if(!this.stateful)throw new Dt("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,a=this.computeSingleOutputShape(r),i=[a[0],...a.slice(2)];if(null==r[0])throw new k("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())this.states_=Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(()=>l.zeros(i)):[l.zeros(i)];else if(null==e)l.dispose(this.states_),null!=this.keptStates&&(l.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>l.zeros(i)):this.states_[0]=l.zeros(i);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new k(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);s?this.keptStates.push(this.states_.slice()):l.dispose(this.states_);for(let u=0;u<this.states_.length;++u){const c=e[u],d=i;if(!l.util.arraysEqual(c.shape,d))throw new k(`State ${u} is incompatible with layer ${this.name}: expected shape=${d}, received shape=${c.shape}`);this.states_[u]=c}}this.states_=this.states_.map(u=>l.keep(u.clone()))})}computeSingleOutputShape(e){const{dataFormat:s,filters:r,kernelSize:a,padding:i,strides:o,dilationRate:u}=this.cell,c="channelsFirst"===s,p=e[c?4:3],h=Tt(e[c?3:2],a[0],i,o[0],u[0]),f=Tt(p,a[1],i,o[1],u[1]);return[...e.slice(0,2),...c?[r,h,f]:[h,f,r]]}}return n.className="ConvRNN2D",n})(),ii=(()=>{class n extends ar{constructor(e){const{filters:s,kernelSize:r,strides:a,padding:i,dataFormat:o,dilationRate:u}=e;super(Object.assign(Object.assign({},e),{units:s})),this.filters=s,Ge(this.filters,"filters"),this.kernelSize=Un(r,2,"kernelSize"),this.kernelSize.forEach(c=>Ge(c,"kernelSize")),this.strides=Un(a||1,2,"strides"),this.strides.forEach(c=>Ge(c,"strides")),this.padding=i||"valid",lt(this.padding),this.dataFormat=o||"channelsLast",Fe(this.dataFormat),this.dilationRate=Un(u||1,2,"dilationRate"),this.dilationRate.forEach(c=>Ge(c,"dilationRate"))}build(e){var s;e=he(e);const r="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[r])throw new k(`The channel dimension of the input should be defined. Found ${e[r]}`);const o=this.kernelSize.concat([e[r],4*this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const u=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",u,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const d=this.biasInitializer,p=this.filters;c=new((s=class extends mt{apply(f,m){return Na([d.apply([p]),l.ones([p]),d.apply([2*p])])}}).className="CustomInit",s)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,s){return l.tidy(()=>{if(3!==e.length)throw new k(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=s.training||!1,a=e[0],i=e[1],o=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=rn({ones:()=>l.onesLike(a),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,d=(U,j,H)=>j&&j[H]?l.mul(j[H],U):U;let p=d(a,c,0),h=d(a,c,1),f=d(a,c,2),m=d(a,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=rn({ones:()=>l.onesLike(i),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const y=this.recurrentDropoutMask;let g=d(i,y,0),x=d(i,y,1),b=d(i,y,2),S=d(i,y,3);const[I,w,N,T]=l.split(this.kernel.read(),4,3),[D,A,$,F]=this.useBias?l.split(this.bias.read(),4):[null,null,null,null];p=this.inputConv(p,I,D,this.padding),h=this.inputConv(h,w,A,this.padding),f=this.inputConv(f,N,$,this.padding),m=this.inputConv(m,T,F,this.padding);const[O,L,z,P]=l.split(this.recurrentKernel.read(),4,3);g=this.recurrentConv(g,O),x=this.recurrentConv(x,L),b=this.recurrentConv(b,z),S=this.recurrentConv(S,P);const B=this.recurrentActivation.apply(l.add(p,g)),_=this.recurrentActivation.apply(l.add(h,x)),V=l.add(l.mul(_,o),l.mul(B,this.activation.apply(l.add(f,b)))),G=l.mul(this.recurrentActivation.apply(l.add(m,S)),this.activation.apply(V));return[G,G,V]})}getConfig(){const r=function(n,t){var e={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&t.indexOf(s)<0&&(e[s]=n[s]);if(null!=n&&"function"==typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(n);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(n,s[r])&&(e[s[r]]=n[s[r]])}return e}(super.getConfig(),["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),a)}inputConv(e,s,r,a){const i=l.conv2d(e,s,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return r?It(i,r,this.dataFormat):i}recurrentConv(e,s){return l.conv2d(e,s,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}return n.className="ConvLSTM2DCell",n})();l.serialization.registerClass(ii);let mu=(()=>{class n extends Yx{constructor(e){const s=new ii(e);super(Object.assign(Object.assign({},e),{cell:s}))}static fromConfig(e,s){return new e(s)}}return n.className="ConvLSTM2D",n})();l.serialization.registerClass(mu);let oi=(()=>{class n extends ue{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const s=e.shape,r=[];for(let a=0;a<this.noiseShape.length;++a)r.push(null==this.noiseShape[a]?s[a]:this.noiseShape[a]);return r}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e);if(0<this.rate&&this.rate<1){const a=null!=s.training&&s.training,i=this.getNoiseShape(r);return ds(()=>al(r,this.rate,i,this.seed),()=>r,a)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},s=super.getConfig();return Object.assign(e,s),e}dispose(){return super.dispose()}}return n.className="Dropout",n})();l.serialization.registerClass(oi);let gu=(()=>{class n extends oi{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const s=e.shape;return[s[0],1,s[2]]}}return n.className="SpatialDropout1D",n})();l.serialization.registerClass(gu);let yu=(()=>{class n extends ue{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let s=null;null!=e.batchSize&&(s=e.batchSize),this.batchInputShape=[s,e.inputDim]}this.units=e.units,Ge(this.units,"units"),this.activation=sn(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=ke(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=ke(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Me(e.kernelConstraint),this.biasConstraint=Me(e.biasConstraint),this.kernelRegularizer=Re(e.kernelRegularizer),this.biasRegularizer=Re(e.biasRegularizer),this.activityRegularizer=Re(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const s=(e=he(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[s,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:s}}],this.built=!0}computeOutputShape(e){const s=(e=he(e)).slice();return s[s.length-1]=this.units,s}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e),a=qo(this.activation.getClassName());let i;return null!=a?i=Et(r,this.kernel.read(),a,this.bias?this.bias.read():null):(i=Et(r,this.kernel.read()),null!=this.bias&&(i=It(i,this.bias.read())),null!=this.activation&&(i=this.activation.apply(i))),i})}getConfig(){const e={units:this.units,activation:nn(this.activation),useBias:this.useBias,kernelInitializer:De(this.kernelInitializer),biasInitializer:De(this.biasInitializer),kernelRegularizer:Ce(this.kernelRegularizer),biasRegularizer:Ce(this.biasRegularizer),activityRegularizer:Ce(this.activityRegularizer),kernelConstraint:Be(this.kernelConstraint),biasConstraint:Be(this.biasConstraint)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Dense",n})();l.serialization.registerClass(yu);let xu=(()=>{class n extends ue{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=he(e);for(const s of e.slice(1))if(null==s)throw new k(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Qt(e,1)]}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);let r=ie(e);if("channelsFirst"===this.dataFormat&&r.rank>1){const a=[0];for(let i=2;i<r.rank;++i)a.push(i);a.push(1),r=(0,l.transpose)(r,a)}return function uy(n){if(n.rank<=1)throw new k(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],Qt(n.shape,1)];return l.reshape(n,t)}(r)})}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const s=super.getConfig();return Object.assign(e,s),e}}return n.className="Flatten",n})();l.serialization.registerClass(xu);let bu=(()=>{class n extends ue{constructor(e){super(e),this.supportsMasking=!0,this.activation=sn(e.activation)}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e);return this.activation.apply(r)})}getConfig(){const e={activation:nn(this.activation)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Activation",n})();l.serialization.registerClass(bu);let Cu=(()=>{class n extends ue{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,s){return(0,l.tidy)(()=>function oy(n,t){return(0,l.tidy)(()=>{if(2!==n.shape.length)throw new k(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);return Ta(us(n,1),[1,t,1])})}(e=ie(e),this.n))}getConfig(){const e={n:this.n},s=super.getConfig();return Object.assign(e,s),e}}return n.className="RepeatVector",n})();l.serialization.registerClass(Cu);let vu=(()=>{class n extends ue{constructor(e){super(e),this.targetShape=e.targetShape;for(let s=0;s<this.targetShape.length;++s)this.isUnknown(this.targetShape[s])&&(this.targetShape[s]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,s){const r="Total size of new array must be unchanged.",a=s.slice();let i=1,o=null;for(let c=0;c<a.length;++c){const d=a[c];if(this.isUnknown(d)){if(null!==o)throw new k("Can only specifiy one unknown dimension.");o=c}else i*=d}const u=Qt(e);if(null!==o){if(0===i||u%i!=0)throw new k(r);a[o]=u/i}else if(u!==i)throw new k(r);return a}computeOutputShape(e){let s=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){s=!0;break}return s?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e),a=r.shape,i=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return(0,l.reshape)(r,i)})}getConfig(){const e={targetShape:this.targetShape},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Reshape",n})();l.serialization.registerClass(vu);let Su=(()=>{class n extends ue{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const s=vt(1,e.dims.length+1);if(!l.util.arraysEqual(e.dims.slice().sort(),s))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ve({ndim:this.dims.length+1})]}computeOutputShape(e){const s=(e=he(e)).slice();return this.dims.forEach((r,a)=>{s[a+1]=e[r]}),s}call(e,s){return(0,l.transpose)(ie(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Permute",n})();l.serialization.registerClass(Su);let Iu=(()=>{class n extends ue{constructor(e){super(e??{}),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={maskValue:this.maskValue};return Object.assign(s,e),s}computeMask(e,s){const r=ie(e);return(0,l.any)((0,l.notEqual)(r,this.maskValue),-1)}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e),o=(0,l.any)((0,l.notEqual)(r,this.maskValue),-1,!0);return(0,l.mul)(r,(0,l.cast)(o,r.dtype))})}}return n.className="Masking",n})();l.serialization.registerClass(Iu);let wu=(()=>{class n extends ue{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let s=null;null!=e.batchSize&&(s=e.batchSize),this.batchInputShape=null==e.inputLength?[s,null]:[s].concat(ve(e.inputLength))}this.inputDim=e.inputDim,Ge(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Ge(this.outputDim,"outputDim"),this.embeddingsInitializer=ke(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Re(e.embeddingsRegularizer),this.activityRegularizer=Re(e.activityRegularizer),this.embeddingsConstraint=Me(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,s){return(0,l.tidy)(()=>this.maskZero?(e=ie(e),(0,l.notEqual)(e,(0,l.zerosLike)(e))):null)}computeOutputShape(e){if(e=he(e),null==this.inputLength)return[...e,this.outputDim];const s=ve(this.inputLength);if(s.length!==e.length-1)throw new k(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let a=0;a<s.length;++a){const i=s[a],o=e[a+1];if(null!=i&&null!=o&&i!==o)throw new k(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==i&&(s[r]=o),r++}}return[e[0],...s,this.outputDim]}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);let r=ie(e);"int32"!==r.dtype&&(r=$t(r,"int32"));const a=rl(this.embeddings.read(),(0,l.reshape)(r,[r.size]));return(0,l.reshape)(a,he(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:De(this.embeddingsInitializer),embeddingsRegularizer:Ce(this.embeddingsRegularizer),activityRegularizer:Ce(this.activityRegularizer),embeddingsConstraint:Be(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Embedding",n})();l.serialization.registerClass(wu);class Nn extends ue{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new oe}computeElementwiseOpOutputShape(t,e){if(null==t||null==e)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(0===e.length)return t;const s=t.slice(0,t.length-e.length);for(let r=0;r<e.length;++r){const a=t[t.length-e.length+r],i=e[r];if(null==a||null==i||a<0||i<0)s.push(null);else if(1===a)s.push(i);else if(1===i)s.push(a);else{if(a!==i)throw new k("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));s.push(a)}}return s}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[he(t)]),t.length<2)throw new k(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const a of t)null!=a&&null!==a[0]&&e.push(a[0]);if(e=Yt(e),e.length>1)throw new k(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let s=null==t[0]?null:t[0].slice(1);for(let a=1;a<t.length;++a){const i=null==t[a]?null:t[a].slice(1);s=this.computeElementwiseOpOutputShape(s,i)}const r=t.map(a=>a.length);this.reshapeRequired=-1!==t.indexOf(null)||1!==Yt(r).length}call(t,e){return(0,l.tidy)(()=>{if(this.reshapeRequired){const s=[],r=t.map(a=>a.rank);if(-1===r.indexOf(null)){const a=Jt(r);for(let i of t){const o=i.rank;for(let u=0;u<a-o;++u)i=us(i,1);s.push(i)}return this.mergeFunction(s)}{let a=!1;for(const u of t){const c=u.rank;if(null==c){const d=u.shape,p=d[0],h=d.slice(1).concat([p]);let f=l.reshape(u,[p].concat(Qt(d.slice(1))));f=l.transpose(f,[1,0]),f=l.reshape(f,h),s.push(f),a=!0}else if(c>1){const d=vt(1,c).concat([0]);s.push(l.transpose(u,d)),a=!0}else s.push(u)}let i=this.mergeFunction(s);const o=i.rank;if(a)if(null==o){const u=i.shape,d=u[u.length-1],p=[d].concat(u.slice(0,u.length-1));i=l.reshape(l.transpose(l.reshape(i,[-1,d]),[1,0]),p)}else if(o>1){const u=[o-1].concat(vt(0,o-1));i=l.transpose(i,u)}return i}}return this.mergeFunction(t)})}computeOutputShape(t){let e;e=null==t[0]?null:t[0].slice(1);for(let r=1;r<t.length;++r){const a=null==t[r]?null:t[r].slice(1);e=this.computeElementwiseOpOutputShape(e,a)}let s=[];for(const r of t)null!=r&&null!==r[0]&&s.push(r[0]);return s=Yt(s),e=1===s.length?s.concat(e):[null].concat(e),e}computeMask(t,e){return l.tidy(()=>{if(null==e)return null;if(!Array.isArray(e))throw new k("`mask` should be an Array");if(!Array.isArray(t))throw new k("`inputs` should be an Array");if(e.length!==t.length)throw new k(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(r=>null==r))return null;let s=(e=e.map(r=>null==r?r:l.expandDims(r,0)))[0];for(let r=1;r<e.length-1;++r)s=l.logicalAnd(s,e[r]);return s})}}let ir=(()=>{class n extends Nn{constructor(e){super(e)}mergeFunction(e){return(0,l.tidy)(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=l.add(s,e[r]);return s})}}return n.className="Add",n})();l.serialization.registerClass(ir);let or=(()=>{class n extends Nn{constructor(e){super(e)}mergeFunction(e){return(0,l.tidy)(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=l.mul(s,e[r]);return s})}}return n.className="Multiply",n})();l.serialization.registerClass(or);let lr=(()=>{class n extends Nn{constructor(e){super(e)}mergeFunction(e){return(0,l.tidy)(()=>{let s=e[0].clone();for(let r=1;r<e.length;++r)s=l.add(s,e[r]);return l.mul(1/e.length,s)})}}return n.className="Average",n})();l.serialization.registerClass(lr);let ur=(()=>{class n extends Nn{constructor(e){super(e)}mergeFunction(e){return(0,l.tidy)(()=>{let s=e[0];for(let r=1;r<e.length;++r)s=l.maximum(s,e[r]);return s})}}return n.className="Maximum",n})();l.serialization.registerClass(ur);let cr=(()=>{class n extends Nn{constructor(e){super(e)}mergeFunction(e){return(0,l.tidy)(()=>{let s=e[0];for(let r=1;r<e.length;++r)s=l.minimum(s,e[r]);return s})}}return n.className="Minimum",n})();l.serialization.registerClass(cr);let dr=(()=>{class n extends Nn{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new k("A `Concatenate` layer should be called on a list of at least 2 inputs");let s=!0;for(const a of e)if(null!=a){s=!1;break}if(s)return;const r=[];for(let a=0;a<e.length;++a){const i=e[a].slice();i.splice(this.axis,1);let o=!1;for(const u of r)if(l.util.arraysEqual(u,i)){o=!0;break}o||r.push(i)}if(r.length>1)throw new k("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return(0,l.tidy)(()=>Na(e,this.axis))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new k("A `Concatenate` layer should be called on a list of inputs.");const s=e,r=s[0].slice(),a=this.axis<0?r.length+this.axis:this.axis;for(const i of s.slice(1)){if(null==r[a]||null==i[a]){r[a]=null;break}r[a]+=i[a]}return r}computeMask(e,s){if(null==s)return null;if(!Array.isArray(s))throw new k("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new k("`inputs` should be an array for Concatenate");if(s.length!==e.length)throw new k(`Mismatch in the length of mask (${s.length}) and the legnth of inputs (${e.length})`);return l.tidy(()=>{let r=!0;if(s.forEach(o=>{null==o||(r=!1)}),r)return null;const a=[];for(let o=0;o<e.length;++o)a.push(null==s[o]?l.cast(l.onesLike(e[o]),"bool"):s[o].rank<e[o].rank?l.expandDims(s[o],-1):s[o]);const i=l.concat(a,this.axis);return l.all(i,-1,!1)})}getConfig(){const e={axis:this.axis},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Concatenate",n})();function xs(n,t){for(;n<0;)n+=t;return n}l.serialization.registerClass(dr);let Nu=(()=>{class n extends Nn{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){l.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const s=e[0],r=e[1];if(s.length>3||r.length>3)throw new oe("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(s,r);if(s[a[0]]!==r[a[1]])throw new k(`Dimension incompatibility: ${s[a[0]]} !== ${r[a[1]]}`)}mergeFunction(e){if(2!==e.length)throw new k(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let a,s=e[0],r=e[1];return a=Array.isArray(this.axes)?this.axes.map((i,o)=>xs(i,e[o].shape.length)):[xs(this.axes,s.shape.length),xs(this.axes,r.shape.length)],this.normalize&&(s=Zs(s,a[0]),r=Zs(r,a[1])),function Qx(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new oe("batchDot is not implemented for tensors of 4D or higher rank yet");if(l.util.assert(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),l.util.assert(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),"number"==typeof e&&(e=[e,e]),"complex64"===n.dtype||"complex64"===t.dtype)throw new oe("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,r=t.shape.length;null==e&&(e=[s-1,r-2]);const a=e;return l.tidy(()=>{let i,o;if(s>r){i=s-r;const u=[];for(let c=0;c<i;++c)u.push(1);t=l.reshape(t,t.shape.concat(u))}else if(r>s){i=r-s;const u=[];for(let c=0;c<i;++c)u.push(1);n=l.reshape(n,n.shape.concat(u))}else i=0;if(o=2===n.shape.length&&2===t.shape.length?a[0]===a[1]?l.sum(l.mul(n,t),a[0]):l.sum(l.mul(l.transpose(n,[1,0]),t),a[1]):l.matMul(n,t,a[0]!==n.shape.length-1,a[1]===t.shape.length-1),i>0){let u;u=s>r?s+r-3:s-1;const c=[];for(let d=u;d<u+i;++d)c.push(d);o=l.squeeze(o,c)}return 1===o.shape.length&&(o=l.expandDims(o,1)),o})}(s,r,a)}interpretAxes(e,s){let r;return r=Array.isArray(this.axes)?this.axes:[xs(this.axes,e.length),xs(this.axes,s.length)],r}computeOutputShape(e){l.util.assert(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const s=e[0].slice(),r=e[1].slice();if(s.length>3||r.length>3)throw new oe("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(s,r);s.splice(a[0],1),r.splice(a[1],1),r.splice(0,1);const i=s.concat(r);return 1===i.length&&i.push(1),i}computeMask(e,s){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},s=super.getConfig();return Object.assign(e,s),e}}return n.className="Dot",n})();l.serialization.registerClass(Nu);let Tu=(()=>{class n extends ue{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={stddev:this.stddev};return Object.assign(s,e),s}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e);return ds(()=>(0,l.add)(Us(r.shape,0,this.stddev),r),()=>r,s.training||!1)})}}return n.className="GaussianNoise",n})();l.serialization.registerClass(Tu);let ku=(()=>{class n extends ue{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={rate:this.rate};return Object.assign(s,e),s}call(e,s){return(0,l.tidy)(()=>{this.invokeCallHook(e,s);const r=ie(e);return this.rate>0&&this.rate<1?ds(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return(0,l.mul)(r,Us(r.shape,1,i))},()=>r,s.training||!1):r})}}return n.className="GaussianDropout",n})();l.serialization.registerClass(ku);let Ru=(()=>{class n extends ue{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ie(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),s={rate:this.rate};return Object.assign(s,e),s}call(e,s){return(0,l.tidy)(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return ds(()=>{const i=ie(e),c=-1.7580993408473766;let d=(0,l.greaterEqual)((0,l.randomUniform)(r),this.rate);d=$t(d,"float32");const p=((1-this.rate)*(1+this.rate*c**2))**-.5,h=-p*c*this.rate,f=(0,l.add)((0,l.mul)(i,d),(0,l.mul)((0,l.add)(d,-1),c));return(0,l.add)((0,l.mul)(f,p),h)},()=>ie(e),s.training||!1)}return e})}}return n.className="AlphaDropout",n})();function bs(n,t,e,s,r,a=.001){let i;if(2===n.rank)i=l.batchNorm2d(n,t,e,s,r,a);else if(3===n.rank)i=l.batchNorm3d(n,t,e,s,r,a);else{if(4!==n.rank)throw new oe(`batchNormalization is not implemented for array of rank ${n.rank} yet`);i=l.batchNorm4d(n,t,e,s,r,a)}return i}l.serialization.registerClass(Ru);let Au=(()=>{class n extends ue{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ke(e.betaInitializer||"zeros"),this.gammaInitializer=ke(e.gammaInitializer||"ones"),this.movingMeanInitializer=ke(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=ke(e.movingVarianceInitializer||"ones"),this.betaConstraint=Me(e.betaConstraint),this.gammaConstraint=Me(e.gammaConstraint),this.betaRegularizer=Re(e.betaRegularizer),this.gammaRegularizer=Re(e.gammaRegularizer)}build(e){e=he(e);const s=this.axis>=0?this.axis:this.axis+e.length,r=e[s];if(null==r)throw new k(`Axis ${s} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ve({ndim:e.length,axes:{[s]:r}})];const a=[r];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,s){return(0,l.tidy)(()=>{const r=null!=s.training&&s.training,a=ie(e),i=a.shape,o=i.length,u=vt(0,o),c=this.axis>=0?this.axis:this.axis+o;u.splice(c,1);const d=bn(1,o);d[c]=i[c];const p=u.slice();p.sort();const h=!l.util.arraysEqual(p,vt(0,o).slice(0,o-1));if(!r)return(()=>{if(h){const S=(0,l.reshape)(this.movingMean.read(),d),v=(0,l.reshape)(this.movingVariance.read(),d),I=this.center?(0,l.reshape)(this.beta.read(),d):null,w=this.scale?(0,l.reshape)(this.gamma.read(),d):null;return bs(a,S,v,I,w,this.epsilon)}return bs(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[m,y,g]=function t0(n,t,e,s,r=.001){return l.util.arraysEqual(s.slice().sort(),vt(0,n.rank-1))?function Jx(n,t,e,s,r=.001){return(0,l.tidy)(()=>{const a=l.moments(n,s),i=a.mean,o=a.variance;return[bs(n,i,o,e,t,r),i,o]})}(n,t,e,s,r):function e0(n,t,e,s,r=.001){return(0,l.tidy)(()=>{const a=l.moments(n,s),i=a.mean,o=a.variance,u=[];for(const m of vt(0,n.rank))-1!==s.indexOf(m)?u.push(1):u.push(n.shape[m]);const c=(0,l.reshape)(i,u),d=(0,l.reshape)(o,u),p=null==t?null:(0,l.reshape)(t,u),h=null==e?null:(0,l.reshape)(e,u);return[bs(n,c,d,h,p,r),i,o]})}(n,t,e,s,r)}(a,this.gamma.read(),this.beta.read(),u,this.epsilon),x=(S,v,I)=>{l.tidy(()=>{const w=1-I,N=S.read(),T=l.mul(l.sub(N,v),w);S.write(l.sub(N,T))})};return(()=>{x(this.movingMean,y,this.momentum),x(this.movingVariance,g,this.momentum)})(),m})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:De(this.betaInitializer),gammaInitializer:De(this.gammaInitializer),movingMeanInitializer:De(this.movingMeanInitializer),movingVarianceInitializer:De(this.movingVarianceInitializer),betaRegularizer:Ce(this.betaRegularizer),gammaRegularizer:Ce(this.gammaRegularizer),betaConstraint:Be(this.betaConstraint),gammaConstraint:Be(this.gammaConstraint)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="BatchNormalization",n})();l.serialization.registerClass(Au);let Du=(()=>{class n extends ue{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"==typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const s of this.axis)if(!Number.isInteger(s))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=ke(e.betaInitializer||"zeros"),this.gammaInitializer=ke(e.gammaInitializer||"ones"),this.betaRegularizer=Re(e.betaRegularizer),this.gammaRegularizer=Re(e.gammaRegularizer),this.supportsMasking=!0}build(e){const s=(e=he(e)).length;"number"==typeof this.axis&&(this.axis=[this.axis]);for(let i=0;i<this.axis.length;++i)this.axis[i]<0&&(this.axis[i]+=s);for(const i of this.axis)if(i<0||i>=s)throw new Error(`Invalid axis: ${i}`);if(this.axis.length!==Yt(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(i=>e[i]);this.gamma=this.scale?this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,!0):null,this.beta=this.center?this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,!0):null,this.built=!0}call(e,s){const r=ie(e),a=r.shape,i=a.length;return(0,l.tidy)(()=>{let{mean:u,variance:c}=(0,l.moments)(r,this.axis,!0);const d=bn(1,i);for(const g of this.axis)d[g]=a[g];const p=g=>null!=g&&g.shape.length!==i?l.reshape(g,d):g;let h=this.scale?p(this.gamma.read()):null,f=this.center?p(this.beta.read()):null;const m=[],y=[];for(let g=0;g<i;++g)-1!==this.axis.indexOf(g)?(m.push(a[g]),y.push(1)):(m.push(1),y.push(a[g]));return u=l.tile(u,m),c=l.tile(c,m),null!=h&&(h=l.tile(h,y)),null!=f&&(f=l.tile(f,y)),bs(r,u,c,f,h,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:De(this.betaInitializer),gammaInitializer:De(this.gammaInitializer),betaRegularizer:Ce(this.betaRegularizer),gammaRegularizer:Ce(this.gammaRegularizer)},s=super.getConfig();return Object.assign(e,s),e}}return n.className="LayerNormalization",n})();l.serialization.registerClass(Du);let $u=(()=>{class n extends ue{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"==typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new k(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let s,r;if("number"==typeof e.padding[0])s=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new k(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(s=e.padding[0],2!==e.padding[1].length)throw new k(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[s,r]}this.inputSpec=[new Ve({ndim:4})]}computeOutputShape(e){let s,r;return e=he(e),"channelsFirst"===this.dataFormat?(s=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],s,r]):(s=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,r=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],s,r,e[3]])}call(e,s){return(0,l.tidy)(()=>function n0(n,t,e){return(0,l.tidy)(()=>{if(4!==n.rank)throw new k(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(null==t&&(t=[[1,1],[1,1]]),2!==t.length||2!==t[0].length||2!==t[1].length)throw new k("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==e&&(e="channelsLast"),"channelsLast"!==e&&"channelsFirst"!==e)throw new k(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return s="channelsFirst"===e?[[0,0],[0,0],t[0],t[1]]:[[0,0],t[0],t[1],[0,0]],l.pad(n,s)})}(ie(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},s=super.getConfig();return Object.assign(e,s),e}}return n.className="ZeroPadding2D",n})();function pr(n,t,e,s,r,a){return(0,l.tidy)(()=>{let i;Fe(r),Yo(a),lt(s),null==e&&(e=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),n=Ja(n,r);const o="same"===s?"same":"valid";return i="max"===a?l.maxPool(n,t,e,o):l.avgPool(n,t,e,o),"channelsFirst"===r&&(i=l.transpose(i,[0,3,1,2])),i})}function Eu(n,t,e,s,r,a){return(0,l.tidy)(()=>{let i;Fe(r),Yo(a),lt(s),null==e&&(e=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==a&&(a="max"),n=eu(n,r);const o="same"===s?"same":"valid";return i="max"===a?l.maxPool3d(n,t,e,o):l.avgPool3d(n,t,e,o),"channelsFirst"===r&&(i=l.transpose(i,[0,4,1,2,3])),i})}l.serialization.registerClass($u);class _u extends ue{constructor(t){if(null==t.poolSize&&(t.poolSize=2),super(t),"number"==typeof t.poolSize)this.poolSize=[t.poolSize];else{if(!Array.isArray(t.poolSize)||1!==t.poolSize.length||"number"!=typeof t.poolSize[0])throw new k(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);this.poolSize=t.poolSize}if(Ge(this.poolSize,"poolSize"),null==t.strides)this.strides=this.poolSize;else if("number"==typeof t.strides)this.strides=[t.strides];else{if(!Array.isArray(t.strides)||1!==t.strides.length||"number"!=typeof t.strides[0])throw new k(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);this.strides=t.strides}Ge(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,lt(this.padding),this.inputSpec=[new Ve({ndim:3})]}computeOutputShape(t){const e=Tt((t=he(t))[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return(0,l.tidy)(()=>{this.invokeCallHook(t,e),t=us(ie(t),2);const s=this.poolingFunction(ie(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return l.squeeze(s,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}let Fu=(()=>{class n extends _u{constructor(e){super(e)}poolingFunction(e,s,r,a,i){return Fe(i),lt(a),pr(e,s,r,a,i,"max")}}return n.className="MaxPooling1D",n})();l.serialization.registerClass(Fu);let Ou=(()=>{class n extends _u{constructor(e){super(e)}poolingFunction(e,s,r,a,i){return Fe(i),lt(a),pr(e,s,r,a,i,"avg")}}return n.className="AveragePooling1D",n})();l.serialization.registerClass(Ou);class zu extends ue{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(2!==t.strides.length)throw new k(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];Ge(this.poolSize,"poolSize"),Ge(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Fe(this.dataFormat),lt(this.padding),this.inputSpec=[new Ve({ndim:4})]}computeOutputShape(t){t=he(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],s="channelsFirst"===this.dataFormat?t[3]:t[2];return e=Tt(e,this.poolSize[0],this.padding,this.strides[0]),s=Tt(s,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,s]:[t[0],e,s,t[3]]}call(t,e){return(0,l.tidy)(()=>(this.invokeCallHook(t,e),this.poolingFunction(ie(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let Lu=(()=>{class n extends zu{constructor(e){super(e)}poolingFunction(e,s,r,a,i){return Fe(i),lt(a),pr(e,s,r,a,i,"max")}}return n.className="MaxPooling2D",n})();l.serialization.registerClass(Lu);let Pu=(()=>{class n extends zu{constructor(e){super(e)}poolingFunction(e,s,r,a,i){return Fe(i),lt(a),pr(e,s,r,a,i,"avg")}}return n.className="AveragePooling2D",n})();l.serialization.registerClass(Pu);class Vu extends ue{constructor(t){if(null==t.poolSize&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],null==t.strides)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(3!==t.strides.length)throw new k(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];Ge(this.poolSize,"poolSize"),Ge(this.strides,"strides"),this.padding=null==t.padding?"valid":t.padding,this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Fe(this.dataFormat),lt(this.padding),this.inputSpec=[new Ve({ndim:5})]}computeOutputShape(t){t=he(t);let e="channelsFirst"===this.dataFormat?t[2]:t[1],s="channelsFirst"===this.dataFormat?t[3]:t[2],r="channelsFirst"===this.dataFormat?t[4]:t[3];return e=Tt(e,this.poolSize[0],this.padding,this.strides[0]),s=Tt(s,this.poolSize[1],this.padding,this.strides[1]),r=Tt(r,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[t[0],t[1],e,s,r]:[t[0],e,s,r,t[4]]}call(t,e){return(0,l.tidy)(()=>(this.invokeCallHook(t,e),this.poolingFunction(ie(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let Bu=(()=>{class n extends Vu{constructor(e){super(e)}poolingFunction(e,s,r,a,i){return Fe(i),lt(a),Eu(e,s,r,a,i,"max")}}return n.className="MaxPooling3D",n})();l.serialization.registerClass(Bu);let Mu=(()=>{class n extends Vu{constructor(e){super(e)}poolingFunction(e,s,r,a,i){return Fe(i),lt(a),Eu(e,s,r,a,i,"avg")}}return n.className="AveragePooling3D",n})();l.serialization.registerClass(Mu);class Wu extends ue{constructor(t){super(t),this.inputSpec=[new Ve({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new oe}}let Gu=(()=>{class n extends Wu{constructor(e){super(e||{})}call(e,s){return(0,l.tidy)(()=>{const r=ie(e);return l.mean(r,1)})}}return n.className="GlobalAveragePooling1D",n})();l.serialization.registerClass(Gu);let Uu=(()=>{class n extends Wu{constructor(e){super(e||{})}call(e,s){return(0,l.tidy)(()=>{const r=ie(e);return l.max(r,1)})}}return n.className="GlobalMaxPooling1D",n})();l.serialization.registerClass(Uu);class Hu extends ue{constructor(t){super(t),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,Fe(this.dataFormat),this.inputSpec=[new Ve({ndim:4})]}computeOutputShape(t){return"channelsLast"===this.dataFormat?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new oe}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}let ju=(()=>{class n extends Hu{call(e,s){return(0,l.tidy)(()=>{const r=ie(e);return l.mean(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalAveragePooling2D",n})();l.serialization.registerClass(ju);let Xu=(()=>{class n extends Hu{call(e,s){return(0,l.tidy)(()=>{const r=ie(e);return l.max(r,"channelsLast"===this.dataFormat?[1,2]:[2,3])})}}return n.className="GlobalMaxPooling2D",n})();l.serialization.registerClass(Xu);class Ku extends ue{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(t){null!=this.layer&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,s={}){const a=Wt(e.layer,s);delete e.layer;const i={layer:a};return Object.assign(i,e),new t(i)}}let qu=(()=>{class n extends Ku{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=he(e)).length<3)throw new k(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const s=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(s),this.layer.built=!0),super.build(e)}computeOutputShape(e){const s=[(e=he(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(s);return[r[0],e[1]].concat(r.slice(1))}call(e,s){return(0,l.tidy)(()=>du((o,u)=>[ie(this.layer.call(o,s)),[]],e=ie(e),[],!1,null,null,!1,!0)[1])}}return n.className="TimeDistributed",n})();l.serialization.registerClass(qu);let Zu=(()=>{class n extends Ku{constructor(e){super(e);const s=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=s,this.forwardLayer=Wt(r),s.goBackwards=!0!==s.goBackwards;const a={};if(a.className=e.layer.getClassName(),a.config=s,this.backwardLayer=Wt(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,function s0(n){vn(ey,"BidirectionalMergeMode",n)}(this.mergeMode),e.weights)throw new oe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const r=Math.floor(e.length/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let r,a,i,s=this.forwardLayer.computeOutputShape(e);return Array.isArray(s)&&Array.isArray(s[0])||(s=[s]),this.returnState&&(i=s.slice(1)),r=s[0],"concat"===this.mergeMode?(r[r.length-1]*=2,a=[r]):a=null==this.mergeMode?[r,r.slice()]:[r],this.returnState?null==this.mergeMode?a.concat(i).concat(i.slice()):[r].concat(i).concat(i.slice()):et(a)}apply(e,s){let r=null==s?null:s.initialState,a=null==s?null:s.constants;null==s&&(s={});const i=cu(e,r,a,this.numConstants);if(e=i.inputs,r=i.initialState,a=i.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==a)return super.apply(e,s);const o=[],u=[];if(null!=r){const d=r.length;if(d%2>0)throw new k("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");s.initialState=r,o.push(...r);const p=r.map(h=>new Ve({shape:h.shape}));this.forwardLayer.stateSpec=p.slice(0,d/2),this.backwardLayer.stateSpec=p.slice(d/2),u.push(...p)}if(null!=a)throw new oe("Support for constants in Bidirectional layers is not implemented yet.");const c=o[0]instanceof Ft;for(const d of o)if(d instanceof Ft!==c)throw new k("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const d=[e].concat(o),p=this.inputSpec.concat(u),h=this.inputSpec;this.inputSpec=p;const f=super.apply(d,s);return this.inputSpec=h,f}return super.apply(e,s)}call(e,s){return(0,l.tidy)(()=>{const r=s.initialState;let a,i,o,u;if(null==r)a=this.forwardLayer.call(e,s),i=this.backwardLayer.call(e,s);else{const c=r.slice(0,r.length/2),d=r.slice(r.length/2);a=this.forwardLayer.call(e,Object.assign(s,{initialState:c})),i=this.backwardLayer.call(e,Object.assign(s,{initialState:d}))}return this.returnState&&(Array.isArray(a)&&(o=a.slice(1).concat(i.slice(1))),a=a[0],i=i[0]),this.returnSequences&&(i=l.reverse(i,1)),"concat"===this.mergeMode?u=Na([a,i]):"sum"===this.mergeMode?u=l.add(a,i):"ave"===this.mergeMode?u=l.mul(.5,l.add(a,i)):"mul"===this.mergeMode?u=l.mul(a,i):null==this.mergeMode&&(u=[a,i]),this.returnState?null==this.mergeMode?u.concat(o):[u].concat(o):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Sn(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Sn(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,s){let r;if(Array.isArray(s)&&(s=s[0]),r=this.returnSequences?null==this.mergeMode?[s,s]:s:null==this.mergeMode?[null,null]:null,this.returnState){const i=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(i).concat(i):[r].concat(i).concat(i)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},s=super.getConfig();return Object.assign(e,s),e}static fromConfig(e,s){const r=Wt(s.layer);if(delete s.layer,null!=s.numConstants)throw new oe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=s;return a.layer=r,new e(a)}}return n.className="Bidirectional",n})();l.serialization.registerClass(Zu);let Yu=(()=>{class n extends ue{constructor(e){super(e),this.scale=e.scale,this.offset=e.offset?e.offset:0}getConfig(){const e={scale:this.scale,offset:this.offset},s=super.getConfig();return Object.assign(e,s),e}call(e,s){return(0,l.tidy)(()=>("float32"!==(e=ie(e)).dtype&&(e=$t(e,"float32")),(0,l.add)((0,l.mul)(e,this.scale),this.offset)))}}return n.className="Rescaling",n})();l.serialization.registerClass(Yu);const{resizeBilinear:a0,cropAndResize:i0}=l.image;let Qu=(()=>{class n extends ue{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,s,r,a,i,o,u,c){return(0,l.tidy)(()=>{let d,p=!1;const g=[s/o,r/u,(a+s)/o,(i+r)/u],x=[];3===e.rank?(p=!0,d=(0,l.stack)([e])):d=e;for(let w=0;w<d.shape[0];w++)x.push(g);const b=(0,l.tensor)(x,[x.length,4]),S=(0,l.range)(0,x.length,1,"int32"),I=i0(d,b,S,[a,i],"nearest");return $t(p?ie((0,l.unstack)(I)):I,c)})}upsize(e,s,r,a){return(0,l.tidy)(()=>$t(a0(e,[s,r]),a))}call(e,s){return(0,l.tidy)(()=>{const r=ie(e),a=r.dtype,i=r.shape,o=i[i.length-3],u=i[i.length-2];let c=0;o!==this.height&&(c=Math.floor((o-this.height)/2));let d=0;return u!==this.width&&(d=Math.floor((u-this.width)/2),0===d&&(d=1)),c>=0&&d>=0?this.centerCrop(r,c,d,this.height,this.width,o,u,a):this.upsize(e,this.height,this.width,a)})}getConfig(){const e={height:this.height,width:this.width},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){const r=(e=he(e)).length-2;return e[e.length-3]=this.height,e[r]=this.width,e}}return n.className="CenterCrop",n})();l.serialization.registerClass(Qu);let Ju=(()=>{class n extends ue{constructor(e){super(e),this.numTokens=e.numTokens,this.outputMode=e.outputMode?e.outputMode:"multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){return null==(e=he(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,s){return(0,l.tidy)(()=>{let r;if("int32"!==(e=ie(e)).dtype&&(e=$t(e,"int32")),typeof s.countWeights<"u"){if("count"!==this.outputMode)throw new k(`countWeights is not used when outputMode !== count.\n              Received countWeights=${s.countWeights}`);r=ie(s.countWeights)}const a=(0,l.max)(e),i=(0,l.min)(e),o=(0,l.greater)(this.numTokens,a).bufferSync().get(0),u=(0,l.greaterEqual)(i,0).bufferSync().get(0);if(!o||!u)throw new k(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function o0(n,t,e,s){let r=ie(n);if("int32"!==r.dtype&&(r=$t(r,"int32")),"int"===t)return r;const a=r.shape;if(0===r.rank&&(r=(0,l.expandDims)(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=(0,l.expandDims)(r,-1)),r.rank>2)throw new k(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${r.rank}.`);const i=["multiHot","oneHot"].includes(t);let u;if(u=(0,l.denseBincount)(r,typeof s<"u"&&"count"===t?s:[],e,i),"tfIdf"!==t)return u;if(s)return(0,l.mul)(u,s);throw new k("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,r)})}}return n.className="CategoryEncoding",n})();l.serialization.registerClass(Ju);const ec=new Set(["bilinear","nearest"]);let tc=(()=>{class n extends ue{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!ec.has(e.interpolation))throw new k(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){return e=he(e),[this.height,this.width,e[2]]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},s=super.getConfig();return Object.assign(e,s),e}call(e,s){return(0,l.tidy)(()=>{const r=[this.height,this.width];if("bilinear"===this.interpolation)return l.image.resizeBilinear(e,r,!this.cropToAspectRatio);if("nearest"===this.interpolation)return l.image.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...ec]} are supported`)})}}return n.className="Resizing",n})();l.serialization.registerClass(tc);let u0=(()=>{class n{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}return n.className="RandomSeed",n})(),c0=(()=>{class n extends ue{constructor(e){super(e),this.randomGenerator=new u0(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},s=super.getConfig();return Object.assign(e,s),e}}return n.className="BaseRandomLayer",n})();const nc=new Set(["bilinear","nearest"]);let sc=(()=>{class n extends c0{constructor(e){super(e);const{factor:s,interpolation:r="bilinear"}=e;if(this.factor=s,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new k(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new k(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new k(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(r){if(!nc.has(r))throw new k(`Invalid interpolation parameter: ${r} is not implemented`);this.interpolation=r}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},s=super.getConfig();return Object.assign(e,s),e}computeOutputShape(e){return e=he(e),[this.imgHeight,-1,e[2]]}call(e,s){return(0,l.tidy)(()=>{const r=ie(e);this.imgHeight=r.shape[r.shape.length-3];const a=r.shape[r.shape.length-2];this.widthFactor=(0,l.randomUniform)([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let i=this.widthFactor.dataSync()[0]*a;i=Math.round(i);const o=[this.imgHeight,i];switch(this.interpolation){case"bilinear":return l.image.resizeBilinear(e,o);case"nearest":return l.image.resizeNearestNeighbor(e,o);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...nc]} are supported`)}})}}return n.className="RandomWidth",n})();function p0(n){return new ps(n)}function h0(n){return new Yl(n)}function f0(n){return new Kl(n)}function m0(n){return new ql(n)}function g0(n){return new Zl(n)}function y0(n){return new Jl(n)}function x0(n){return new Ql(n)}function b0(n){return new iu(n)}function C0(n){return new ti(n)}function v0(n){return new su(n)}function S0(n){return new ni(n)}function I0(n){return new ru(n)}function w0(n){return new au(n)}function N0(n){return new ou(n)}function T0(n){return new lu(n)}function k0(n){return new uu(n)}function R0(n){return new bu(n)}function A0(n){return new yu(n)}function D0(n){return new oi(n)}function $0(n){return new gu(n)}function E0(n){return new xu(n)}function _0(n){return new Cu(n)}function F0(n){return new vu(n)}function O0(n){return new Su(n)}function z0(n){return new wu(n)}function L0(n){return new ir(n)}function P0(n){return new lr(n)}function V0(n){return new dr(n)}function B0(n){return new ur(n)}function M0(n){return new cr(n)}function W0(n){return new or(n)}function G0(n){return new Nu(n)}function U0(n){return new Au(n)}function H0(n){return new Du(n)}function j0(n){return new $u(n)}function li(n){return new Ou(n)}function X0(n){return li(n)}function K0(n){return li(n)}function ui(n){return new Pu(n)}function q0(n){return ui(n)}function Z0(n){return ui(n)}function ci(n){return new Mu(n)}function Y0(n){return ci(n)}function Q0(n){return ci(n)}function J0(n){return new Gu(n)}function eb(n){return new ju(n)}function rc(n){return new Uu(n)}function ac(n){return new Xu(n)}function ic(n){return new Fu(n)}function oc(n){return new Lu(n)}function tb(n){return new Bu(n)}function nb(n){return new hu(n)}function sb(n){return new ri(n)}function rb(n){return new fu(n)}function ab(n){return new ar(n)}function ib(n){return new pu(n)}function ob(n){return new si(n)}function lb(n){return new mu(n)}function ub(n){return new ii(n)}function cb(n){return new wn(n)}function db(n){return new ai(n)}function pb(n){return new Zu(n)}function hb(n){return new qu(n)}l.serialization.registerClass(sc);const fb=rc,mb=ac,gb=ic,yb=oc;function xb(n){return new Tu(n)}function bb(n){return new ku(n)}function Cb(n){return new Ru(n)}function vb(n){return new Iu(n)}function Sb(n){return new Yu(n)}function Ib(n){return new Qu(n)}function wb(n){return new tc(n)}function Nb(n){return new Ju(n)}function Tb(n){return new sc(n)}(0,l.env)().registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var uc,W=(()=>((W=W||{})[W.DT_INVALID=0]="DT_INVALID",W[W.DT_FLOAT=1]="DT_FLOAT",W[W.DT_DOUBLE=2]="DT_DOUBLE",W[W.DT_INT32=3]="DT_INT32",W[W.DT_UINT8=4]="DT_UINT8",W[W.DT_INT16=5]="DT_INT16",W[W.DT_INT8=6]="DT_INT8",W[W.DT_STRING=7]="DT_STRING",W[W.DT_COMPLEX64=8]="DT_COMPLEX64",W[W.DT_INT64=9]="DT_INT64",W[W.DT_BOOL=10]="DT_BOOL",W[W.DT_QINT8=11]="DT_QINT8",W[W.DT_QUINT8=12]="DT_QUINT8",W[W.DT_QINT32=13]="DT_QINT32",W[W.DT_BFLOAT16=14]="DT_BFLOAT16",W[W.DT_QINT16=15]="DT_QINT16",W[W.DT_QUINT16=16]="DT_QUINT16",W[W.DT_UINT16=17]="DT_UINT16",W[W.DT_COMPLEX128=18]="DT_COMPLEX128",W[W.DT_HALF=19]="DT_HALF",W[W.DT_RESOURCE=20]="DT_RESOURCE",W[W.DT_VARIANT=21]="DT_VARIANT",W[W.DT_UINT32=22]="DT_UINT32",W[W.DT_UINT64=23]="DT_UINT64",W[W.DT_FLOAT_REF=101]="DT_FLOAT_REF",W[W.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",W[W.DT_INT32_REF=103]="DT_INT32_REF",W[W.DT_UINT8_REF=104]="DT_UINT8_REF",W[W.DT_INT16_REF=105]="DT_INT16_REF",W[W.DT_INT8_REF=106]="DT_INT8_REF",W[W.DT_STRING_REF=107]="DT_STRING_REF",W[W.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",W[W.DT_INT64_REF=109]="DT_INT64_REF",W[W.DT_BOOL_REF=110]="DT_BOOL_REF",W[W.DT_QINT8_REF=111]="DT_QINT8_REF",W[W.DT_QUINT8_REF=112]="DT_QUINT8_REF",W[W.DT_QINT32_REF=113]="DT_QINT32_REF",W[W.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",W[W.DT_QINT16_REF=115]="DT_QINT16_REF",W[W.DT_QUINT16_REF=116]="DT_QUINT16_REF",W[W.DT_UINT16_REF=117]="DT_UINT16_REF",W[W.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",W[W.DT_HALF_REF=119]="DT_HALF_REF",W[W.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",W[W.DT_VARIANT_REF=121]="DT_VARIANT_REF",W[W.DT_UINT32_REF=122]="DT_UINT32_REF",W[W.DT_UINT64_REF=123]="DT_UINT64_REF",W))();!function(n){let t;var e;(e=t=n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(uc||(uc={}));const di={};function cc(n){return di[n]}function C(n,t,e,s,r){const a=t.inputParams[n];if(a&&void 0!==a.inputIndexStart){const o=a.inputIndexStart,u=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?o+1:a.inputIndexEnd,c=o<0?t.inputNames.length+o:o;if("tensor"===a.type)return Ue(t.inputNames[c],e,s,r);if("tensors"===a.type){const h=t.inputs.slice(o,u);return t.inputNames.slice(o,u).filter((m,y)=>{var g;return"NoOp"!==(null===(g=h[y])||void 0===g?void 0:g.op)}).map(m=>Ue(m,e,s,r))}const d=Ue(t.inputNames[c],e,s,r),p=d.dataSync();return"number"===a.type?p[0]:l.util.toNestedArray(d.shape,p)}const i=t.attrParams[n];return i&&i.value}function Ue(n,t,e,s){const[r,a]=st(n,e);if(null!=s){const o=s.getHashTableHandleByName(r);if(null!=o)return o}const i=e.currentContextIds.find(o=>!!t[fr(r,o)]);return void 0!==i?t[fr(r,i)][a]:void 0}function dc(n,t,e){return t[fr(n,e.currentContextId)]}function Gt(n,t){const[e,s,r]=st(n,t);return[fr(e,t&&t.currentContextId),s,r]}function fr(n,t){return t?`${n}-${t}`:n}function st(n,t){if(""===n)return["",0,void 0];const e=null!=t&&null!=t.parseNodeNameCache;if(e){const a=t.parseNodeNameCache.get(n);if(null!=a)return a}const s=n.split(":");let r;if(1===s.length)r=[n,0,void 0];else{const i=3===s.length?s[1]:void 0;r=[s[0],Number(s[s.length-1]),i]}return e&&t.parseNodeNameCache.set(n,r),r}function mr(n,t,e){let s=C("pad",n,t,e);if("explicit"===s){s=C("explicitPaddings",n,t,e);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[2*a],r[a][1]=s[2*a+1];return r}return s}function Ut(n){return n.kept?n:(0,l.clone)(n)}const Db=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],$b=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Eb=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],_b=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Fb=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],Ob=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zb=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Lb=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Pb=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Vb=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Bb=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Mb=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Wb=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Gb=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ub=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Hb=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],jb=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Xb=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Kb=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class pc{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[qr,Zr,Yr,Qr,Jr,ea,ta,na,sa,ra,aa,ia,oa,la,ua,ca,da,pa,ha].map(s=>s.json));this.opMappers=e.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(t,e={}){const r=[],a=[],i=[],o=t.node.reduce((y,g)=>(y[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(y[g.name]):"Const"===g.op?a.push(y[g.name]):(null==g.input||0===g.input.length)&&i.push(y[g.name]),y),{});let u=[];const c=[];let d={},p={};null!=e&&(d=this.mapSignatureEntries(e.inputs),p=this.mapSignatureEntries(e.outputs));const h=Object.keys(o);h.forEach(y=>{const g=o[y];g.inputNames.forEach((x,b)=>{const[S,,v]=Gt(x),I=o[S];if(null!=I.outputs){const w=I.outputs.indexOf(v);-1!==w&&(g.inputNames[b]=`${S}:${w}`)}g.inputs.push(I),I.children.push(g)})}),0===Object.keys(p).length?h.forEach(y=>{const g=o[y];0===g.children.length&&c.push(g)}):Object.keys(p).forEach(y=>{const[g]=Gt(y),x=o[g];null!=x&&(x.signatureKey=p[y],c.push(x))}),Object.keys(d).length>0?Object.keys(d).forEach(y=>{const[g]=Gt(y),x=o[g];x&&(x.signatureKey=d[y],u.push(x))}):u=r;let f={};null!=t.library&&null!=t.library.function&&(f=t.library.function.reduce((y,g)=>(y[g.signature.name]=this.mapFunction(g),y),{}));const m={nodes:o,inputs:u,outputs:c,weights:a,placeholders:r,signature:e,functions:f};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,s)=>(e[t[s].name]=s,e),{})}mapNode(t){const e=cc(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const s={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return null!=e.inputs&&(s.inputParams=e.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),null!=e.attrs&&(s.attrParams=e.attrs.reduce((r,a)=>{const i=a.type;let o;switch(a.type){case"string":o=pi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=pi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":o=Ci(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=Ci(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":o=fi(t.attr,a.tfName,a.defaultValue||0),void 0===o&&a.tfDeprecatedName&&(o=fi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":o=bi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=bi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":o=hi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=hi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":o=Si(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=Si(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":o=xi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=xi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":o=vi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=vi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":o=gi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=gi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":o=yi(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=yi(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":o=fc(t.attr,a.tfName,a.defaultValue),void 0===o&&a.tfDeprecatedName&&(o=fc(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return r[a.name]={value:o,type:i},r},{})),s}mapFunction(t){const e=t.nodeDef,r=[];let a={};null!=e&&(a=e.reduce((p,h)=>(p[h.name]=this.mapNode(h),"Const"===h.op&&r.push(p[h.name]),p),{}));const i=[],o=[];t.signature.inputArg.forEach(p=>{const[h]=Gt(p.name),f={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:mi(p.type),type:"dtype"}},children:[]};f.signatureKey=p.name,i.push(f),a[h]=f}),Object.keys(a).forEach(p=>{const h=a[p];h.inputNames.forEach((f,m)=>{const[y,,g]=Gt(f),x=a[y];if(null!=x.outputs){const b=x.outputs.indexOf(g);-1!==b&&(h.inputNames[m]=`${y}:${b}`)}h.inputs.push(x),x.children.push(h)})});const c=t.ret;t.signature.outputArg.forEach(p=>{const[h,f]=Gt(c[p.name]),m=a[h];null!=m&&(m.defaultOutput=f,o.push(m))});const d=this.mapArgsToSignature(t);return{nodes:a,inputs:i,outputs:o,weights:r,placeholders:[],signature:d}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s),e),{}),outputs:t.signature.outputArg.reduce((e,s)=>(e[s.name]=this.mapArgToTensorInfo(s,t.ret),e),{})}}mapArgToTensorInfo(t,e){let s=t.name;return null!=e&&(s=e[s]),{name:s,dtype:t.type}}}function hc(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):function qb(n){const t=(0,l.env)().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(n);return t?e:e.toLowerCase()}function pi(n,t,e,s=!1){const r=n[t];return null!=r?hc(r.s,s):e}function hi(n,t,e){const s=n[t];return s?s.b:e}function fi(n,t,e){const s=n[t]||{},r=null!=s.i?s.i:null!=s.f?s.f:e;return"number"==typeof r?r:parseInt(r,10)}function mi(n){switch("string"==typeof n&&(n=W[n]),n){case W.DT_FLOAT:case W.DT_HALF:return"float32";case W.DT_INT32:case W.DT_INT64:case W.DT_INT8:case W.DT_UINT8:return"int32";case W.DT_BOOL:return"bool";case W.DT_DOUBLE:return"float32";case W.DT_STRING:return"string";default:return null}}function fc(n,t,e){const s=n[t];return s&&s.func?s.func.name:e}function gi(n,t,e){const s=n[t];return s&&s.type?mi(s.type):e}function yi(n,t,e){const s=n[t];return s&&s.list&&s.list.type?s.list.type.map(r=>mi(r)):e}function mc(n){if(!n.unknownRank)return null!=n.dim?n.dim.map(t=>"number"==typeof t.size?t.size:parseInt(t.size,10)):[]}function xi(n,t,e){const s=n[t];return s&&s.shape?mc(s.shape):e}function bi(n,t,e){const s=n[t];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>"number"==typeof r?r:parseInt(r,10)):e}function Ci(n,t,e,s=!1){const r=n[t];return r&&r.list&&r.list.s?r.list.s.map(a=>hc(a,s)):e}function vi(n,t,e){const s=n[t];return s&&s.list&&s.list.shape?s.list.shape.map(r=>mc(r)):e}function Si(n,t,e){const s=n[t];return s&&s.list&&s.list.b?s.list.b:e}class Zb{constructor(t,e,s){this.node=t,this.tensorMap=e,this.context=s,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(r=>this.getInput(r)),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(t){return Ue(t,this.tensorMap,this.context)}getAttr(t,e){const s=this.node.rawAttrs[t];if(null!=s.tensor)return Ue(t,this.tensorMap,this.context);if(null!=s.i||null!=s.f)return fi(this.node.rawAttrs,t,e);if(null!=s.s)return pi(this.node.rawAttrs,t,e);if(null!=s.b)return hi(this.node.rawAttrs,t,e);if(null!=s.shape)return xi(this.node.rawAttrs,t,e);if(null!=s.type)return gi(this.node.rawAttrs,t,e);if(null!=s.list){if(null!=s.list.i||null!=s.list.f)return bi(this.node.rawAttrs,t,e);if(null!=s.list.s)return Ci(this.node.rawAttrs,t,e);if(null!=s.list.shape)return vi(this.node.rawAttrs,t,e);if(null!=s.list.b)return Si(this.node.rawAttrs,t,e);if(null!=s.list.type)return yi(this.node.rawAttrs,t,e)}return e}}var He=R(1357);function gt(n,t,e=""){if("number"!=typeof n&&"number"!=typeof t){l.util.assert(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let s=0;s<n.length;s++){const r=n[s],a=t[s];l.util.assert(r<0||a<0||r===a,()=>e+` Shapes ${n} and ${t} must match`)}}}function gc(n){return!("number"==typeof n||n.some(t=>t<0))}function Cs(n,t,e){let s=Ii(n,e);const r=!gc(s);if(r&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&t.forEach(a=>{s=Ii(a.shape,s)}),!gc(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Ii(n,t){if("number"==typeof n)return t;if("number"==typeof t)return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let s=0;s<n.length;++s){const r=n[s],a=t[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[s]=r>=0?r:a}return e}class Jb{constructor(t,e,s,r,a,i,o){this.name=t,this.dtype=e,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=i,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=(0,l.scalar)(0),(0,l.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0===this.size()&&(null==this.elementShape||0===this.elementShape.length)&&(this.elementShape=e.shape),gt(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);s.tensor=e,(0,l.keep)(e),s.written=!0,this.tensors[t]=s}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((s,r)=>this.write(s,e[r]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let r=0;r<this.size();r++)t.push(r)}if(0===t.length)return(0,l.tensor)([],[0].concat(this.elementShape));const s=this.readMany(t);return gt(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),(0,l.stack)(s,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return(0,l.tensor)([],[0].concat(this.elementShape));const e=[];for(let r=0;r<this.size();r++)e.push(r);const s=this.readMany(e);return gt(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),(0,l.concat)(s,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(t,(0,l.unstack)(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let s=0;const r=t.map(u=>(s+=u,s));if(s!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const a=0===s?0:e.size/s,i=[];(0,l.tidy)(()=>{e=(0,l.reshape)(e,[1,s,a]);for(let u=0;u<t.length;++u)i[u]=(0,l.reshape)((0,l.slice)(e,[0,0===u?0:r[u-1],0],[1,t[u],a]),this.elementShape);return i});const o=[];for(let u=0;u<t.length;u++)o[u]=u;this.writeMany(o,i)}}class Tn{get id(){return this.idTensor.id}constructor(t,e,s,r=-1){this.tensors=t,this.elementShape=e,this.elementDtype=s,t?.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);gt(e,a.shape,"TensorList shape mismatch: "),(0,l.keep)(a)}),this.idTensor=(0,l.scalar)(0),this.maxNumElements=r,(0,l.keep)(this.idTensor)}copy(){return new Tn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(null==t||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,s=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==s&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);gt(t,this.elementShape,"TensorList shape mismatch: ");const r=Cs(this.elementShape,this.tensors,t);return(0,l.tidy)(()=>{const a=this.tensors.map(i=>(0,l.reshape)(i,r));return(0,l.stack)(a,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const s=Cs(this.elementShape,this.tensors,t),r=this.tensors.pop();return r.kept=!1,gt(r.shape,t,"TensorList shape mismatch: "),(0,l.reshape)(r,s)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(gt(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,l.keep)(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new Tn([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s)e.tensors[s]=this.tensors[s];return e}getItem(t,e,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);gt(this.tensors[t].shape,e,"TensorList shape mismatch: ");const r=Cs(this.elementShape,this.tensors,e);return(0,l.reshape)(this.tensors[t],r)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);gt(this.elementShape,e.shape,"TensorList shape mismatch: "),(0,l.keep)(e),null!=this.tensors[t]&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,s){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);gt(this.elementShape,s,"TensorList shape mismatch: "),t=t.slice(0,this.size());const r=Cs(this.elementShape,this.tensors,s);return 0===t.length?(0,l.tensor)([],[0].concat(r)):(0,l.tidy)(()=>{const a=t.map(i=>(0,l.reshape)(this.tensors[i],r));return(0,l.stack)(a,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);gt(this.elementShape,e,"TensorList shape mismatch: ");const s=Cs(this.elementShape,this.tensors,e);return 0===this.size()?(0,l.tensor)([],[0].concat(s)):(0,l.tidy)(()=>{const r=this.tensors.map(a=>(0,l.reshape)(a,s));return(0,l.concat)(r,0)})}}const rC=function(){var n=(0,J.Z)(function*(t,e,s){switch(t.op){case"If":case"StatelessIf":{const r=C("thenBranch",t,e,s),a=C("elseBranch",t,e,s),i=C("cond",t,e,s),o=C("args",t,e,s);return(yield i.data())[0]?s.functionMap[r].executeFunctionAsync(o,s.tensorArrayMap,s.tensorListMap):s.functionMap[a].executeFunctionAsync(o,s.tensorArrayMap,s.tensorListMap)}case"While":case"StatelessWhile":{const r=C("body",t,e,s),a=C("cond",t,e,s),i=C("args",t,e,s),o=yield s.functionMap[a].executeFunctionAsync(i,s.tensorArrayMap,s.tensorListMap),u=i.map(p=>p.id);let c=yield o[0].data();o.forEach(p=>{!p.kept&&-1===u.indexOf(p.id)&&p.dispose()});let d=i;for(;c[0];){const p=d;d=yield s.functionMap[r].executeFunctionAsync(d,s.tensorArrayMap,s.tensorListMap);const h=d.map(m=>m.id);p.forEach(m=>{!m.kept&&-1===u.indexOf(m.id)&&-1===h.indexOf(m.id)&&m.dispose()});const f=yield s.functionMap[a].executeFunctionAsync(d,s.tensorArrayMap,s.tensorListMap);c=yield f[0].data(),f.forEach(m=>{!m.kept&&-1===u.indexOf(m.id)&&-1===h.indexOf(m.id)&&m.dispose()})}return d}case"LoopCond":return[Ut(C("pred",t,e,s))];case"Switch":{const r=C("pred",t,e,s);let a=C("data",t,e,s);return a.kept||(a=Ut(a)),(yield r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=t.inputNames.find(a=>void 0!==Ue(a,e,s));return r?[Ut(Ue(r,e,s))]:void 0}case"Enter":{const r=C("frameName",t,e,s),a=C("tensor",t,e,s);return s.enterFrame(r),[Ut(a)]}case"Exit":{const r=C("tensor",t,e,s);return s.exitFrame(),[Ut(r)]}case"NextIteration":{const r=C("tensor",t,e,s);return s.nextIteration(),[Ut(r)]}case"TensorArrayV3":{const r=C("size",t,e,s),a=C("dtype",t,e,s),i=C("elementShape",t,e,s),o=C("dynamicSize",t,e,s),u=C("clearAfterRead",t,e,s),c=C("identicalElementShapes",t,e,s),d=C("name",t,e,s),p=new Jb(d,a,r,i,c,o,u);return s.addTensorArray(p),[p.idTensor,(0,l.scalar)(1)]}case"TensorArrayWriteV3":{const r=C("tensorArrayId",t,e,s),a=C("index",t,e,s),i=C("tensor",t,e,s),o=s.getTensorArray(r.id);return o.write(a,i),[o.idTensor]}case"TensorArrayReadV3":{const r=C("tensorArrayId",t,e,s),a=C("index",t,e,s);return[s.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=C("tensorArrayId",t,e,s),a=C("indices",t,e,s),i=C("dtype",t,e,s);return[s.getTensorArray(r.id).gather(a,i)]}case"TensorArrayScatterV3":{const r=C("tensorArrayId",t,e,s),a=C("indices",t,e,s),i=C("tensor",t,e,s),o=s.getTensorArray(r.id);return o.scatter(a,i),[o.idTensor]}case"TensorArrayConcatV3":{const r=C("tensorArrayId",t,e,s),a=s.getTensorArray(r.id),i=C("dtype",t,e,s);return[a.concat(i)]}case"TensorArraySplitV3":{const r=C("tensorArrayId",t,e,s),a=C("tensor",t,e,s),i=C("lengths",t,e,s),o=s.getTensorArray(r.id);return o.split(i,a),[o.idTensor]}case"TensorArraySizeV3":{const r=C("tensorArrayId",t,e,s),a=s.getTensorArray(r.id);return[(0,l.scalar)(a.size(),"int32")]}case"TensorArrayCloseV3":{const r=C("tensorArrayId",t,e,s),a=s.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=C("tensorListId",t,e,s),a=C("index",t,e,s),i=C("tensor",t,e,s),o=s.getTensorList(r.id);return o.setItem(a,i),[o.idTensor]}case"TensorListGetItem":{const r=C("tensorListId",t,e,s),a=C("index",t,e,s),i=C("elementShape",t,e,s),o=C("elementDType",t,e,s);return[s.getTensorList(r.id).getItem(a,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=C("indices",t,e,s),u=function nC(n,t,e,s){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const r=Math.max(...t);if(null!=s&&-1!==s&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new Tn([],e,n.dtype,s),i=(0,l.unstack)(n,0);return t.forEach((o,u)=>{a.setItem(o,i[u])}),a}(C("tensor",t,e,s),r,C("elementShape",t,e,s),C("numElements",t,e,s));return s.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=C("elementShape",t,e,s),a=C("elementDType",t,e,s);let i;i="TensorListReserve"===t.op?"numElements":"maxNumElements";const o=C(i,t,e,s),c=function tC(n,t,e,s){return new Tn([],n,t,s)}(r,a,0,"TensorListReserve"===t.op?-1:o);return s.addTensorList(c),[c.idTensor]}case"TensorListGather":{const r=C("tensorListId",t,e,s),a=C("indices",t,e,s),i=C("elementShape",t,e,s),o=C("elementDType",t,e,s);return[s.getTensorList(r.id).gather(a,o,i)]}case"TensorListStack":{const r=C("tensorListId",t,e,s),a=C("elementShape",t,e,s),i=C("elementDType",t,e,s),o=C("numElements",t,e,s);return[s.getTensorList(r.id).stack(a,i,o)]}case"TensorListFromTensor":{const o=function eC(n,t,e){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);gt(n.shape.slice(1),t,"TensorList shape mismatch: ");const a=(0,l.unstack)(n);return new Tn(a,t,s)}(C("tensor",t,e,s),C("elementShape",t,e,s),C("elementDType",t,e,s));return s.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=C("tensorListId",t,e,s),a=s.getTensorList(r.id),i=C("dtype",t,e,s),o=C("elementShape",t,e,s);return[a.concat(i,o)]}case"TensorListPushBack":{const r=C("tensorListId",t,e,s),a=C("tensor",t,e,s),i=s.getTensorList(r.id);return i.pushBack(a),[i.idTensor]}case"TensorListPopBack":{const r=C("tensorListId",t,e,s),a=C("elementShape",t,e,s),i=C("elementDType",t,e,s);return[s.getTensorList(r.id).popBack(a,i)]}case"TensorListSplit":{const r=C("tensor",t,e,s),a=C("elementShape",t,e,s),o=function sC(n,t,e){let s=0;const r=t.map(d=>(s+=d,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${s}, and tensor's shape is: ${n.shape}`);const i=Ii(n.shape.slice(1),e),o=0===s?0:n.size/s,u=(0,l.tidy)(()=>{const d=[];n=(0,l.reshape)(n,[1,s,o]);for(let p=0;p<t.length;++p)d[p]=(0,l.reshape)((0,l.slice)(n,[0,0===p?0:r[p-1],0],[1,t[p],o]),i);return n.dispose(),d}),c=new Tn([],e,n.dtype,t.length);for(let d=0;d<u.length;d++)c.setItem(d,u[d]);return c}(r,C("lengths",t,e,s),a);return s.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=C("tensorListId",t,e,s),a=s.getTensorList(r.id);return[(0,l.scalar)(a.size(),"int32")]}case"TensorListResize":{const r=C("tensorListId",t,e,s),a=C("size",t,e,s),o=s.getTensorList(r.id).resize(a);return s.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,s,r){return n.apply(this,arguments)}}();function yc(n,t,e){const[s,r]=C("fusedOps",n,t,e),a="biasadd"===s,i=!a,o="prelu"===r,u="fusedbatchnorm"===s,c=C("numArgs",n,t,e);if(a){if(o&&2!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==c)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const d=C("strides",n,t,e),p=mr(n,t,e),h=C("dataFormat",n,t,e).toUpperCase(),f=C("dilations",n,t,e);let[m,y]=C("args",n,t,e);return i&&(y=m,m=void 0),{stride:d,pad:p,dataFormat:h,dilations:f,biasArg:m,preluArg:y,activationFunc:r,leakyreluAlpha:C("leakyreluAlpha",n,t,e)}}function wi(n,t,e){return{boxes:C("boxes",n,t,e),scores:C("scores",n,t,e),maxOutputSize:C("maxOutputSize",n,t,e),iouThreshold:C("iouThreshold",n,t,e),scoreThreshold:C("scoreThreshold",n,t,e),softNmsSigma:C("softNmsSigma",n,t,e)}}const oC=function(){var n=(0,J.Z)(function*(t,e,s,r,a=He){switch(t.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:u,iouThreshold:c,scoreThreshold:d,softNmsSigma:p}=wi(t,e,s),h=yield a.image.nonMaxSuppressionWithScoreAsync(i,o,u,c,d,p);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:u,iouThreshold:c,scoreThreshold:d}=wi(t,e,s),p=C("padToMaxOutputSize",t,e,s),h=yield a.image.nonMaxSuppressionPaddedAsync(i,o,u,c,d,p);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:u,iouThreshold:c,scoreThreshold:d}=wi(t,e,s);return[yield a.image.nonMaxSuppressionAsync(i,o,u,c,d)]}case"Where":{const i=a.cast(C("condition",t,e,s),"bool"),o=[yield a.whereAsync(i)];return i.dispose(),o}case"ListDiff":return a.setdiff1dAsync(C("x",t,e,s),C("y",t,e,s));default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,s,r,a){return n.apply(this,arguments)}}();class cC{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=(0,l.scalar)(0),this.tensorMap=new Map,(0,l.keep)(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ke.i(this.size(),"int32")}import(t,e){var s=this;return(0,J.Z)(function*(){s.checkKeyAndValueTensor(t,e);const r=yield t.data();return s.tensorMap.forEach(a=>a.dispose()),s.tensorMap.clear(),(0,l.tidy)(()=>{const a=(0,l.unstack)(e),i=r.length,o=a.length;l.util.assert(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let u=0;u<i;u++){const c=r[u],d=a[u];(0,l.keep)(d),s.tensorMap.set(c,d)}return s.handle})})()}find(t,e){var s=this;return(0,J.Z)(function*(){s.checkKeyAndValueTensor(t,e);const r=yield t.data();return(0,l.tidy)(()=>{const a=[];for(let i=0;i<r.length;i++){const u=s.findWithDefault(r[i],e);a.push(u)}return(0,l.stack)(a)})})()}findWithDefault(t,e){return this.tensorMap.get(t)??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const dC=function(){var n=(0,J.Z)(function*(t,e,s,r){switch(t.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(t.name);if(null!=a)return[a];{const i=C("keyDType",t,e,s),o=C("valueDType",t,e,s),u=new cC(i,o);return r.addHashTable(t.name,u),[u.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=C("tableHandle",t,e,s,r),i=C("keys",t,e,s),o=C("values",t,e,s);return[yield r.getHashTableById(a.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=C("tableHandle",t,e,s,r),i=C("keys",t,e,s),o=C("defaultValue",t,e,s);return[yield r.getHashTableById(a.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=C("tableHandle",t,e,s,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}});return function(e,s,r,a){return n.apply(this,arguments)}}();function xc(n,t,e,s,r=l.tidy){const a=((i,o,u)=>{switch(i.category){case"arithmetic":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(C("a",n,t,e),C("b",n,t,e))];case"AddN":return[s.addN(C("tensors",n,t,e))];case"FloorMod":case"Mod":return[s.mod(C("a",n,t,e),C("b",n,t,e))];case"Mul":return[s.mul(C("a",n,t,e),C("b",n,t,e))];case"RealDiv":case"Div":return[s.div(C("a",n,t,e),C("b",n,t,e))];case"DivNoNan":return[s.divNoNan(C("a",n,t,e),C("b",n,t,e))];case"FloorDiv":return[s.floorDiv(C("a",n,t,e),C("b",n,t,e))];case"Sub":return[s.sub(C("a",n,t,e),C("b",n,t,e))];case"Minimum":return[s.minimum(C("a",n,t,e),C("b",n,t,e))];case"Maximum":return[s.maximum(C("a",n,t,e),C("b",n,t,e))];case"Pow":return[s.pow(C("a",n,t,e),C("b",n,t,e))];case"SquaredDifference":return[s.squaredDifference(C("a",n,t,e),C("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"basic_math":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(C("x",n,t,e))];case"Acos":return[s.acos(C("x",n,t,e))];case"Acosh":return[s.acosh(C("x",n,t,e))];case"Asin":return[s.asin(C("x",n,t,e))];case"Asinh":return[s.asinh(C("x",n,t,e))];case"Atan":return[s.atan(C("x",n,t,e))];case"Atan2":return[s.atan2(C("x",n,t,e),C("y",n,t,e))];case"Atanh":return[s.atanh(C("x",n,t,e))];case"Ceil":return[s.ceil(C("x",n,t,e))];case"Complex":return[s.complex(C("real",n,t,e),C("imag",n,t,e))];case"Cos":return[s.cos(C("x",n,t,e))];case"Cosh":return[s.cosh(C("x",n,t,e))];case"Elu":return[s.elu(C("x",n,t,e))];case"Erf":return[s.erf(C("x",n,t,e))];case"Exp":return[s.exp(C("x",n,t,e))];case"Expm1":return[s.expm1(C("x",n,t,e))];case"Floor":return[s.floor(C("x",n,t,e))];case"Log":return[s.log(C("x",n,t,e))];case"Log1p":return[s.log1p(C("x",n,t,e))];case"Imag":return[s.imag(C("x",n,t,e))];case"Neg":return[s.neg(C("x",n,t,e))];case"Reciprocal":return[s.reciprocal(C("x",n,t,e))];case"Real":return[s.real(C("x",n,t,e))];case"Relu":return[s.relu(C("x",n,t,e))];case"Round":return[s.round(C("x",n,t,e))];case"Selu":return[s.selu(C("x",n,t,e))];case"Sigmoid":return[s.sigmoid(C("x",n,t,e))];case"Sin":return[s.sin(C("x",n,t,e))];case"Sign":return[s.sign(C("x",n,t,e))];case"Sinh":return[s.sinh(C("x",n,t,e))];case"Softplus":return[s.softplus(C("x",n,t,e))];case"Sqrt":return[s.sqrt(C("x",n,t,e))];case"Square":return[s.square(C("x",n,t,e))];case"Tanh":return[s.tanh(C("x",n,t,e))];case"Tan":return[s.tan(C("x",n,t,e))];case"ClipByValue":return[s.clipByValue(C("x",n,t,e),C("clipValueMin",n,t,e),C("clipValueMax",n,t,e))];case"Relu6":return[s.relu6(C("x",n,t,e))];case"Rsqrt":return[s.rsqrt(Ue(n.inputNames[0],t,e))];case"LeakyRelu":return[s.leakyRelu(C("x",n,t,e),C("alpha",n,t,e))];case"Prelu":return[s.prelu(C("x",n,t,e),C("alpha",n,t,e))];case"IsNan":return[s.isNaN(Ue(n.inputNames[0],t,e))];case"IsInf":return[s.isInf(Ue(n.inputNames[0],t,e))];case"IsFinite":return[s.isFinite(Ue(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"control":return rC(i,o,u);case"convolution":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Conv1D":{const r=C("stride",n,t,e),a=C("pad",n,t,e),i=C("dataFormat",n,t,e).toUpperCase(),o=C("dilation",n,t,e);return[s.conv1d(C("x",n,t,e),C("filter",n,t,e),r,a,i,o)]}case"Conv2D":{const r=C("strides",n,t,e),a=mr(n,t,e),i=C("dataFormat",n,t,e).toUpperCase(),o=C("dilations",n,t,e);return[s.conv2d(C("x",n,t,e),C("filter",n,t,e),[r[1],r[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:c,activationFunc:d,leakyreluAlpha:p}=yc(n,t,e);return[s.fused.conv2d({x:C("x",n,t,e),filter:C("filter",n,t,e),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:c,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:c,activationFunc:d,leakyreluAlpha:p}=yc(n,t,e);return[s.fused.depthwiseConv2d({x:C("x",n,t,e),filter:C("filter",n,t,e),strides:[r[1],r[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:d,preluActivationWeights:c,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=C("outputShape",n,t,e),a=C("strides",n,t,e),i=mr(n,t,e);return[s.conv2dTranspose(C("x",n,t,e),C("filter",n,t,e),r,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=C("strides",n,t,e),a=mr(n,t,e),i=C("dilations",n,t,e),o=C("dataFormat",n,t,e).toUpperCase();return[s.depthwiseConv2d(C("input",n,t,e),C("filter",n,t,e),[r[1],r[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("dataFormat",n,t,e).toUpperCase(),o=C("dilations",n,t,e);return[s.conv3d(C("x",n,t,e),C("filter",n,t,e),[r[1],r[2],r[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[s.avgPool(C("x",n,t,e),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[s.maxPool(C("x",n,t,e),[i[1],i[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("kernelSize",n,t,e),o=C("includeBatchInIndex",n,t,e),{result:u,indexes:c}=s.maxPoolWithArgmax(C("x",n,t,e),[i[1],i[2]],[r[1],r[2]],a,o);return[u,c]}case"AvgPool3D":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[s.avgPool3d(C("x",n,t,e),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("kernelSize",n,t,e);return[s.maxPool3d(C("x",n,t,e),[i[1],i[2],i[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=C("strides",n,t,e),a=C("pad",n,t,e),i=C("dilations",n,t,e),o=r[1],u=r[2],c=i[1],d=i[2];return[s.dilation2d(C("x",n,t,e),C("filter",n,t,e),[o,u],a,[c,d],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"creation":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Fill":{const r=C("shape",n,t,e),a=C("dtype",n,t,e),i=C("value",n,t,e);return[s.fill(r,i,a)]}case"LinSpace":{const r=C("start",n,t,e),a=C("stop",n,t,e),i=C("num",n,t,e);return[s.linspace(r,a,i)]}case"Multinomial":{const r=C("logits",n,t,e),a=C("numSamples",n,t,e),i=C("seed",n,t,e);return[s.multinomial(r,a,i)]}case"OneHot":{const r=C("indices",n,t,e),a=C("depth",n,t,e),i=C("onValue",n,t,e),o=C("offValue",n,t,e),u=C("dtype",n,t,e);return[s.oneHot(r,a,i,o,u)]}case"Ones":return[s.ones(C("shape",n,t,e),C("dtype",n,t,e))];case"OnesLike":return[s.onesLike(C("x",n,t,e))];case"RandomStandardNormal":return[s.randomStandardNormal(C("shape",n,t,e),C("dtype",n,t,e),C("seed",n,t,e))];case"RandomUniform":return[s.randomUniform(C("shape",n,t,e),C("minval",n,t,e),C("maxval",n,t,e),C("dtype",n,t,e))];case"RandomUniformInt":return[s.randomUniformInt(C("shape",n,t,e),C("minval",n,t,e),C("maxval",n,t,e),C("seed",n,t,e))];case"Range":{const r=C("start",n,t,e),a=C("stop",n,t,e),i=C("step",n,t,e);return[s.range(r,a,i,C("dtype",n,t,e))]}case"TruncatedNormal":{const r=C("shape",n,t,e),a=C("mean",n,t,e),i=C("stdDev",n,t,e),o=C("seed",n,t,e);return[s.truncatedNormal(r,a,i,C("dtype",n,t,e),o)]}case"Zeros":return[s.zeros(C("shape",n,t,e),C("dtype",n,t,e))];case"ZerosLike":return[s.zerosLike(C("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"dynamic":return oC(i,o,u);case"evaluation":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"LowerBound":{const r=C("sortedSequence",n,t,e),a=C("values",n,t,e);return[s.lowerBound(r,a)]}case"TopKV2":{const r=C("x",n,t,e),a=C("k",n,t,e),i=C("sorted",n,t,e),o=s.topk(r,a,i);return[o.values,o.indices]}case"UpperBound":{const r=C("sortedSequence",n,t,e),a=C("values",n,t,e);return[s.upperBound(r,a)]}case"Unique":{const r=C("x",n,t,e),a=s.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=C("x",n,t,e),a=C("axis",n,t,e),i=s.unique(r,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"image":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"ResizeBilinear":{const r=C("images",n,t,e),a=C("size",n,t,e),i=C("alignCorners",n,t,e),o=C("halfPixelCenters",n,t,e);return[s.image.resizeBilinear(r,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const r=C("images",n,t,e),a=C("size",n,t,e),i=C("alignCorners",n,t,e),o=C("halfPixelCenters",n,t,e);return[s.image.resizeNearestNeighbor(r,[a[0],a[1]],i,o)]}case"CropAndResize":{const r=C("image",n,t,e),a=C("boxes",n,t,e),i=C("boxInd",n,t,e),o=C("cropSize",n,t,e),u=C("method",n,t,e),c=C("extrapolationValue",n,t,e);return[s.image.cropAndResize(r,a,i,o,u,c)]}case"ImageProjectiveTransformV3":{const r=C("images",n,t,e),a=C("transforms",n,t,e),i=C("outputShape",n,t,e),o=C("fillValue",n,t,e),u=C("interpolation",n,t,e),c=C("fillMode",n,t,e);return[s.image.transform(r,a,u.toLowerCase(),c.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"graph":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const r=C("default",n,t,e);return[Ue(n.name,t,e)||r];case"Placeholder":return[Ue(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Ut(C("x",n,t,e))];case"IdentityN":return C("x",n,t,e).map(d=>Ut(d));case"Shape":return[s.tensor1d(C("x",n,t,e).shape,"int32")];case"ShapeN":return C("x",n,t,e).map(d=>s.tensor1d(d.shape));case"Size":return[s.scalar(C("x",n,t,e).size,"int32")];case"Rank":return[s.scalar(C("x",n,t,e).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=C("x",n,t,e),o=C("data",n,t,e),u=C("message",n,t,e),c=C("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let d=0;d<o.length;d++)console.log(Array.prototype.slice.call(o[d].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"logical":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Equal":return[s.equal(C("a",n,t,e),C("b",n,t,e))];case"NotEqual":return[s.notEqual(C("a",n,t,e),C("b",n,t,e))];case"Greater":return[s.greater(C("a",n,t,e),C("b",n,t,e))];case"GreaterEqual":return[s.greaterEqual(C("a",n,t,e),C("b",n,t,e))];case"Less":return[s.less(C("a",n,t,e),C("b",n,t,e))];case"LessEqual":return[s.lessEqual(C("a",n,t,e),C("b",n,t,e))];case"LogicalAnd":return[s.logicalAnd(C("a",n,t,e),C("b",n,t,e))];case"LogicalNot":return[s.logicalNot(C("a",n,t,e))];case"LogicalOr":return[s.logicalOr(C("a",n,t,e),C("b",n,t,e))];case"Select":case"SelectV2":return[s.where(C("condition",n,t,e),C("a",n,t,e),C("b",n,t,e))];case"BitwiseAnd":return[s.bitwiseAnd(C("a",n,t,e),C("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"matrices":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(C("a",n,t,e),C("b",n,t,e),C("transposeA",n,t,e),C("transposeB",n,t,e))];case"Einsum":return[s.einsum(C("equation",n,t,e),...C("tensors",n,t,e))];case"Transpose":return[s.transpose(C("x",n,t,e),C("perm",n,t,e))];case"_FusedMatMul":const[r,a]=C("fusedOps",n,t,e),i="biasadd"===r,o="prelu"===a,u=C("numArgs",n,t,e),c=C("leakyreluAlpha",n,t,e);if(i){if(o&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[d,p]=C("args",n,t,e);return[s.fused.matMul({a:C("a",n,t,e),b:C("b",n,t,e),transposeA:C("transposeA",n,t,e),transposeB:C("transposeB",n,t,e),bias:d,activation:a,preluActivationWeights:p,leakyreluAlpha:c})];case"MatrixBandPart":return[s.linalg.bandPart(C("a",n,t,e),C("numLower",n,t,e),C("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"normalization":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(C("x",n,t,e),C("axis",n,t,e),C("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[s.batchNorm(C("x",n,t,e),C("mean",n,t,e),C("variance",n,t,e),C("offset",n,t,e),C("scale",n,t,e),C("epsilon",n,t,e))];case"LRN":return[s.localResponseNormalization(C("x",n,t,e),C("radius",n,t,e),C("bias",n,t,e),C("alpha",n,t,e),C("beta",n,t,e))];case"Softmax":return[s.softmax(C("x",n,t,e))];case"LogSoftmax":return[s.logSoftmax(C("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"ragged":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=s.raggedGather(C("paramsNestedSplits",n,t,e),C("paramsDenseValues",n,t,e),C("indices",n,t,e),C("outputRaggedRank",n,t,e));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=s.raggedRange(C("starts",n,t,e),C("limits",n,t,e),C("splits",n,t,e));return[r,a]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(C("shape",n,t,e),C("values",n,t,e),C("defaultValue",n,t,e),C("rowPartitionTensors",n,t,e),C("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"reduction":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Max":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.max(C("x",n,t,e),o,u)]}case"Mean":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.mean(C("x",n,t,e),o,u)]}case"Min":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.min(C("x",n,t,e),o,u)]}case"Sum":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.sum(C("x",n,t,e),o,u)]}case"All":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.all(C("x",n,t,e),o,u)]}case"Any":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.any(C("x",n,t,e),o,u)]}case"ArgMax":{const o=C("axis",n,t,e);return[s.argMax(C("x",n,t,e),o)]}case"ArgMin":{const o=C("axis",n,t,e);return[s.argMin(C("x",n,t,e),o)]}case"Prod":{const o=C("axis",n,t,e),u=C("keepDims",n,t,e);return[s.prod(C("x",n,t,e),o,u)]}case"Cumprod":{const o=C("axis",n,t,e),u=C("exclusive",n,t,e),c=C("reverse",n,t,e);return[s.cumprod(C("x",n,t,e),o,u,c)]}case"Cumsum":{const o=C("axis",n,t,e),u=C("exclusive",n,t,e),c=C("reverse",n,t,e);return[s.cumsum(C("x",n,t,e),o,u,c)]}case"Bincount":const r=C("x",n,t,e),a=C("weights",n,t,e),i=C("size",n,t,e);return[s.bincount(r,a,i)];case"DenseBincount":{const o=C("x",n,t,e),u=C("weights",n,t,e),c=C("size",n,t,e),d=C("binaryOutput",n,t,e);return[s.denseBincount(o,u,c,d)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"slice_join":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"ConcatV2":case"Concat":{const r=C("n",n,t,e),a=C("axis",n,t,e);let i=C("tensors",n,t,e);return i=i.slice(0,r),[s.concat(i,a)]}case"Gather":{const r=C("x",n,t,e),a=C("indices",n,t,e);return[s.gather(r,s.cast(a,"int32"),0)]}case"GatherV2":{const r=C("axis",n,t,e),a=C("batchDims",n,t,e),i=C("x",n,t,e),o=C("indices",n,t,e);return[s.gather(i,s.cast(o,"int32"),r,a)]}case"Reverse":{const r=C("dims",n,t,e),a=[];for(let o=0;o<r.length;o++)r[o]&&a.push(o);const i=C("x",n,t,e);return[s.reverse(i,a)]}case"ReverseV2":{const r=C("axis",n,t,e),a=C("x",n,t,e);return[s.reverse(a,r)]}case"Slice":{const r=C("begin",n,t,e),a=C("size",n,t,e);return[s.slice(C("x",n,t,e),r,a)]}case"StridedSlice":{const r=C("begin",n,t,e),a=C("end",n,t,e),i=C("strides",n,t,e),o=C("beginMask",n,t,e),u=C("endMask",n,t,e),c=C("ellipsisMask",n,t,e),d=C("newAxisMask",n,t,e),p=C("shrinkAxisMask",n,t,e),h=C("x",n,t,e);return[s.stridedSlice(h,r,a,i,o,u,c,d,p)]}case"Pack":return(0,l.tidy)(()=>{const r=C("axis",n,t,e),a=C("tensors",n,t,e),i=a[0].shape,o=s.squeeze(a[0]).shape,u=a.map(c=>{const d=l.util.arraysEqual(c.shape,i);if(!d&&!l.util.arraysEqual(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return d?c:s.reshape(c,i)});return[s.stack(u,r)]});case"Unpack":{const r=C("axis",n,t,e),a=C("tensor",n,t,e);return s.unstack(a,r)}case"Tile":{const r=C("reps",n,t,e);return[s.tile(C("x",n,t,e),r)]}case"Split":case"SplitV":{const r=C("axis",n,t,e),a=C("numOrSizeSplits",n,t,e),i=C("x",n,t,e);return s.split(i,a,r)}case"ScatterNd":{const r=C("indices",n,t,e),a=C("values",n,t,e),i=C("shape",n,t,e);return[s.scatterND(r,a,i)]}case"GatherNd":{const r=C("x",n,t,e),a=C("indices",n,t,e);return[s.gatherND(r,a)]}case"SparseToDense":{const r=C("sparseIndices",n,t,e),a=C("outputShape",n,t,e),i=C("sparseValues",n,t,e),o=C("defaultValue",n,t,e);return[s.sparseToDense(r,i,a,i.dtype===o.dtype?o:s.cast(o,i.dtype))]}case"TensorScatterUpdate":{const r=C("indices",n,t,e),a=C("values",n,t,e),i=C("tensor",n,t,e);return[s.tensorScatterUpdate(i,r,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"sparse":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(C("indices",n,t,e),C("values",n,t,e),C("denseShape",n,t,e),C("defaultValue",n,t,e));return[r,a,i,o]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=s.sparse.sparseReshape(C("inputIndices",n,t,e),C("inputShape",n,t,e),C("newShape",n,t,e));return[r,a]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(C("data",n,t,e),C("indices",n,t,e),C("segmentIds",n,t,e))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(C("data",n,t,e),C("indices",n,t,e),C("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"spectral":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"FFT":return[s.fft(C("x",n,t,e))];case"IFFT":return[s.ifft(C("x",n,t,e))];case"RFFT":return[s.rfft(C("x",n,t,e))];case"IRFFT":return[s.irfft(C("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"string":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(C("input",n,t,e),C("pattern",n,t,e),C("rewrite",n,t,e),C("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=s.string.stringNGrams(C("data",n,t,e),C("dataSplits",n,t,e),C("separator",n,t,e),C("nGramWidths",n,t,e),C("leftPad",n,t,e),C("rightPad",n,t,e),C("padWidth",n,t,e),C("preserveShortSequences",n,t,e));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:i}=s.string.stringSplit(C("input",n,t,e),C("delimiter",n,t,e),C("skipEmpty",n,t,e));return[r,a,i]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(C("input",n,t,e),C("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"transformation":return r(()=>((n,t,e,s=He)=>{switch(n.op){case"Cast":return[s.cast(C("x",n,t,e),C("dtype",n,t,e))];case"ExpandDims":{const r=C("axis",n,t,e);return[s.expandDims(C("x",n,t,e),r)]}case"Squeeze":{const r=C("axis",n,t,e);return[s.squeeze(C("x",n,t,e),r)]}case"Reshape":return[s.reshape(C("x",n,t,e),C("shape",n,t,e))];case"EnsureShape":return[s.ensureShape(C("x",n,t,e),C("shape",n,t,e))];case"MirrorPad":return[s.mirrorPad(C("x",n,t,e),C("padding",n,t,e),C("mode",n,t,e))];case"PadV2":case"Pad":return[s.pad(C("x",n,t,e),C("padding",n,t,e),C("constantValue",n,t,e))];case"SpaceToBatchND":{const r=C("blockShape",n,t,e),a=C("paddings",n,t,e);return[s.spaceToBatchND(C("x",n,t,e),r,a)]}case"BatchToSpaceND":{const r=C("blockShape",n,t,e),a=C("crops",n,t,e);return[s.batchToSpaceND(C("x",n,t,e),r,a)]}case"DepthToSpace":{const r=C("blockSize",n,t,e),a=C("dataFormat",n,t,e).toUpperCase();return[s.depthToSpace(C("x",n,t,e),r,a)]}case"BroadcastTo":return[s.broadcastTo(C("x",n,t,e),C("shape",n,t,e))];case"BroadcastArgs":return[s.broadcastArgs(C("s0",n,t,e),C("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}})(i,o,u));case"hash_table":return dC(i,o,u,s);case"custom":const c=cc(i.op);if(c&&c.customExecutor)return c.customExecutor(new Zb(i,o,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return l.util.isPromise(a)?a.then(i=>[].concat(i)):[].concat(a)}class bc{constructor(t={},e={},s={},r={},a){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=s,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const s=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(s))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function Cc(n,t,e,s){const r=new Set,a=[];let i=null,o=null;const u=new Set,c=new Set(Object.keys(n).map(h=>st(h)[0]));s=s||[];const d=new Set(s.map(h=>st(h.name)[0])),p=[...t];for(;p.length>0;){const h=p.pop();if((kn(h)||DC(h)||$C(h))&&null==i&&(i=h,o=i.children.map(f=>f.name).filter(f=>r.has(f))),r.add(h.name),null==e[h.name]&&!c.has(h.name)&&!d.has(h.name)){if(0===h.inputs.length){a.push(h.name);continue}h.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),p.push(f))})}}return{inputs:n,outputs:t,usedNodes:r,missingInputs:a,dynamicNode:i,syncInputs:o}}class gr extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}const kC=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),RC=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),AC=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function kn(n){return kC.has(n.op)}function DC(n){return RC.has(n.op)}function $C(n){return AC.has(n.op)}class yr{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new yr(t.functions[s],this)})}getCompilationKey(t,e){const s=t.map(a=>a.name).sort(),r=e.map(a=>a.name).sort();return s.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(t,e){const s=Cc(t,e,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:i}=s;if(null!=a)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(r.length>0){const c=e.map(p=>p.name),d=Object.keys(t);throw new Error(`Cannot compute the outputs [${c}] from the provided inputs [${d}]. Missing the following inputs: [${r}]`)}const o=function IC(n,t){const{usedNodes:e,inputs:s}=t,i=g=>e.has("string"==typeof g?g:g.name);function o(g){return[...new Map(g.map(x=>[x.name,x])).values()]}const u=o([...Object.keys(s).map(g=>st(g)[0]).map(g=>n.nodes[g]),...n.weights,...n.initNodes||[]]).filter(i),c=o([...u,...Object.values(n.nodes)]).filter(i),d=new Map(c.map(g=>[g.name,g])),p={};for(const g of c){p[g.name]=p[g.name]||0;for(const x of g.children)i(x)||(p[x.name]=Number.POSITIVE_INFINITY),p[x.name]=(p[x.name]||0)+1}const h=Object.entries(p).filter(([,g])=>0===g).map(([g])=>g),f=[...h];for(;h.length>0;){const g=h.pop(),x=d.get(g);for(const b of x.children.filter(i))0==--p[b.name]&&(f.push(b.name),h.push(b.name))}const y=function wC(n,t){const e=new Map(n.map(i=>[i.name,i])),s=t.map(i=>i.name),r=new Set(s);for(;s.length>0;){const i=s.pop(),o=e.get(i);for(const u of o.children)!e.has(u.name)||r.has(u.name)||(r.add(u.name),s.push(u.name))}return n.filter(i=>r.has(i.name))}(f.map(g=>d.get(g)),u);return function NC(n,t){const e=new Map(n.map((o,u)=>[o.name,u])),s=new Set(t.map(o=>o.name)),r=o=>s.has("string"==typeof o?o:o.name),a=new Set(n.map(o=>o.name)),i=o=>a.has("string"==typeof o?o:o.name);for(const o of n){for(const u of o.children.filter(i)){if(!e.has(u.name))throw new gr(`Child ${u.name} of node ${o.name} is unreachable.`);if(e.get(o.name)>e.get(u.name))throw new gr(`Node ${o.name} is scheduled to run after its child ${u.name}.`)}if(!r(o))for(const u of o.inputs){if(!e.has(u.name))throw new gr(`Input ${u.name} of node ${o.name} is unreachable.`);if(e.get(u.name)>e.get(o.name))throw new gr(`Node ${o.name} is scheduled to run before its input ${u.name}.`)}}}(y,u),y}(this.graph,s),u=function TC(n){const t=new Map(n.map((o,u)=>[o.name,u])),e=Number.MAX_SAFE_INTEGER,s=n.map((o,u)=>kn(o)?e:u),r=o=>s[t.get(o.name)]??-1,a=n.map((o,u)=>o.children.map(r).reduce((c,d)=>Math.max(c,d),s[u])),i=new Map;for(let o=0;o<n.length;++o){const u=a[o];if(u===e)continue;const c=n[o],d=n[u];i.has(d.name)||i.set(d.name,[]),i.get(d.name).push(c)}return i}(o);return{orderedNodes:o,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(null==t)return null;const e=t.clone();return(0,l.keep)(e),e}cloneTensorList(t){return t?t.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,s])=>[e,this.cloneTensorList(s)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const r=s.map(h=>this.graph.nodes[st(h)[0]]),a=e.map(h=>st(h)[0]),i=new Set(a);let o=a.map(h=>this.graph.nodes[h]);0===o.length&&(o=this._outputs);const u=this.getCompilationKey(r,o);let c=this.compiledMap.get(u);null==c&&(c=this.compile(t,o),this.compiledMap.set(u,c));try{this.keepIntermediateTensors=(0,l.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const d={},p={};return(0,l.tidy)(()=>{const h=new bc(this.weightMap,d,p,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(x=>{const[b,S]=st(x,h),v=[];v[S]=t[x],f[b]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(v))});const m=this.getFrozenTensorIds(f),{orderedNodes:y,nodeLiveUntilMap:g}=c;for(const x of y){if(f[x.name])continue;const b=xc(x,f,h,this._resourceManager);if(l.util.isPromise(b))throw new Error(`The execution of the op '${x.op}' returned a promise. Please use model.executeAsync() instead.`);f[x.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[x.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(x,f,h,m,i,g.get(x.name))}return null==this.parent&&h.dispose(m),e.map(x=>Ue(x,f,h))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(e)}checkTensorForDisposal(t,e,s,r,a,i,o){if(!kn(e)&&!i.has(t)){for(const u of s[t])null!=u&&(o[u.id]=(o[u.id]||0)+e.children.length);for(const u of e.inputs){if(kn(u))continue;const c=dc(u.name,s,r);if(null!=c)for(const d of c){if(!d||d.kept||a.has(d.id))continue;const p=o[d.id];1===p?(d.dispose(),delete o[d.id]):null!=p&&o[d.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,s,r,a,i){function o(u){return kn(u)||a.has(u.name)}if(!kn(t)&&null!=i)for(const u of i){if(o(u))continue;const c=dc(u.name,e,s);for(const d of c)!d||d.kept||r.has(d.id)||d.dispose()}}executeAsync(t,e){var s=this;return(0,J.Z)(function*(){return s._executeAsync(t,e)})()}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}_executeAsync(t,e,s=!1,r={},a={}){var i=this;return(0,J.Z)(function*(){i.disposeIntermediateTensors(),s||(t=i.mapInputs(t),i.checkInputs(t),i.checkInputShapeAndType(t),e=i.mapOutputs(e),i.checkOutputs(e));try{i.keepIntermediateTensors=(0,l.env)().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){i.keepIntermediateTensors=!1,console.warn(f.message)}const o=new bc(i.weightMap,r,a,i.functionExecutorMap,i.parseNodeNameCache);i.keepIntermediateTensors&&(i.clonedTensorsMap=i.cloneTensorMap(i.weightMap));const u=yield i.executeWithControlFlow(t,o,e,s),c=e.map(f=>Ue(f,u,o)),d=c.map(f=>f.id),p=Object.keys(t).map(f=>t[f].id),h=new Set([...d,...p,...i.weightIds]);return Object.values(u).forEach(f=>{f.forEach(m=>{m&&!m.isDisposed&&!h.has(m.id)&&m.dispose()})}),null==i.parent&&o.dispose(h),c})()}executeFunctionAsync(t,e,s){var r=this;return(0,J.Z)(function*(){const a=t.reduce((i,o,u)=>(i[r.inputs[u].name]=o,i),{});return r._executeAsync(a,r.outputNodes,!0,e,s)})()}executeWithControlFlow(t,e,s,r){var a=this;return(0,J.Z)(function*(){const i=Object.keys(t),o=i.map(I=>a.graph.nodes[st(I)[0]]),u=s.map(I=>st(I)[0]),c=new Set(u);let d=u.map(I=>a.graph.nodes[I]);0===d.length&&(d=a._outputs);const{usedNodes:p,missingInputs:h,dynamicNode:f,syncInputs:m}=Cc(t,d,a.weightMap,a._initNodes),y=[...o,...a.graph.weights,...a._initNodes||[]].map(I=>({node:I,contexts:e.currentContext})),g=Object.assign({},a.weightMap);Object.keys(t).forEach(I=>{const[w,N]=st(I),T=[];T[N]=t[I],g[w]=T});const x={},b=a.getFrozenTensorIds(g),S={};for(;y.length>0;){const I=a.processStack(o,y,e,g,S,b,c,x,p);yield Promise.all(I)}null==f&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const v=d.filter(I=>!kn(I)&&!Ue(I.name,g,e)).map(I=>I.name);if(v.length>0){let I="";throw null!=f&&(I=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${v}] from the provided inputs [${i}]. Consider providing the following inputs: [${h}]. ${I}`)}return g})()}processStack(t,e,s,r,a,i,o,u,c){const d=[];for(;e.length>0;){const p=e.pop();s.currentContext=p.contexts;let h="";if("Enter"===p.node.op&&C("isConstant",p.node,r,s)&&([h]=Gt(p.node.name,s)),null==r[p.node.name]){const f=xc(p.node,r,s,this._resourceManager);h||([h]=Gt(p.node.name,s));const m=s.currentContext;l.util.isPromise(f)?d.push(f.then(y=>(r[h]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(y)),s.currentContext=m,this.checkTensorForDisposal(h,p.node,r,s,i,o,u),this.processChildNodes(p.node,e,s,r,a,c),y))):(r[h]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(f)),this.checkTensorForDisposal(h,p.node,r,s,i,o,u),this.processChildNodes(p.node,e,s,r,a,c))}else this.processChildNodes(p.node,e,s,r,a,c)}return d}processChildNodes(t,e,s,r,a,i){t.children.forEach(o=>{const[u]=Gt(o.name,s);a[u]||!i.has(o.name)||("Merge"===o.op?o.inputNames.some(c=>!!Ue(c,r,s))&&(a[u]=!0,e.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!Ue(c,r,s))&&(a[u]=!0,e.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const s=t[e],[r]=st(e),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const i=a.attrParams.shape.value,o=i.length===s.shape.length&&s.shape.every((u,c)=>-1===i[c]||i[c]===u);l.util.assert(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&l.util.assert(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(t){var e,s;const r={};for(const a in t){const i=null===(s=null===(e=this._signature)||void 0===e?void 0:e.inputs)||void 0===s?void 0:s[a];null!=i?r[i.name]=t[a]:r[a]=t[a]}return r}checkInputs(t){const e=Object.keys(t).filter(s=>{const[r]=st(s);return null==this.graph.nodes[r]});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var s,r;const a=null===(r=null===(s=this._signature)||void 0===s?void 0:s.outputs)||void 0===r?void 0:r[e];return null!=a?a.name:e},{})}checkOutputs(t){t.forEach(e=>{const[s]=st(e);if(!this.graph.nodes[s])throw new Error(`The output '${e}' is not found in the graph`)})}}class EC{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const _C="?tfjs-format=file",FC="model.json";class vc{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},s=l.io){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=s,null==e&&(this.loadOptions={}),this.resourceManager=new EC}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return l.util.isPromise(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let s=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const a=this.artifacts.userDefinedMetadata;null!=a.signature&&(s=a.signature),null!=a.structuredOutputKeys&&(this.structuredOutputKeys=a.structuredOutputKeys)}this.signature=s,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new yr(pc.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,null!=t.modelInitializer&&null!=t.modelInitializer.node){const a=pc.Instance.transformGraph(t.modelInitializer);this.initializer=new yr(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}save(t,e){var s=this;return(0,J.Z)(function*(){if("string"==typeof t){const r=s.io.getSaveHandlers(t);if(0===r.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(s.artifacts)})()}addStructuredOutputNames(t){if(this.structuredOutputKeys){const s={};return(t instanceof l.Tensor?[t]:t).forEach((r,a)=>s[this.structuredOutputKeys[a]]=r),s}return t}predict(t,e){const s=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(s)}predictAsync(t,e){var s=this;return(0,J.Z)(function*(){const r=yield s.executeAsync(t,s.outputNodes);return s.addStructuredOutputNames(r)})()}normalizeInputs(t){var e;if(!(t instanceof l.Tensor||Array.isArray(t))){const a=null===(e=this.signature)||void 0===e?void 0:e.inputs;if(null!=a)for(const i in a){const o=a[i];null!=o.resourceId&&(t[i]=this.resourceIdToCapturedInput[o.resourceId])}return t}t=Array.isArray(t)?t:[t];const s=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${t.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,i)=>{var o,u,c;const d=null===(c=null===(u=null===(o=this.signature)||void 0===o?void 0:o.inputs)||void 0===u?void 0:u[i])||void 0===c?void 0:c.resourceId;return a[i]=null!=d?this.resourceIdToCapturedInput[d]:t[r++],a},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return null==this.initializer?[]:this.initializer.execute({},null==this.initializerSignature?[]:Object.keys(this.initializerSignature.outputs))}executeInitializerGraphAsync(){var t=this;return(0,J.Z)(function*(){return null==t.initializer?[]:t.initializer.executeAsync({},null==t.initializerSignature?[]:Object.keys(t.initializerSignature.outputs))})()}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,s=Object.keys(e);for(let r=0;r<s.length;r++)this.resourceIdToCapturedInput[e[s[r]].resourceId]=t[r]}}execute(t,e){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const s=this.executor.execute(t,e);return s.length>1?s:s[0]}executeAsync(t,e){var s=this;return(0,J.Z)(function*(){null==s.resourceIdToCapturedInput&&s.setResourceIdToCapturedInput(yield s.executeInitializerGraphAsync()),t=s.normalizeInputs(t),e=s.normalizeOutputs(e);const r=yield s.executor.executeAsync(t,e);return r.length>1?r:r[0]})()}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,s)=>(e[s]=[t[s]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&(0,l.dispose)(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}function OC(n){return Ni.apply(this,arguments)}function Ni(){return(Ni=(0,J.Z)(function*(n,t={},e=l.io){if(null==n)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"==typeof n&&(n=function zC(n){return n.endsWith("/")||(n+="/"),`${n}${FC}${_C}`}(n));const s=new vc(n,t,e);return yield s.load(),s})).apply(this,arguments)}var PC=R(4901);function ee(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&l.util.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the CPU backend.`)})}Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");const dv=l.kernel_impls.whereImpl;let pv=(()=>{class n extends l.KernelBackend{nextDataId(){return n.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new l.DataStorage(this,(0,l.engine)())}write(e,s,r){this.firstUse&&(this.firstUse=!1,(0,l.env)().get("IS_NODE")&&l.backend_util.warn("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:r,refCount:1}),a}makeTensorInfo(e,s,r){let a;if("string"===s&&null!=r&&r.length>0&&l.util.isString(r[0])){const i=r.map(o=>l.util.encodeString(o));a=this.write(i,e,s)}else a=this.write(r,e,s);return{dataId:a,shape:e,dtype:s}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){this.data.get(e).refCount++}decRef(e){this.data.has(e)&&this.data.get(e).refCount--}move(e,s,r,a,i){this.data.set(e,{values:s,dtype:a,refCount:i})}numDataIds(){return this.data.numDataIds()}read(e){var s=this;return(0,J.Z)(function*(){return s.readSync(e)})()}readSync(e){const{dtype:s,complexTensorInfos:r}=this.data.get(e);if("complex64"===s){const a=this.readSync(r.real.dataId),i=this.readSync(r.imag.dataId);return l.backend_util.mergeRealAndImagArrays(a,i)}return l.util.convertBackendValuesAndArrayBuffer(this.data.get(e).values,s)}bufferSync(e){const s=this.readSync(e.dataId);if("string"===e.dtype)try{const r=s.map(a=>l.util.decodeString(a));return(0,l.buffer)(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,l.buffer)(e.shape,e.dtype,s)}makeOutput(e,s,r){return(0,l.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(s,r,e),this)}disposeData(e,s=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!s&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);null!=r&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}time(e){return(0,J.Z)(function*(){const s=l.util.now();return e(),{kernelMs:l.util.now()-s}})()}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ee([e],"where");const s=this.readSync(e.dataId);return dv(e.shape,s)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}return n.nextDataId=0,n})();function zt(n){return(t,e,s)=>{const r=l.util.getArrayFromDType(e,t.length);for(let a=0;a<t.length;++a)r[a]=n(t[a],s);return r}}function me(n,t,e){return an(n,zt(t),e)}function an(n,t,e){return({inputs:s,attrs:r,backend:a})=>{const{x:i}=s;ee(i,n);const o=a,u=o.data.get(i.dataId).values;let c;if("string"===i.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=l.backend_util.fromUint8ToStringArray(u)}else c=u;const d=e||i.dtype,p=t(c,d,r);return o.makeTensorInfo(i.shape,d,p)}}(0,l.registerBackend)("cpu",()=>new pv,1);const Ec=me(l.Elu,n=>n>=0?n:Math.exp(n)-1),fv={kernelName:l.Elu,backendName:"cpu",kernelFunc:Ec};function Lt(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const mv={kernelName:l.Identity,backendName:"cpu",kernelFunc:Lt};function _c(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:a}=s;ee([r],"leakyRelu");const i=l.util.sizeFromShape(r.shape),o=e.data.get(r.dataId).values,u=l.util.getTypedArrayFromDType("float32",i);for(let c=0;c<o.length;c++)u[c]=o[c]<0?a*o[c]:o[c];return e.makeTensorInfo(r.shape,"float32",u)}const gv={kernelName:l.LeakyRelu,backendName:"cpu",kernelFunc:_c};function Oe(n){return(t,e,s,r,a)=>{const i=l.backend_util.assertAndGetBroadcastShape(t,e),o=i.length,u=l.util.computeStrides(i),c=l.util.sizeFromShape(i),d=l.util.getTypedArrayFromDType(a,c),p=t.length,h=e.length,f=l.util.computeStrides(t),m=l.util.computeStrides(e),y=l.backend_util.getBroadcastDims(t,i),g=l.backend_util.getBroadcastDims(e,i);if(y.length+g.length===0)for(let x=0;x<d.length;++x)d[x]=n(s[x%s.length],r[x%r.length]);else for(let x=0;x<d.length;++x){const b=l.util.indexToLoc(x,o,u),S=b.slice(-p);y.forEach(N=>S[N]=0);const v=l.util.locToIndex(S,p,f),I=b.slice(-h);g.forEach(N=>I[N]=0);const w=l.util.locToIndex(I,h,m);d[x]=n(s[v],r[w])}return[d,i]}}const yv=Oe((n,t)=>n<0?t*n:n);function Fc(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t;ee([s,r],"prelu");const a=e.data.get(s.dataId).values,i=e.data.get(r.dataId).values,[o,u]=yv(s.shape,r.shape,a,i,"float32");return e.makeTensorInfo(u,"float32",o)}const xv={kernelName:l.Prelu,backendName:"cpu",kernelFunc:Fc},Oc=me(l.Relu,n=>Math.max(0,n)),bv={kernelName:l.Relu,backendName:"cpu",kernelFunc:Oc},zc=me(l.Relu6,n=>Math.min(Math.max(0,n),6)),Cv={kernelName:l.Relu6,backendName:"cpu",kernelFunc:zc},vv=zt(n=>1/(1+Math.exp(-n))),Lc=me(l.Sigmoid,n=>1/(1+Math.exp(-n))),Sv={kernelName:l.Sigmoid,backendName:"cpu",kernelFunc:Lc};function vr(n,t,e,s,r){if("linear"===e)return Lt({inputs:{x:t},backend:n});if("relu"===e)return Oc({inputs:{x:t},backend:n});if("elu"===e)return Ec({inputs:{x:t},backend:n});if("relu6"===e)return zc({inputs:{x:t},backend:n});if("prelu"===e)return Fc({inputs:{x:t,alpha:s},backend:n});if("leakyrelu"===e)return _c({inputs:{x:t},backend:n,attrs:{alpha:r}});if("sigmoid"===e)return Lc({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function rt(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,a=e.data.get(s.dataId).values,i=e.data.get(r.dataId).values,o=e.makeTensorInfo(s.shape,"complex64");return e.data.get(o.dataId).complexTensorInfos={real:e.makeTensorInfo(s.shape,"float32",a),imag:e.makeTensorInfo(r.shape,"float32",i)},o}const Iv={kernelName:l.Complex,backendName:"cpu",kernelFunc:rt};function Sr(n,t,e="float32"){if("complex64"===e)return rt({inputs:{real:Sr(n,t,"float32"),imag:Sr(n,t,"float32")},backend:n});const s=l.util.makeZerosTypedArray(l.util.sizeFromShape(t),e);return n.makeTensorInfo(t,e,s)}function Rn(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.real,a=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,a)}const wv={kernelName:l.Real,backendName:"cpu",kernelFunc:Rn};function Pc(n,t,e,s){if("int32"===s)return[t,"int32",Int32Array.from(n)];if("bool"===s){const r=l.util.toTypedArray([0],e),[a,i]=Oe((o,u)=>o!==u?1:0)(t,[],n,r,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${e} to ${s}`)}function on(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return Lt({inputs:{x:r},backend:e});const d=Sr(e,r.shape,r.dtype),p=on({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),h=rt({inputs:{real:p,imag:d},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),h}if("complex64"===r.dtype){const d=Rn({inputs:{input:r},backend:e}),p=on({inputs:{x:d},backend:e,attrs:{dtype:a}});return e.disposeIntermediateTensorInfo(d),p}if(!l.util.hasEncodingLoss(r.dtype,a)){const d=Lt({inputs:{x:r},backend:e});return{dataId:d.dataId,shape:d.shape,dtype:a}}const i=e.data.get(r.dataId).values,[o,u,c]=Pc(i,r.shape,r.dtype,a);return e.makeTensorInfo(o,u,c)}const Nv={kernelName:l.Cast,backendName:"cpu",kernelFunc:on};function We(n,t,e,s){return null==e?({inputs:r,backend:a})=>{const{a:i,b:o}=r,u=a;ee([i,o],n);const c=u.data.get(i.dataId).values,d=u.data.get(o.dataId).values,p="string"===i.dtype?l.backend_util.fromUint8ToStringArray(c):c,h="string"===i.dtype?l.backend_util.fromUint8ToStringArray(d):d,f=s||i.dtype,[m,y]=t(i.shape,o.shape,p,h,f);return u.makeTensorInfo(y,f,m)}:({inputs:r,backend:a})=>{const{a:i,b:o}=r,u=a;if("complex64"===i.dtype||"complex64"===o.dtype){const c=on({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),d=u.data.get(c.dataId),h=d.complexTensorInfos.imag,f=u.data.get(d.complexTensorInfos.real.dataId).values,m=u.data.get(h.dataId).values,y=on({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(y.dataId),b=g.complexTensorInfos.imag,S=u.data.get(g.complexTensorInfos.real.dataId).values,v=u.data.get(b.dataId).values,[I,w,N]=e(i.shape,o.shape,f,m,S,v),T=u.makeTensorInfo(N,"float32",I),D=u.makeTensorInfo(N,"float32",w),A=rt({inputs:{real:T,imag:D},backend:u});return u.disposeIntermediateTensorInfo(c),u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo(T),u.disposeIntermediateTensorInfo(D),A}{const c=u.data.get(i.dataId).values,d=u.data.get(o.dataId).values,p=s||i.dtype,[h,f]=t(i.shape,o.shape,c,d,p);return u.makeTensorInfo(f,p,h)}}}function Ei(n){return(t,e,s,r,a,i)=>{const o=l.backend_util.assertAndGetBroadcastShape(t,e),u=l.util.sizeFromShape(o),c=o.length,d=l.util.computeStrides(o),p=l.util.getTypedArrayFromDType("float32",u),h=l.util.getTypedArrayFromDType("float32",u),f=l.backend_util.getBroadcastDims(t,o),m=l.backend_util.getBroadcastDims(e,o),y=l.backend_util.mergeRealAndImagArrays(s,r),g=l.backend_util.mergeRealAndImagArrays(a,i),x=t.length,b=l.util.computeStrides(t),S=e.length,v=l.util.computeStrides(e);if(f.length+m.length===0)for(let I=0;I<p.length;I++){const w=I%y.length,N=I%g.length,T=n(y[2*w],y[2*w+1],g[2*N],g[2*N+1]);p[I]=T.real,h[I]=T.imag}else for(let I=0;I<p.length;I++){const w=l.util.indexToLoc(I,c,d),N=w.slice(-x);f.forEach(F=>N[F]=0);const T=l.util.locToIndex(N,x,b),D=w.slice(-S);m.forEach(F=>D[F]=0);const A=l.util.locToIndex(D,S,v),$=n(y[2*T],y[2*T+1],g[2*A],g[2*A+1]);p[I]=$.real,h[I]=$.imag}return[p,h,o]}}const Vc=Oe((n,t)=>n+t),Tv=Ei((n,t,e,s)=>({real:n+e,imag:t+s})),jn=We(l.Add,Vc,Tv),kv={kernelName:l.Add,backendName:"cpu",kernelFunc:jn};function Se(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:a}=s,i=l.util.sizeFromShape(r.shape),o=l.util.inferFromImplicitShape(a,i),u=l.util.sizeFromShape(o);l.util.assert(i===u,()=>`The new shape (${o}) has ${u} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),e.incRef(r.dataId);const c=e.data.get(r.dataId);if(null!=c.complexTensorInfos){const p=c.complexTensorInfos.imag;c.complexTensorInfos.real.shape=o,p.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const Rv={kernelName:l.Reshape,backendName:"cpu",kernelFunc:Se};function Bc(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a}=t,{transposeA:i,transposeB:o}=s;ee([r,a],"matMul");const u=r.shape.length,c=a.shape.length,d=i?r.shape[u-2]:r.shape[u-1],p=o?a.shape[c-1]:a.shape[c-2],h=i?r.shape[u-1]:r.shape[u-2],f=o?a.shape[c-2]:a.shape[c-1],m=r.shape.slice(0,-2),y=a.shape.slice(0,-2),g=l.util.sizeFromShape(m),x=l.util.sizeFromShape(y),S=l.broadcast_util.assertAndGetBroadcastShape(r.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,f]);l.util.assert(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const I=o?[x,f,p]:[x,p,f],w=Se({inputs:{x:r},backend:e,attrs:{shape:i?[g,d,h]:[g,h,d]}}),N=Se({inputs:{x:a},backend:e,attrs:{shape:I}}),T=i?w.shape[1]:w.shape[2],D=i?w.shape[2]:w.shape[1],A=o?N.shape[1]:N.shape[2],$=Math.max(g,x),F=e.data.get(w.dataId).values,O=e.data.get(N.dataId).values,L=l.util.computeStrides(w.shape),z=l.util.computeStrides(N.shape),[P,B,_]=i?[L[0],1,L[1]]:[L[0],L[1],1],[V,G,U]=o?[1,z[1],z[0]]:[z[1],1,z[0]],j=D*A,H=(0,l.buffer)([$,D,A],w.dtype),Z=H.values,X=e.blockSize;for(let Q=0;Q<$;Q++){const ne=Q%g,ae=Q%x;for(let re=0;re<D;re+=X){const le=Math.min(re+X,D);for(let ce=0;ce<A;ce+=X){const ge=Math.min(ce+X,A);for(let Ie=0;Ie<T;Ie+=X){const Ee=Math.min(Ie+X,T);for(let we=re;we<le;we++)for(let be=ce;be<ge;be++){let $e=0;for(let Ae=Ie;Ae<Ee;Ae++)$e+=F[ne*P+we*B+Ae*_]*O[Ae*V+be*G+ae*U];Z[Q*j+(we*A+be)]+=$e}}}}}return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(N),e.makeTensorInfo(S,H.dtype,H.values)}const Av={kernelName:l.BatchMatMul,backendName:"cpu",kernelFunc:Bc},$v={kernelName:l._FusedMatMul,backendName:"cpu",kernelFunc:function Dv(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=s;let h,f,m;const y=[];h=Bc({inputs:{a:r,b:a},attrs:{transposeA:u,transposeB:c},backend:e}),i&&(f=jn({inputs:{a:h,b:i},backend:e}),y.push(h),h=f),d&&(m=vr(e,h,d,o,p),y.push(h),h=m);for(const x of y)e.disposeIntermediateTensorInfo(x);return h}};function Mc(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const _v={kernelName:l.Abs,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend;ee(t,"abs");let s=new Float32Array(l.util.sizeFromShape(t.shape));return s=Mc(e.data.get(t.dataId).values),e.makeOutput(s,t.shape,t.dtype)}},Fv=me(l.Acos,n=>Math.acos(n)),Ov={kernelName:l.Acos,backendName:"cpu",kernelFunc:Fv},zv=me(l.Acosh,n=>Math.acosh(n)),Lv={kernelName:l.Acosh,backendName:"cpu",kernelFunc:zv},Vv={kernelName:l.AddN,backendName:"cpu",kernelFunc:function Pv(n){const{inputs:t,backend:e}=n,s=t;ee(t,"addN");const r=s.map(o=>e.data.get(o.dataId).values),a=(0,l.buffer)(s[0].shape,s[0].dtype),i=a.values;for(let o=0;o<s.length;o++){const u=r[o];for(let c=0;c<i.length;c++)i[c]+=u[c]}return e.makeTensorInfo(a.shape,a.dtype,a.values)}};function _i(n,t,e,s,r){const a=t.length,i=l.util.sizeFromShape(t),o=l.util.computeStrides(t),u=l.util.computeStrides(r),c=l.util.getTypedArrayFromDType(e,l.util.sizeFromShape(r));for(let d=0;d<i;++d){const p=l.util.indexToLoc(d,a,o),h=new Array(p.length);for(let m=0;m<h.length;m++)h[m]=p[s[m]];c[l.util.locToIndex(h,a,u)]=n[d]}return c}function nt(n){const{inputs:t,attrs:e,backend:s}=n,{x:r}=t,{perm:a}=e;ee(r,"transpose");const o=new Array(r.shape.length);for(let p=0;p<o.length;p++)o[p]=r.shape[a[p]];const c=_i(s.data.get(r.dataId).values,r.shape,r.dtype,a,o);return{dataId:s.write(c,o,r.dtype),shape:o,dtype:r.dtype}}const Bv={kernelName:l.Transpose,backendName:"cpu",kernelFunc:nt},Wv={kernelName:l.All,backendName:"cpu",kernelFunc:function Mv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s;ee(r,"all");const o=l.util.parseAxisParam(a,r.shape);let u=o;const c=l.backend_util.getAxesPermutation(u,r.shape.length);let d=r;null!=c&&(d=nt({inputs:{x:r},backend:e,attrs:{perm:c}}),u=l.backend_util.getInnerMostAxes(u.length,r.shape.length)),l.backend_util.assertAxesAreInnerMostDims("all",u,d.shape.length);const[p,h]=l.backend_util.computeOutAndReduceShapes(d.shape,u),f=l.util.sizeFromShape(h),m=l.util.makeZerosTypedArray(l.util.sizeFromShape(p),d.dtype),y=e.data.get(d.dataId).values;for(let x=0;x<m.length;++x){const b=x*f;let S=y[b];for(let v=0;v<f;++v)S=S&&y[b+v];m[x]=S}null!=c&&e.disposeIntermediateTensorInfo(d);const g=e.makeTensorInfo(p,d.dtype,m);if(i){const b=Se({inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(p,o)}});return e.disposeIntermediateTensorInfo(g),b}return g}},Uv={kernelName:l.Any,backendName:"cpu",kernelFunc:function Gv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s;ee(r,"any");const o=l.util.parseAxisParam(a,r.shape);let u=o;const c=l.backend_util.getAxesPermutation(u,r.shape.length);let d=r;null!=c&&(d=nt({inputs:{x:r},backend:e,attrs:{perm:c}}),u=l.backend_util.getInnerMostAxes(u.length,r.shape.length)),l.backend_util.assertAxesAreInnerMostDims("any",u,d.shape.length);const[p,h]=l.backend_util.computeOutAndReduceShapes(d.shape,u),f=l.util.sizeFromShape(h),m=l.util.makeZerosTypedArray(l.util.sizeFromShape(p),d.dtype),y=e.data.get(d.dataId).values;for(let x=0;x<m.length;++x){const b=x*f;let S=y[b];for(let v=0;v<f;++v)S=S||y[b+v];m[x]=S}null!=c&&e.disposeIntermediateTensorInfo(d);const g=e.makeTensorInfo(p,d.dtype,m);if(i){const b=Se({inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(p,o)}});return e.disposeIntermediateTensorInfo(g),b}return g}},jv={kernelName:l.ArgMax,backendName:"cpu",kernelFunc:function Hv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;ee(r,"argMax");let i=l.util.parseAxisParam(a,r.shape);const o=l.backend_util.getAxesPermutation(i,r.shape.length);let u=r;const c=[];null!=o&&(u=nt({inputs:{x:r},backend:e,attrs:{perm:o}}),c.push(u),i=l.backend_util.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],l.backend_util.assertAxesAreInnerMostDims("argMax",i,u.shape.length);const[d,p]=l.backend_util.computeOutAndReduceShapes(u.shape,i),h=l.util.sizeFromShape(d),f=l.util.makeZerosTypedArray(h,"int32"),m=l.util.sizeFromShape(p),y=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const x=g*m;let b=y[x],S=0;for(let v=0;v<m;++v){const I=y[x+v];I>b&&(b=I,S=v)}f[g]=S}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(d,"int32",f)}},Kv={kernelName:l.ArgMin,backendName:"cpu",kernelFunc:function Xv(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;ee(r,"argMin");let i=l.util.parseAxisParam(a,r.shape);const o=l.backend_util.getAxesPermutation(i,r.shape.length);let u=r;const c=[];null!=o&&(u=nt({inputs:{x:r},backend:e,attrs:{perm:o}}),c.push(u),i=l.backend_util.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],l.backend_util.assertAxesAreInnerMostDims("argMin",i,u.shape.length);const[d,p]=l.backend_util.computeOutAndReduceShapes(u.shape,i),h=l.util.sizeFromShape(d),f=l.util.makeZerosTypedArray(h,"int32"),m=l.util.sizeFromShape(p),y=e.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const x=g*m;let b=y[x],S=0;for(let v=0;v<m;++v){const I=y[x+v];I<b&&(b=I,S=v)}f[g]=S}return c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(d,"int32",f)}},qv=me(l.Asin,n=>Math.asin(n)),Zv={kernelName:l.Asin,backendName:"cpu",kernelFunc:qv},Yv=me(l.Asinh,n=>Math.asinh(n)),Qv={kernelName:l.Asinh,backendName:"cpu",kernelFunc:Yv},Jv=me(l.Atan,n=>Math.atan(n)),eS={kernelName:l.Atan,backendName:"cpu",kernelFunc:Jv},tS=Oe((n,t)=>Math.atan2(n,t)),nS=We(l.Atan2,tS),sS={kernelName:l.Atan2,backendName:"cpu",kernelFunc:nS},rS=me(l.Atanh,n=>Math.atanh(n)),aS={kernelName:l.Atanh,backendName:"cpu",kernelFunc:rS};function Fi(n,t,e,s,r,a){const i=r.strideHeight,o=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,p=r.effectiveFilterWidth,h=r.padInfo.top,f=r.padInfo.left,m="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=(0,l.buffer)(r.outShape,e),g=y.values,x=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],S=r.outShape[3];for(let v=0;v<r.batchSize;++v){const I=v*x,w=v*s[0];for(let N=0;N<r.inChannels;++N)for(let T=0;T<r.outHeight;++T){const D=T*i-h,A=Math.max(0,D),$=Math.min(r.inHeight,d+D),F=I+T*b;for(let O=0;O<r.outWidth;++O){const L=O*o-f,z=Math.max(0,L),P=Math.min(r.inWidth,p+L);let B=m,_=0,V=0;for(let U=A;U<$;U+=u){const j=w+U*s[1];for(let H=z;H<P;H+=c){const X=n[j+H*s[2]+N];"max"===a&&X>B?B=X:"avg"===a&&(_+=X,V++)}if(isNaN(B))break}g[F+O*S+N]="avg"===a?_/V:B}}}return y}function Wc(n,t,e,s,r=!1,a=!1){const i=(0,l.buffer)(s.outShape,"int32"),o=s.strideHeight,u=s.strideWidth,c=s.dilationHeight,d=s.dilationWidth,p=s.effectiveFilterHeight,h=s.effectiveFilterWidth,f=s.padInfo.top,m=s.padInfo.left,y=(0,l.buffer)(t,e,n);for(let g=0;g<s.batchSize;++g)for(let x=0;x<s.inChannels;++x)for(let b=0;b<s.outHeight;++b){const S=b*o-f;let v=S;for(;v<0;)v+=c;const I=Math.min(s.inHeight,p+S);for(let w=0;w<s.outWidth;++w){const N=w*u-m;let T=N;for(;T<0;)T+=d;const D=Math.min(s.inWidth,h+N);let A=Number.NEGATIVE_INFINITY,$=-1;for(let F=v;F<I;F+=c){const O=F-S;for(let L=T;L<D;L+=d){const z=L-N,P=y.get(g,F,L,x);P>A&&(A=P,$=r?a?((g*s.inHeight+F)*s.inWidth+L)*s.inChannels+x:(F*s.inWidth+L)*s.inChannels+x:O*h+z)}}i.set($,g,b,w,x)}}return i}function Gc(n,t,e,s,r,a){const i=r.strideDepth,o=r.strideHeight,u=r.strideWidth,c=r.dilationDepth,d=r.dilationHeight,p=r.dilationWidth,h=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,y=r.padInfo.front,g=r.padInfo.top,x=r.padInfo.left,b="max"===a?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=(0,l.buffer)(r.outShape,e),v=S.values,I=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],w=r.outShape[2]*r.outShape[3]*r.outShape[4],N=r.outShape[3]*r.outShape[4],T=r.outShape[4];for(let D=0;D<r.batchSize;++D){const A=D*I,$=D*s[0];for(let F=0;F<r.inChannels;++F)for(let O=0;O<r.outDepth;++O){const L=O*i-y;let z=L;for(;z<0;)z+=c;const P=Math.min(r.inDepth,h+L),B=A+O*w;for(let _=0;_<r.outHeight;++_){const V=_*o-g;let G=V;for(;G<0;)G+=d;const U=Math.min(r.inHeight,f+V),j=B+_*N;for(let H=0;H<r.outWidth;++H){const Z=H*u-x;let X=Z;for(;X<0;)X+=p;const Q=Math.min(r.inWidth,m+Z),ne=j+H*T;let ae=b,re=0,le=0;for(let ge=z;ge<P;ge+=c){const Ie=$+ge*s[1];for(let Ee=G;Ee<U;Ee+=d){const we=Ie+Ee*s[2];for(let be=X;be<Q;be+=p){const Ae=n[we+be*s[3]+F];if("max"===a&&Ae>ae?ae=Ae:"avg"===a&&(re+=Ae,le++),isNaN(ae))break}if(isNaN(ae))break}if(isNaN(ae))break}v[ne+F]="avg"===a?re/Math.max(le,1):ae}}}}return S}const lS={kernelName:l.AvgPool,backendName:"cpu",kernelFunc:function oS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;ee(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const d=l.backend_util.computePool2DInfo(r.shape,a,i,1,o,u);let p;if(1===d.filterWidth&&1===d.filterHeight&&l.util.arraysEqual(d.inShape,d.outShape))p=Lt({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,f=l.util.computeStrides(r.shape),m=Fi(h,0,r.dtype,f,d,"avg");p=e.makeTensorInfo(d.outShape,r.dtype,m.values)}return p}},cS={kernelName:l.AvgPool3D,backendName:"cpu",kernelFunc:function uS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=s;ee(r,"avgPool3d");const d=l.backend_util.computePool3DInfo(r.shape,a,i,1,o,u,c),h=Gc(e.data.get(r.dataId).values,0,r.dtype,l.util.computeStrides(r.shape),d,"avg");return e.makeTensorInfo(h.shape,"float32",h.values)}},pS={kernelName:l.AvgPool3DGrad,backendName:"cpu",kernelFunc:function dS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=s;ee([r,a],"avgPool3DGrad");const d=l.backend_util.computePool3DInfo(a.shape,i,o,1,u,c),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.filterDepth,y=d.filterHeight,g=d.filterWidth,x=d.dilationDepth,b=d.dilationHeight,S=d.dilationWidth,v=d.effectiveFilterDepth,I=d.effectiveFilterHeight,w=d.effectiveFilterWidth,N=v-1-d.padInfo.front,T=w-1-d.padInfo.left,D=I-1-d.padInfo.top,A=(0,l.buffer)(a.shape,"float32"),$=1/(m*y*g),F=e.bufferSync(r);for(let O=0;O<d.batchSize;++O)for(let L=0;L<d.inChannels;++L)for(let z=0;z<d.inDepth;++z)for(let P=0;P<d.inHeight;++P)for(let B=0;B<d.inWidth;++B){const _=z-N,V=P-D,G=B-T;let U=0;for(let j=0;j<v;j+=x){const H=(_+j)/p;if(!(H<0||H>=d.outDepth||Math.floor(H)!==H))for(let Z=0;Z<I;Z+=b){const X=(V+Z)/h;if(!(X<0||X>=d.outHeight||Math.floor(X)!==X))for(let Q=0;Q<w;Q+=S){const ne=(G+Q)/f;ne<0||ne>=d.outWidth||Math.floor(ne)!==ne||(U+=F.get(O,H,X,ne,L))}}}A.set(U*$,O,z,P,B,L)}return e.makeTensorInfo(A.shape,A.dtype,A.values)}},fS={kernelName:l.AvgPoolGrad,backendName:"cpu",kernelFunc:function hS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,i=a;ee([r,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=s,d=l.backend_util.computePool2DInfo(i.shape,o,u,1,c),p=d.strideHeight,h=d.strideWidth,f=d.filterHeight,m=d.filterWidth,y=d.dilationHeight,g=d.dilationWidth,x=d.effectiveFilterHeight,b=d.effectiveFilterWidth,S=b-1-d.padInfo.left,v=x-1-d.padInfo.top,I=(0,l.buffer)(i.shape,"float32"),w=1/(f*m),N=e.data.get(r.dataId).values,T=(0,l.buffer)(r.shape,"float32",N);for(let D=0;D<d.batchSize;++D)for(let A=0;A<d.inChannels;++A)for(let $=0;$<d.inHeight;++$)for(let F=0;F<d.inWidth;++F){const O=$-v,L=F-S;let z=0;for(let P=0;P<x;P+=y){const B=(O+P)/p;if(!(B<0||B>=d.outHeight||Math.floor(B)!==B))for(let _=0;_<b;_+=g){const V=(L+_)/h;V<0||V>=d.outWidth||Math.floor(V)!==V||(z+=T.get(D,B,V,A))}}I.set(z*w,D,$,F,A)}return e.makeTensorInfo(I.shape,I.dtype,I.values)}},gS={kernelName:l.FusedBatchNorm,backendName:"cpu",kernelFunc:function mS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,scale:a,offset:i,mean:o,variance:u}=t;l.util.assert(o.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),l.util.assert(null==i||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),l.util.assert(null==a||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ee([r,o,u,a,i],"batchNorm");let{varianceEpsilon:c}=s;null==c&&(c=.001);const d=e.data.get(r.dataId).values,p=e.data.get(o.dataId).values,h=e.data.get(u.dataId).values,f=a?e.data.get(a.dataId).values:new Float32Array([1]),m=i?e.data.get(i.dataId).values:new Float32Array([0]),y=new Float32Array(d.length),g=m.length,x=f.length,b=h.length,S=p.length;let v=0,I=0,w=0,N=0;for(let T=0;T<d.length;++T)y[T]=m[v++]+(d[T]-p[I++])*f[w++]/Math.sqrt(h[N++]+c),v>=g&&(v=0),I>=S&&(I=0),w>=x&&(w=0),N>=b&&(N=0);return e.makeTensorInfo(r.shape,r.dtype,y)}};function Uc(n,t,e,s,r){const a=l.slice_util.isSliceContinous(s,t,e),i=l.util.sizeFromShape(e),o=l.util.computeStrides(s);if(a){const p=l.slice_util.computeFlatOffset(t,o);return"string"===r?n.slice(p,p+i):n.subarray(p,p+i)}const u="string"===r?l.backend_util.fromUint8ToStringArray(n):n,c=(0,l.buffer)(s,r,u),d=(0,l.buffer)(e,r);for(let p=0;p<d.size;++p){const h=d.indexToLoc(p),f=h.map((m,y)=>m+t[y]);d.set(c.get(...f),...h)}return"string"===r?l.backend_util.fromStringArrayToUint8(d.values):d.values}function An(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,size:i}=s;ee(r,"slice");const[o,u]=l.slice_util.parseSliceParams(r,a,i);l.slice_util.assertParamsValid(r,o,u);const d=Uc(e.data.get(r.dataId).values,o,u,r.shape,r.dtype);return e.makeTensorInfo(u,r.dtype,d)}const yS={kernelName:l.Slice,backendName:"cpu",kernelFunc:An},bS={kernelName:l.BatchToSpaceND,backendName:"cpu",kernelFunc:function xS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,crops:i}=s;ee([r],"batchToSpaceND");const o=a.reduce((x,b)=>x*b),u=l.backend_util.getReshaped(r.shape,a,o),c=l.backend_util.getPermuted(u.length,a.length),d=l.backend_util.getReshapedPermuted(r.shape,a,o),p=l.backend_util.getSliceBeginCoords(i,a.length),h=l.backend_util.getSliceSize(d,i,a.length),f=Se({inputs:{x:r},backend:e,attrs:{shape:u}}),m=nt({inputs:{x:f},backend:e,attrs:{perm:c}}),y=Se({inputs:{x:m},backend:e,attrs:{shape:d}}),g=An({inputs:{x:y},backend:e,attrs:{begin:p,size:h}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),g}};function Oi(n,t,e,s,r){const a=l.util.sizeFromShape(s),i=l.util.makeZerosTypedArray(r,e);for(let o=0;o<n.length;o++){const u=n[o];if(u<0)throw new Error("Input x must be non-negative!");u>=r||(i[u]+=a>0?t[o]:1)}return i}function Hc(n,t,e,s=!1){const r=n.shape[0],a=n.shape[1],i=(0,l.buffer)([r,e],t.dtype);for(let o=0;o<r;o++)for(let u=0;u<a;u++){const c=n.get(o,u);if(c<0)throw new Error("Input x must be non-negative!");c>=e||i.set(s?1:t.size>0?i.get(o,c)+t.get(o,u):i.get(o,c)+1,o,c)}return i}const vS={kernelName:l.Bincount,backendName:"cpu",kernelFunc:function CS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:i}=s,c=Oi(e.data.get(r.dataId).values,e.data.get(a.dataId).values,a.dtype,a.shape,i);return e.makeTensorInfo([i],a.dtype,c)}},SS=Oe((n,t)=>n&t),IS=We(l.BitwiseAnd,SS),wS={kernelName:l.BitwiseAnd,backendName:"cpu",kernelFunc:IS},TS={kernelName:l.BroadcastArgs,backendName:"cpu",kernelFunc:function NS(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,a=e.data.get(s.dataId).values,i=e.data.get(r.dataId).values,o=l.backend_util.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},jc=zt(n=>Math.ceil(n)),kS=an(l.Ceil,jc),RS={kernelName:l.Ceil,backendName:"cpu",kernelFunc:kS},AS=me(l.ClipByValue,(n,t)=>n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n),DS={kernelName:l.ClipByValue,backendName:"cpu",kernelFunc:AS},ES={kernelName:l.ComplexAbs,backendName:"cpu",kernelFunc:n=>{const{x:t}=n.inputs,e=n.backend,s=new Float32Array(l.util.sizeFromShape(t.shape)),r=e.data.get(t.dataId),i=r.complexTensorInfos.imag,o=e.data.get(r.complexTensorInfos.real.dataId).values,u=e.data.get(i.dataId).values;for(let c=0;c<o.length;c++)s[c]=Math.hypot(o[c],u[c]);return e.makeOutput(s,t.shape,"float32")}};function Xc(n,t,e,s){const r=l.util.getArrayFromDType(e,l.util.sizeFromShape(t));if(s&&"string"!==e){let a=0;n.forEach(i=>{const o=l.util.sizeFromShape(i.shape);r.set(i.vals,a),a+=o})}else{let a=0;n.forEach(i=>{const o="string"===e?l.backend_util.fromUint8ToStringArray(i.vals):i.vals;let u=0;for(let c=0;c<i.shape[0];++c){const d=c*t[1]+a;for(let p=0;p<i.shape[1];++p)r[d+p]=o[u++]}a+=i.shape[1]})}return r}function Xn(n){const{inputs:t,backend:e}=n,{input:s}=t,r=e.data.get(s.dataId).complexTensorInfos.imag,a=e.data.get(r.dataId).values;return e.makeTensorInfo(r.shape,r.dtype,a)}const _S={kernelName:l.Imag,backendName:"cpu",kernelFunc:Xn};function Kn(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,a=l.util.parseAxisParam(r,t[0].shape)[0],i=t.map(y=>y.shape);l.backend_util.assertParamsConsistent(i,a);let o=l.backend_util.computeOutShape(t.map(y=>y.shape),a);if(0===l.util.sizeFromShape(o))return e.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter(y=>l.util.sizeFromShape(y.shape)>0);if(1===u.length)return Lt({inputs:{x:u[0]},backend:e});if("complex64"===u[0].dtype){const y=u.map(v=>Rn({inputs:{input:v},backend:e})),g=u.map(v=>Xn({inputs:{input:v},backend:e})),x=Kn({inputs:y,backend:e,attrs:{axis:a}}),b=Kn({inputs:g,backend:e,attrs:{axis:a}}),S=rt({inputs:{real:x,imag:b},backend:e});return y.forEach(v=>e.disposeIntermediateTensorInfo(v)),g.forEach(v=>e.disposeIntermediateTensorInfo(v)),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),S}const c=u.map(y=>{const x=[-1,l.util.sizeFromShape(y.shape.slice(a))];return Se({inputs:{x:y},backend:e,attrs:{shape:x}})}),d=c.map(y=>({vals:e.data.get(y.dataId).values,shape:y.shape}));o=l.backend_util.computeOutShape(c.map(y=>y.shape),1);const h=Xc(d,o,t[0].dtype,1===c[0].shape[0]),f=l.backend_util.computeOutShape(u.map(y=>y.shape),a),m=e.makeTensorInfo(f,t[0].dtype,h);return c.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}const FS={kernelName:l.Concat,backendName:"cpu",kernelFunc:Kn};function Kc(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:c,dimRoundingMode:d}=s;ee([r,a],"conv2d");const p=l.backend_util.convertConv2DDataFormat(u),h=l.backend_util.computeConv2DInfo(r.shape,a.shape,i,c,o,d,!1,p),f=h.filterHeight,m=h.filterWidth,y=h.dilationHeight,g=h.dilationWidth,x=h.padInfo.left,b=h.padInfo.top,S="channelsLast"===h.dataFormat,v=new l.TensorBuffer(h.outShape,r.dtype),I=l.util.computeStrides(r.shape),w=l.util.computeStrides(a.shape),N=I[0],T=S?I[1]:I[2],D=S?I[2]:1,A=S?1:I[1],$=v.strides[0],F=S?v.strides[1]:v.strides[2],O=S?v.strides[2]:1,L=S?1:v.strides[1],z=e.data.get(r.dataId).values,P=e.data.get(a.dataId).values,B=v.values;for(let _=0;_<h.batchSize;++_){const V=_*N,G=_*$;for(let U=0;U<h.outHeight;++U){const j=G+U*F,H=U*h.strideHeight-b;for(let Z=0;Z<f;++Z){const X=H+Z*y;if(X<0||X>=h.inHeight)continue;const Q=Z*w[0],ne=V+X*T;for(let ae=0;ae<h.outWidth;++ae){const re=j+ae*O,le=ae*h.strideWidth-x;for(let ce=0;ce<m;++ce){const ge=le+ce*g;if(ge<0||ge>=h.inWidth)continue;const Ee=ne+ge*D;let we=Q+ce*w[1];for(let be=0;be<h.inChannels;++be){const $e=z[Ee+be*A];for(let Ae=0;Ae<h.outChannels;++Ae)B[re+Ae*L]+=$e*P[we+Ae];we+=h.outChannels}}}}}}return e.makeTensorInfo(v.shape,v.dtype,B)}const OS={kernelName:l.Conv2D,backendName:"cpu",kernelFunc:Kc},LS={kernelName:l.Conv2DBackpropFilter,backendName:"cpu",kernelFunc:function zS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:d}=s;ee([r,a],"conv2dBackpropFilter");const p=l.backend_util.convertConv2DDataFormat(u),h=l.backend_util.computeConv2DInfo(r.shape,d,i,1,o,c,!1,p),{strideHeight:f,strideWidth:m,filterHeight:y,filterWidth:g}=h,x="channelsLast"===h.dataFormat,b=new l.TensorBuffer(h.filterShape,"float32"),S=h.padInfo.left,v=h.padInfo.top,I=e.data.get(r.dataId).values,w=e.data.get(a.dataId).values,N=new l.TensorBuffer(r.shape,r.dtype,I),T=new l.TensorBuffer(a.shape,a.dtype,w);for(let D=0;D<y;++D){const A=Math.max(0,Math.ceil((v-D)/f)),$=Math.min(h.outHeight,(h.inHeight+v-D)/f);for(let F=0;F<g;++F){const O=Math.max(0,Math.ceil((S-F)/m)),L=Math.min(h.outWidth,(h.inWidth+S-F)/m);for(let z=0;z<h.inChannels;++z)for(let P=0;P<h.outChannels;++P){let B=0;for(let _=0;_<h.batchSize;++_)for(let V=A;V<$;++V){const G=D+V*f-v;for(let U=O;U<L;++U){const j=F+U*m-S;B+=x?N.get(_,G,j,z)*T.get(_,V,U,P):N.get(_,z,G,j)*T.get(_,P,V,U)}}b.set(B,D,F,z,P)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},VS={kernelName:l.Conv2DBackpropInput,backendName:"cpu",kernelFunc:function PS(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:c,dimRoundingMode:d}=s;ee([r,a],"conv2dBackpropInput");const p=l.util.computeStrides(a.shape),h=l.util.computeStrides(r.shape);let f=l.backend_util.convertConv2DDataFormat(c);const m=l.backend_util.computeConv2DInfo(i,a.shape,o,1,u,d,!1,f),y=new l.TensorBuffer(m.inShape,"float32"),g=y.values,x=e.data.get(r.dataId).values,b=e.data.get(a.dataId).values,[S,v,I]=p,{batchSize:w,filterHeight:N,filterWidth:T,inChannels:D,inHeight:A,inWidth:$,outChannels:F,outHeight:O,outWidth:L,strideHeight:z,strideWidth:P}=m;f=m.dataFormat;const B=N-1-m.padInfo.top,_=T-1-m.padInfo.left,V="channelsLast"===f,G=y.strides[0],U=V?y.strides[1]:y.strides[2],j=V?y.strides[2]:1,H=V?1:y.strides[1],Z=h[0],X=V?h[1]:h[2],Q=V?h[2]:1,ne=V?1:h[1];for(let ae=0;ae<w;++ae)for(let re=0;re<D;++re)for(let le=0;le<A;++le){const ce=le-B,ge=Math.max(0,Math.ceil(ce/z)),Ie=Math.min(O,(N+ce)/z);for(let Ee=0;Ee<$;++Ee){const we=Ee-_,be=Math.max(0,Math.ceil(we/P)),$e=Math.min(L,(T+we)/P);let Ae=0;for(let Xe=ge;Xe<Ie;++Xe){const hn=Xe*z-ce;for(let dt=be;dt<$e;++dt){const Rt=Z*ae+X*Xe+Q*dt,Xt=S*(N-1-hn)+v*(T-1-(dt*P-we))+I*re;for(let fn=0;fn<F;++fn)Ae+=x[Rt+ne*fn]*b[Xt+fn]}}g[G*ae+U*le+j*Ee+H*re]=Ae}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}},MS={kernelName:l.Conv3D,backendName:"cpu",kernelFunc:function BS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u}=s;ee([r,a],"conv3d");const c=l.backend_util.computeConv3DInfo(r.shape,a.shape,i,u,o),{filterDepth:d,filterHeight:p,filterWidth:h,dilationDepth:f,dilationHeight:m,dilationWidth:y,padInfo:g}=c,x=g.front,b=g.left,S=g.top,v=new l.TensorBuffer(c.outShape,r.dtype),I=e.data.get(r.dataId).values,w=e.data.get(a.dataId).values,N=v.values,T=l.util.computeStrides(r.shape),D=l.util.computeStrides(a.shape);for(let A=0;A<c.batchSize;++A){const $=A*T[0],F=A*v.strides[0];for(let O=0;O<c.outDepth;++O){const L=F+O*v.strides[1],z=O*c.strideDepth-x;for(let P=0;P<d;++P){const B=z+P*f;if(B<0||B>=c.inDepth)continue;const _=P*D[0],V=$+B*T[1];for(let G=0;G<c.outHeight;++G){const U=L+G*v.strides[2],j=G*c.strideHeight-S;for(let H=0;H<p;++H){const Z=j+H*m;if(Z<0||Z>=c.inHeight)continue;const X=_+H*D[1],Q=V+Z*T[2];for(let ne=0;ne<c.outWidth;++ne){const ae=U+ne*c.outChannels,re=ne*c.strideWidth-b;for(let le=0;le<h;++le){const ce=re+le*y;if(ce<0||ce>=c.inWidth)continue;const Ie=Q+ce*c.inChannels;let Ee=X+le*D[2];for(let we=0;we<c.inChannels;++we){const be=I[Ie+we];for(let $e=0;$e<c.outChannels;++$e)N[ae+$e]+=be*w[Ee+$e];Ee+=c.outChannels}}}}}}}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}},GS={kernelName:l.Conv3DBackpropFilterV2,backendName:"cpu",kernelFunc:function WS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:i,pad:o,filterShape:u}=s;ee([r,a],"conv3dBackpropFilterV2");const c=l.util.computeStrides(r.shape),d=l.util.computeStrides(a.shape),p=l.backend_util.computeConv3DInfo(r.shape,u,i,1,o),h=p.strideDepth,f=p.strideHeight,m=p.strideWidth,y=p.filterDepth,g=p.filterHeight,x=p.filterWidth,b=new l.TensorBuffer(p.filterShape,"float32"),S=b.values,[v,I,w,N]=b.strides,T=e.data.get(a.dataId).values,[D,A,$,F]=d,O=e.data.get(r.dataId).values,[L,z,P,B]=c,_=p.padInfo.front,V=p.padInfo.left,G=p.padInfo.top;for(let U=0;U<y;++U){const j=Math.max(0,Math.ceil((_-U)/h)),H=Math.min(p.outDepth,(p.inDepth+_-U)/h),Z=U*v;for(let X=0;X<g;++X){const Q=Math.max(0,Math.ceil((G-X)/f)),ne=Math.min(p.outHeight,(p.inHeight+G-X)/f),ae=X*I+Z;for(let re=0;re<x;++re){const le=Math.max(0,Math.ceil((V-re)/m)),ce=Math.min(p.outWidth,(p.inWidth+V-re)/m),ge=re*w+ae;for(let Ie=0;Ie<p.inChannels;++Ie){const Ee=Ie*N+ge;for(let we=0;we<p.outChannels;++we){let be=0;for(let $e=0;$e<p.batchSize;++$e){const Ae=$e*L,jt=$e*D;for(let Xe=j;Xe<H;++Xe){const dt=(U+Xe*h-_)*z+Ae,zn=Xe*A+jt;for(let Rt=Q;Rt<ne;++Rt){const fn=(X+Rt*f-G)*P+dt,mn=Rt*$+zn;for(let gn=le;gn<ce;++gn)be+=O[(re+gn*m-V)*B+fn+Ie]*T[gn*F+mn+we]}}}S[Ee+we]=be}}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}},HS={kernelName:l.Conv3DBackpropInputV2,backendName:"cpu",kernelFunc:function US(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{pad:i,strides:o,inputShape:u}=s;ee([r],"conv3dBackpropInputV2");const c=l.util.computeStrides(r.shape),d=l.util.computeStrides(a.shape),p=l.backend_util.computeConv3DInfo(u,a.shape,o,1,i),h=new l.TensorBuffer(p.inShape,"float32"),f=h.values,[m,y,g,x]=h.strides,b=e.data.get(r.dataId).values,[S,v,I,w]=c,N=e.data.get(a.dataId).values,[T,D,A,$]=d,{batchSize:F,filterDepth:O,filterHeight:L,filterWidth:z,inChannels:P,inDepth:B,inHeight:_,inWidth:V,outChannels:G,outDepth:U,outHeight:j,outWidth:H,strideDepth:Z,strideHeight:X,strideWidth:Q}=p,ne=O-1-p.padInfo.front,ae=L-1-p.padInfo.top,re=z-1-p.padInfo.left;for(let le=0;le<F;++le)for(let ce=0;ce<P;++ce)for(let ge=0;ge<B;++ge){const Ie=ge-ne,Ee=Math.max(0,Math.ceil(Ie/Z)),we=Math.min(U,(O+Ie)/Z);for(let be=0;be<_;++be){const $e=be-ae,Ae=Math.max(0,Math.ceil($e/X)),jt=Math.min(j,(L+$e)/X);for(let Xe=0;Xe<V;++Xe){const hn=Xe-re,dt=Math.max(0,Math.ceil(hn/Q)),zn=Math.min(H,(z+hn)/Q);let Rt=0;for(let Xt=Ee;Xt<we;++Xt){const fn=Xt*Z-Ie;for(let mn=Ae;mn<jt;++mn){const gn=mn*X-$e;for(let Os=dt;Os<zn;++Os){const lo=S*le+v*Xt+I*mn+w*Os,Wz=T*(O-1-fn)+D*(L-1-gn)+A*(z-1-(Os*Q-hn))+$*ce;for(let Xr=0;Xr<G;++Xr)Rt+=b[lo+Xr]*N[Wz+Xr]}}}f[m*le+y*ge+g*be+x*Xe+ce]=Rt}}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}},jS=me(l.Cos,n=>Math.cos(n)),XS={kernelName:l.Cos,backendName:"cpu",kernelFunc:jS},KS=me(l.Cosh,n=>Math.cosh(n)),qS={kernelName:l.Cosh,backendName:"cpu",kernelFunc:KS},YS={kernelName:l.CropAndResize,backendName:"cpu",kernelFunc:function ZS(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:c}=s,[d,p,h,f]=r.shape,m=a.shape[0],[y,g]=o,x=(0,l.buffer)([m,y,g,f],"float32"),b=e.data.get(a.dataId).values,S=e.data.get(i.dataId).values,v=e.data.get(r.dataId).values,I=l.util.computeStrides(r.shape),w=l.util.computeStrides(x.shape);for(let N=0;N<m;N++){const T=4*N,D=b[T],A=b[T+1],$=b[T+2],F=b[T+3],O=S[N];if(O>=d)continue;const L=y>1?($-D)*(p-1)/(y-1):0,z=g>1?(F-A)*(h-1)/(g-1):0;for(let P=0;P<y;P++){const B=y>1?D*(p-1)+P*L:.5*(D+$)*(p-1);if(B<0||B>p-1)for(let _=0;_<g;_++)for(let V=0;V<f;V++)x.values[V+_*w[2]+P*w[1]+N*w[0]]=c;else if("bilinear"===u){const _=Math.floor(B),V=Math.ceil(B),G=B-_;for(let U=0;U<g;U++){const j=g>1?A*(h-1)+U*z:.5*(A+F)*(h-1);if(j<0||j>h-1){for(let Q=0;Q<f;Q++)x.values[Q+U*w[2]+P*w[1]+N*w[0]]=c;continue}const H=Math.floor(j),Z=Math.ceil(j),X=j-H;for(let Q=0;Q<f;Q++){let ne=Q+H*I[2]+_*I[1]+O*I[0];const ae=v[ne];ne=Q+Z*I[2]+_*I[1]+O*I[0];const re=v[ne];ne=Q+H*I[2]+V*I[1]+O*I[0];const le=v[ne];ne=Q+Z*I[2]+V*I[1]+O*I[0];const ce=v[ne],ge=ae+(re-ae)*X;ne=Q+U*w[2]+P*w[1]+N*w[0],x.values[ne]=ge+(le+(ce-le)*X-ge)*G}}}else for(let _=0;_<g;++_){const V=g>1?A*(h-1)+_*z:.5*(A+F)*(h-1);if(V<0||V>h-1){for(let j=0;j<f;j++)x.values[j+_*w[2]+P*w[1]+N*w[0]]=c;continue}const G=Math.round(V),U=Math.round(B);for(let j=0;j<f;j++)x.values[j+_*w[2]+P*w[1]+N*w[0]]=v[j+G*I[2]+U*I[1]+O*I[0]]}}}return e.makeTensorInfo(x.shape,x.dtype,x.values)}},JS={kernelName:l.Cumprod,backendName:"cpu",kernelFunc:function QS(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:i,reverse:o}=s;ee(r,"cumprod");const u=l.backend_util.getAxesPermutation([a],r.shape.length);let c=r;null!=u&&(c=nt({inputs:{x:r},backend:e,attrs:{perm:u}}));const d=l.backend_util.getInnerMostAxes(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=(0,l.upcastType)(c.dtype,"int32"),h=l.util.makeOnesTypedArray(l.util.sizeFromShape(c.shape),p),f=e.data.get(c.dataId).values,m=c.shape[c.shape.length-1],y=o?(x,b)=>x+m-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=m)for(let b=0;b<m;b++){const S=y(x,b);if(0===b)h[S]=i?1:f[S];else{const v=y(x,b-1);h[S]=i?f[v]*h[v]:f[S]*h[v]}}const g=e.makeTensorInfo(c.shape,p,h);if(null!=u){const b=nt({inputs:{x:g},backend:e,attrs:{perm:l.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},tI={kernelName:l.Cumsum,backendName:"cpu",kernelFunc:function eI(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:i,reverse:o}=s;ee(r,"cumsum");const u=l.backend_util.getAxesPermutation([a],r.shape.length);let c=r;null!=u&&(c=nt({inputs:{x:r},backend:e,attrs:{perm:u}}));const d=l.backend_util.getInnerMostAxes(1,r.shape.length)[0];if(d!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${d}`);const p=(0,l.upcastType)(c.dtype,"int32"),h=l.util.makeZerosTypedArray(l.util.sizeFromShape(c.shape),p),f=e.data.get(c.dataId).values,m=c.shape[c.shape.length-1],y=o?(x,b)=>x+m-b-1:(x,b)=>x+b;for(let x=0;x<f.length;x+=m)for(let b=0;b<m;b++){const S=y(x,b);if(0===b)h[S]=i?0:f[S];else{const v=y(x,b-1);h[S]=i?f[v]+h[v]:f[S]+h[v]}}const g=e.makeTensorInfo(c.shape,p,h);if(null!=u){const b=nt({inputs:{x:g},backend:e,attrs:{perm:l.backend_util.getUndoAxesPermutation(u)}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(c),b}return g}},sI={kernelName:l.DenseBincount,backendName:"cpu",kernelFunc:function nI(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:i,binaryOutput:o}=s;if(1===r.shape.length){const d=Oi(e.data.get(r.dataId).values,e.data.get(a.dataId).values,a.dtype,a.shape,i);return e.makeTensorInfo([i],a.dtype,d)}if(2===r.shape.length){const d=Hc(e.bufferSync(r),e.bufferSync(a),i,o);return e.makeTensorInfo(d.shape,a.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}},aI={kernelName:l.DepthToSpace,backendName:"cpu",kernelFunc:function rI(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:a,dataFormat:i}=s;l.util.assert("NHWC"===i,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=r.shape[0],u=r.shape[1],c=r.shape[2],d=r.shape[3],p=u*a,h=c*a,f=d/(a*a),m=e.data.get(r.dataId).values,y=new Float32Array(o*p*h*f);let g=0;for(let x=0;x<o;++x)for(let b=0;b<p;++b){const S=Math.floor(b/a),v=b%a;for(let I=0;I<h;++I){const w=Math.floor(I/a),T=(v*a+I%a)*f;for(let D=0;D<f;++D)y[g++]=m[D+T+d*(w+c*(S+u*x))]}}return e.makeTensorInfo([o,p,h,f],r.dtype,y)}};function qc(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:c}=s;ee([r,a],"depthwiseConv2DNative");const d=l.util.computeStrides(r.shape),p=l.util.computeStrides(a.shape);let h=u;null==h&&(h=[1,1]),l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const f=l.backend_util.computeConv2DInfo(r.shape,a.shape,i,h,o,c,!0),{filterHeight:m,filterWidth:y,dilationHeight:g,dilationWidth:x,padInfo:b}=f,S=b.left,v=b.top,I=f.outChannels/f.inChannels,w=new l.TensorBuffer(f.outShape,r.dtype),N=e.data.get(r.dataId).values,T=e.data.get(a.dataId).values,D=w.values;for(let A=0;A<f.batchSize;++A){const $=A*d[0],F=A*w.strides[0];for(let O=0;O<f.outHeight;++O){const L=F+O*w.strides[1],z=O*f.strideHeight-v;for(let P=0;P<m;++P){const B=z+P*g;if(B<0||B>=f.inHeight)continue;const _=P*p[0],V=$+B*d[1];for(let G=0;G<f.outWidth;++G){const U=L+G*w.strides[2],j=G*f.strideWidth-S;for(let H=0;H<y;++H){const Z=j+H*x;if(Z<0||Z>=f.inWidth)continue;const Q=V+Z*f.inChannels;let ne=U,ae=_+H*p[1];for(let re=0;re<f.inChannels;++re){const le=N[Q+re];for(let ce=0;ce<I;++ce)D[ne+ce]+=le*T[ae+ce];ne+=I,ae+=I}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const iI={kernelName:l.DepthwiseConv2dNative,backendName:"cpu",kernelFunc:qc},lI={kernelName:l.DepthwiseConv2dNativeBackpropFilter,backendName:"cpu",kernelFunc:function oI(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,filterShape:d}=s;ee([r,a],"depthwiseConv2dNativeBackpropFilter");const p=l.backend_util.computeConv2DInfo(r.shape,d,i,o,u,c,!0),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:y}=p,g=new l.TensorBuffer(p.filterShape,"float32"),x=p.padInfo.left,b=p.padInfo.top,S=p.outChannels/p.inChannels,v=e.data.get(r.dataId).values,I=new l.TensorBuffer(r.shape,r.dtype,v),w=e.data.get(a.dataId).values,N=new l.TensorBuffer(a.shape,a.dtype,w);for(let T=0;T<m;++T){const D=Math.max(0,Math.ceil((b-T)/h)),A=Math.min(p.outHeight,(p.inHeight+b-T)/h);for(let $=0;$<y;++$){const F=Math.max(0,Math.ceil((x-$)/f)),O=Math.min(p.outWidth,(p.inWidth+x-$)/f);for(let L=0;L<p.outChannels;++L){const z=Math.trunc(L/S),P=L%S;let B=0;for(let _=0;_<p.batchSize;++_)for(let V=D;V<A;++V){const G=T+V*h-b;for(let U=F;U<O;++U)B+=I.get(_,G,$+U*f-x,z)*N.get(_,V,U,L)}g.set(B,T,$,z,P)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}},cI={kernelName:l.DepthwiseConv2dNativeBackpropInput,backendName:"cpu",kernelFunc:function uI(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,inputShape:d}=s;ee([r,a],"depthwiseConv2DNativeBackpropInput");const p=l.util.computeStrides(r.shape),h=l.util.computeStrides(a.shape),f=l.backend_util.computeConv2DInfo(d,a.shape,i,o,u,c,!0),m=new l.TensorBuffer(f.inShape,"float32"),y=m.values,[g,x,b]=m.strides,S=e.data.get(r.dataId).values,[v,I,w]=p,N=e.data.get(a.dataId).values,[T,D,A]=h,{batchSize:$,filterHeight:F,filterWidth:O,inChannels:L,inHeight:z,inWidth:P,outChannels:B,outHeight:_,outWidth:V,strideHeight:G,strideWidth:U}=f,j=F-1-f.padInfo.top,H=O-1-f.padInfo.left,Z=B/L;for(let X=0;X<$;++X)for(let Q=0;Q<L;++Q)for(let ne=0;ne<z;++ne){const ae=ne-j,re=Math.max(0,Math.ceil(ae/G)),le=Math.min(_,(F+ae)/G);for(let ce=0;ce<P;++ce){const ge=ce-H,Ie=Math.max(0,Math.ceil(ge/U)),Ee=Math.min(V,(O+ge)/U);let we=0;for(let be=re;be<le;++be){const $e=be*G-ae;for(let Ae=Ie;Ae<Ee;++Ae){const Xe=v*X+I*be+w*Ae,hn=T*(F-1-$e)+D*(O-1-(Ae*U-ge))+A*Q;for(let dt=0;dt<Z;++dt)we+=S[Xe+(Q*Z+dt)]*N[hn+dt]}}y[g*X+x*ne+b*ce+Q]=we}}return e.makeTensorInfo(m.shape,m.dtype,m.values)}},pI={kernelName:l.Diag,backendName:"cpu",kernelFunc:function dI(n){const{inputs:t,backend:e}=n,{x:s}=t,r=l.util.sizeFromShape(s.shape),a=e.data.get(s.dataId).values,i=(0,l.buffer)([r,r],s.dtype),o=i.values;for(let c=0;c<a.length;c++)o[c*r+c]=a[c];const u=[...s.shape,...s.shape];return e.makeTensorInfo(u,i.dtype,i.values)}},hI={kernelName:l.Dilation2D,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r}=n,{strides:a,pad:i,dilations:o}=e,u=t,c=u.data.get(s.dataId).values,d=s.shape.length,p=u.data.get(r.dataId).values,h=r.shape.length,{batchSize:f,inHeight:m,inWidth:y,inChannels:g,outHeight:x,outWidth:b,padInfo:S,strideHeight:v,strideWidth:I,filterHeight:w,filterWidth:N,dilationHeight:T,dilationWidth:D,outShape:A}=l.backend_util.computeDilation2DInfo(s.shape,r.shape,a,i,"NHWC",o),$=l.util.sizeFromShape(A),F=A.length,O=l.util.getArrayFromDType(s.dtype,$);for(let z=0;z<f;++z)for(let P=0;P<x;++P){const B=P*v-S.top;for(let _=0;_<b;++_){const V=_*I-S.left;for(let G=0;G<g;++G){let U=Number.MIN_SAFE_INTEGER;for(let H=0;H<w;++H){const Z=B+H*T;if(Z>=0&&Z<m)for(let X=0;X<N;++X){const Q=V+X*D;if(Q>=0&&Q<y){const ne=l.util.locToIndex([z,Z,Q,G],d,l.util.computeStrides(s.shape)),ae=l.util.locToIndex([H,X,G],h,l.util.computeStrides(r.shape)),re=c[ne]+p[ae];re>U&&(U=re)}}}O[l.util.locToIndex([z,P,_,G],F,l.util.computeStrides(A))]=U}}}return{dataId:u.write(l.util.toTypedArray(O,s.dtype),A,s.dtype),shape:A,dtype:s.dtype}}},fI={kernelName:l.Dilation2DBackpropFilter,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:a}=n,{strides:i,pad:o,dilations:u}=e,c=t,d=l.util.toNestedArray(s.shape,c.data.get(s.dataId).values),p=l.util.toNestedArray(r.shape,c.data.get(r.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:x,padInfo:b,strideHeight:S,strideWidth:v,filterHeight:I,filterWidth:w,dilationHeight:N,dilationWidth:T,outShape:D}=l.backend_util.computeDilation2DInfo(s.shape,r.shape,i,o,"NHWC",u);l.util.assert(a.rank===D.length,()=>`Error in ${l.Dilation2DBackpropFilter}, dy must have the same rank as output ${D.length}, but got ${a.rank}`);const A=l.util.toNestedArray(D,c.data.get(a.dataId).values),$=l.util.makeZerosNestedTypedArray(r.shape,r.dtype);for(let O=0;O<h;++O)for(let L=0;L<g;++L){const z=L*S-b.top;for(let P=0;P<x;++P){const B=P*v-b.left;for(let _=0;_<y;++_){let V=Number.MIN_SAFE_INTEGER,G=0,U=0;for(let j=0;j<I;++j){const H=z+j*N;if(H>=0&&H<f)for(let Z=0;Z<w;++Z){const X=B+Z*T;if(X>=0&&X<m){const Q=d[O][H][X][_]+p[j][Z][_];Q>V&&(V=Q,G=j,U=Z)}}}$[G][U][_]+=A[O][L][P][_]}}}return{dataId:c.write(l.util.toTypedArray($,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},mI={kernelName:l.Dilation2DBackpropInput,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,filter:r,dy:a}=n,{strides:i,pad:o,dilations:u}=e,c=t,d=l.util.toNestedArray(s.shape,c.data.get(s.dataId).values),p=l.util.toNestedArray(r.shape,c.data.get(r.dataId).values),{batchSize:h,inHeight:f,inWidth:m,inChannels:y,outHeight:g,outWidth:x,padInfo:b,strideHeight:S,strideWidth:v,filterHeight:I,filterWidth:w,dilationHeight:N,dilationWidth:T,outShape:D}=l.backend_util.computeDilation2DInfo(s.shape,r.shape,i,o,"NHWC",u);l.util.assert(a.rank===D.length,()=>`Error in ${l.Dilation2DBackpropInput}, dy must have the same rank as output ${D.length}, but got ${a.rank}`);const A=l.util.toNestedArray(D,c.data.get(a.dataId).values),$=l.util.makeZerosNestedTypedArray(s.shape,s.dtype);for(let O=0;O<h;++O)for(let L=0;L<g;++L){const z=L*S-b.top;for(let P=0;P<x;++P){const B=P*v-b.left;for(let _=0;_<y;++_){let V=Number.MIN_SAFE_INTEGER,G=z<0?0:z,U=B<0?0:B;for(let j=0;j<I;++j){const H=z+j*N;if(H>=0&&H<f)for(let Z=0;Z<w;++Z){const X=B+Z*T;if(X>=0&&X<m){const Q=d[O][H][X][_]+p[j][Z][_];Q>V&&(V=Q,G=H,U=X)}}}$[O][G][U][_]+=A[O][L][P][_]}}}return{dataId:c.write(l.util.toTypedArray($,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},zi=Oe((n,t)=>n*t),gI=Ei((n,t,e,s)=>({real:n*e-t*s,imag:n*s+t*e})),Ir=We(l.Multiply,zi,gI),yI={kernelName:l.Multiply,backendName:"cpu",kernelFunc:Ir};function Is(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s;let o;ee(r,"sum"),o="bool"===r.dtype?on({inputs:{x:r},backend:e,attrs:{dtype:"int32"}}):Lt({inputs:{x:r},backend:e});const u=o.shape.length,c=l.util.parseAxisParam(a,o.shape),d=l.backend_util.getAxesPermutation(c,u);let p=c,h=o;null!=d&&(h=nt({inputs:{x:o},backend:e,attrs:{perm:d}}),p=l.backend_util.getInnerMostAxes(p.length,u)),l.backend_util.assertAxesAreInnerMostDims("sum",p,h.shape.length);const[f,m]=l.backend_util.computeOutAndReduceShapes(h.shape,p);let g=Sr(e,f,l.backend_util.upcastType(h.dtype,"int32"));const x=l.util.sizeFromShape(m),b=e.data.get(g.dataId).values,S=e.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const I=v*x;let w=0;for(let N=0;N<x;++N)w+=S[I+N];b[v]=w}if(i){const I=g;g=Se({inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(g.shape,c)}}),e.disposeIntermediateTensorInfo(I)}return e.disposeIntermediateTensorInfo(o),null!=d&&e.disposeIntermediateTensorInfo(h),g}const xI={kernelName:l.Sum,backendName:"cpu",kernelFunc:Is},CI={kernelName:l.Einsum,backendName:"cpu",kernelFunc:function bI(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,a=t,{allDims:i,summedDims:o,idDims:u}=l.backend_util.decodeEinsumEquation(r,a.length);l.backend_util.checkEinsumDimSizes(i.length,u,a);const{path:c,steps:d}=l.backend_util.getEinsumComputePath(o,u),p=d.length;let h=null,f=i.length;const m=[];for(let y=0;y<p;++y){for(const g of d[y]){const{permutationIndices:x,expandDims:b}=l.backend_util.getEinsumPermutation(f,u[g]);let S;l.backend_util.isIdentityPermutation(x)?S=a[g]:(S=nt({inputs:{x:a[g]},backend:e,attrs:{perm:x}}),m.push(S));const v=S.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);l.util.arraysEqual(S.shape,v)||(S=Se({inputs:{x:S},backend:e,attrs:{shape:v}}),m.push(S)),null===h?h=S:(h=Ir({inputs:{a:S,b:h},backend:e}),m.push(h))}y<p-1&&(c[y]>=0&&(h=Is({inputs:{x:h},backend:e,attrs:{axis:c[y]-(i.length-f),keepDims:!1}}),m.push(h)),f--)}for(const y of m)y!==h&&e.disposeIntermediateTensorInfo(y);return h}},SI={kernelName:l.EluGrad,backendName:"cpu",kernelFunc:function vI(n){const{inputs:t,backend:e}=n,{dy:s,y:r}=t;ee([s,r],"eluGrad");const a=new Float32Array(l.util.sizeFromShape(r.shape)),i=e.data.get(r.dataId).values,o=e.data.get(s.dataId).values;for(let u=0;u<i.length;++u){const c=i[u];a[u]=c>=0?o[u]:o[u]*(c+1)}return e.makeTensorInfo(r.shape,"float32",a)}},Zc=Oe((n,t)=>n===t?1:0),Yc=We(l.Equal,Zc,null,"bool"),II={kernelName:l.Equal,backendName:"cpu",kernelFunc:Yc},wI=l.backend_util.ERF_P,NI=l.backend_util.ERF_A1,TI=l.backend_util.ERF_A2,kI=l.backend_util.ERF_A3,RI=l.backend_util.ERF_A4,AI=l.backend_util.ERF_A5,DI=me(l.Erf,n=>{const t=Math.sign(n),e=Math.abs(n),s=1/(1+wI*e);return t*(1-((((AI*s+RI)*s+kI)*s+TI)*s+NI)*s*Math.exp(-e*e))}),$I={kernelName:l.Erf,backendName:"cpu",kernelFunc:DI},Qc=zt(n=>Math.exp(n)),Jc=an(l.Exp,Qc,"float32"),EI={kernelName:l.Exp,backendName:"cpu",kernelFunc:Jc};function wr(n){const{inputs:t,backend:e,attrs:s}=n,{input:r}=t,{dim:a}=s,i=r.shape.length,o=r.shape.slice();let u=a;return a<0&&(l.util.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+a+1),o.splice(u,0,1),Se({inputs:{x:r},backend:e,attrs:{shape:o}})}const _I={kernelName:l.ExpandDims,backendName:"cpu",kernelFunc:wr},ed=zt(n=>Math.expm1(n)),FI=an(l.Expm1,ed),OI={kernelName:l.Expm1,backendName:"cpu",kernelFunc:FI},zI=Oe((n,t)=>n/t),Li=We(l.RealDiv,zI),Pi={kernelName:l.RealDiv,backendName:"cpu",kernelFunc:Li},td=Oe((n,t)=>n-t),LI=Ei((n,t,e,s)=>({real:n-e,imag:t-s})),Vi=We(l.Sub,td,LI),PI={kernelName:l.Sub,backendName:"cpu",kernelFunc:Vi};function nd(n,t,e){const s=n.shape,r=s[0],a=s[1],i=e.data.get(n.dataId),o=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,c=[r,a],d=l.util.sizeFromShape(c),p=l.util.getTypedArrayFromDType("float32",d),h=l.util.getTypedArrayFromDType("float32",d);for(let g=0;g<r;g++){const x=An({inputs:{x:o},backend:e,attrs:{begin:[g,0],size:[1,a]}}),b=An({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,a]}}),S=rt({inputs:{real:x,imag:b},backend:e}),{real:v,imag:I}=VI(S,t,e),w=l.backend_util.mergeRealAndImagArrays(v,I);for(let N=0;N<a;N++){const T=l.backend_util.getComplexWithIndex(w,N);p[g*a+N]=T.real,h[g*a+N]=T.imag}e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(S)}const f=e.makeTensorInfo(c,"float32",p),m=e.makeTensorInfo(c,"float32",h),y=rt({inputs:{real:f,imag:m},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),y}function VI(n,t,e){const s=l.util.sizeFromShape(n.shape),r=e.data.get(n.dataId),a=e.data.get(r.complexTensorInfos.real.dataId).values,i=e.data.get(r.complexTensorInfos.imag.dataId).values;if(function BI(n){return 0==(n&n-1)}(s)){const o=Bi(a,i,s,t,e),u=[n.shape[0],n.shape[1]];if(t){const c=e.makeTensorInfo(u,"float32",o.real),d=e.makeTensorInfo(u,"float32",o.imag),p=e.makeTensorInfo([],"float32",l.util.createScalarValue(s,"float32")),h=Lt({inputs:{x:p},backend:e}),f=Pi.kernelFunc({inputs:{a:c,b:p},backend:e}),m=Pi.kernelFunc({inputs:{a:d,b:h},backend:e}),y=e.data.get(f.dataId).values,g=e.data.get(m.dataId).values;return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),{real:y,imag:g}}return o}{const u=function MI(n,t,e){const s=new Float32Array(2*t);for(let r=0;r<t;r++){let a=0,i=0;for(let o=0;o<t;o++){const u=l.backend_util.exponent(r*o,t,e),c=l.backend_util.getComplexWithIndex(n,o);a+=c.real*u.real-c.imag*u.imag,i+=c.real*u.imag+c.imag*u.real}e&&(a/=t,i/=t),l.backend_util.assignToTypedArray(s,a,i,r)}return s}(l.backend_util.mergeRealAndImagArrays(a,i),s,t);return l.backend_util.splitRealAndImagArrays(u)}}function Bi(n,t,e,s,r){if(1===e)return{real:n,imag:t};const a=l.backend_util.mergeRealAndImagArrays(n,t),i=e/2,o=l.backend_util.complexWithEvenIndex(a),u=o.real,c=o.imag,d=[u.length],p=r.makeTensorInfo(d,"float32",u),h=r.makeTensorInfo(d,"float32",c),f=rt({inputs:{real:p,imag:h},backend:r}),m=l.backend_util.complexWithOddIndex(a),y=m.real,g=m.imag,x=[y.length],b=r.makeTensorInfo(x,"float32",y),S=r.makeTensorInfo(x,"float32",g),v=rt({inputs:{real:b,imag:S},backend:r}),I=Bi(u,c,i,s,r),w=I.real,N=I.imag,T=[w.length],D=r.makeTensorInfo(T,"float32",w),A=r.makeTensorInfo(T,"float32",N),$=rt({inputs:{real:D,imag:A},backend:r}),F=Bi(y,g,i,s,r),O=F.real,L=F.imag,z=[O.length],P=r.makeTensorInfo(z,"float32",O),B=r.makeTensorInfo(z,"float32",L),_=rt({inputs:{real:P,imag:B},backend:r}),V=l.backend_util.exponents(e,s),G=[V.real.length],U=r.makeTensorInfo(G,"float32",V.real),j=r.makeTensorInfo(G,"float32",V.imag),H=rt({inputs:{real:U,imag:j},backend:r}),Z=Ir({inputs:{a:H,b:_},backend:r}),X=jn({inputs:{a:$,b:Z},backend:r}),Q=Vi({inputs:{a:$,b:Z},backend:r}),ne=Rn({inputs:{input:X},backend:r}),ae=Rn({inputs:{input:Q},backend:r}),re=Xn({inputs:{input:X},backend:r}),le=Xn({inputs:{input:Q},backend:r}),ce=Kn({inputs:[ne,ae],backend:r,attrs:{axis:0}}),ge=Kn({inputs:[re,le],backend:r,attrs:{axis:0}}),Ie=r.data.get(ce.dataId).values,Ee=r.data.get(ge.dataId).values;return r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(f),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(S),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(Z),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(Q),r.disposeIntermediateTensorInfo(ne),r.disposeIntermediateTensorInfo(re),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(ce),r.disposeIntermediateTensorInfo(ge),{real:Ie,imag:Ee}}const GI={kernelName:l.FFT,backendName:"cpu",kernelFunc:function WI(n){const{inputs:t,backend:e}=n,{input:s}=t,r=l.util.sizeFromShape(s.shape),a=s.shape[s.shape.length-1],o=Se({inputs:{x:s},backend:e,attrs:{shape:[r/a,a]}}),u=nd(o,!1,e),c=Se({inputs:{x:u},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(u),c}};function Mi(n){const{backend:t,attrs:e}=n,{shape:s,value:r,dtype:a}=e,i=a||l.util.inferDtype(r),o=l.util.getArrayFromDType(i,l.util.sizeFromShape(s));return function HI(n,t,e){n.fill(t)}(o,r),t.makeTensorInfo(s,i,o)}const UI={kernelName:l.Fill,backendName:"cpu",kernelFunc:Mi},jI={kernelName:l.FlipLeftRight,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{image:s}=n,r=e,a=l.util.getTypedArrayFromDType(s.dtype,l.util.sizeFromShape(s.shape)),[i,o,u,c]=s.shape,d=r.data.get(s.dataId).values;for(let h=0;h<i;h++){const f=h*u*o*c;for(let m=0;m<o;m++){const y=m*(u*c);for(let g=0;g<u;g++){const x=g*c;for(let b=0;b<c;b++){const S=Math.round(u-g-1),v=f+y+x+b;let I=d[v];S>=0&&S<u&&(I=d[f+y+S*c+b]),a[v]=I}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},sd=zt(n=>Math.floor(n)),XI=an(l.Floor,sd),KI={kernelName:l.Floor,backendName:"cpu",kernelFunc:XI},qI=Oe((n,t)=>Math.floor(n/t)),ZI=We(l.FloorDiv,qI,null,"int32"),YI={kernelName:l.FloorDiv,backendName:"cpu",kernelFunc:ZI},JI={kernelName:l.FusedConv2D,backendName:"cpu",kernelFunc:function QI(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=s;let y=Kc({inputs:{x:r,filter:a},backend:e,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:h}});if(i){const g=y;if("NCHW"===d&&1===i.shape.length&&1!==i.shape[0]){const x=Se({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});y=jn({inputs:{a:y,b:x},backend:e}),e.disposeIntermediateTensorInfo(x)}else y=jn({inputs:{a:y,b:i},backend:e});e.disposeIntermediateTensorInfo(g)}if(f){const g=y;if("NCHW"===d&&"prelu"===f&&1===o.shape.length&&1!==o.shape[0]){const x=Se({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});y=vr(e,y,f,x,m),e.disposeIntermediateTensorInfo(x)}else y=vr(e,y,f,o,m);e.disposeIntermediateTensorInfo(g)}return y}},tw={kernelName:l.FusedDepthwiseConv2D,backendName:"cpu",kernelFunc:function ew(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=s;let y=qc({inputs:{x:r,filter:a},backend:e,attrs:{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:h}});if(i){const g=y;y=jn({inputs:{a:y,b:i},backend:e}),e.disposeIntermediateTensorInfo(g)}if(f){const g=y;y=vr(e,y,f,o,m),e.disposeIntermediateTensorInfo(g)}return y}};function rd(n,t,e,s,r,a,i,o,u){const c=(0,l.buffer)([s,a],e);for(let d=0;d<s;d++){const p=[];let h=0;for(let f=0;f<r;f++){const m=n[d*r+f];h+=m*i[f],p.push(m)}if(h<0||h>=u/a)throw new Error(`Invalid indices: ${p} does not index into ${o}`);for(let f=0;f<a;f++)c.values[d*a+f]=t.get(...t.indexToLoc(h*a+f))}return c}const sw={kernelName:l.GatherNd,backendName:"cpu",kernelFunc:function nw(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,a=l.util.sizeFromShape(s.shape),i=r.shape,o=i[i.length-1],[u,c,d,p]=l.backend_util.prepareAndValidate(s,r);if(0===c)return e.makeTensorInfo(u,s.dtype,[]);const m=rd(e.data.get(r.dataId).values,e.bufferSync(s),s.dtype,c,o,d,p,s.shape,a);return e.makeTensorInfo(u,s.dtype,m.values)}};function ad(n,t,e){const s=(0,l.buffer)(e,n.dtype);for(let r=0;r<s.size;++r){const i=s.indexToLoc(r).slice(),c=t.locToIndex([i[0],i[2]]);i[2]=t.values[c];const d=n.locToIndex(i);0<=d&&d<n.values.length&&(s.values[r]=n.values[d])}return s}const aw={kernelName:l.GatherV2,backendName:"cpu",kernelFunc:function rw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:a}=t,{axis:i,batchDims:o}=s;ee([r,a],"gatherV2");const u=l.util.parseAxisParam(i,r.shape)[0],c=e.data.get(a.dataId).values,d=r.shape[u];for(let v=0;v<c.length;++v){const I=c[v];l.util.assert(I<=d-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${d-1}]`)}let p=o;null==o&&(p=0);const h=l.util.sizeFromShape(a.shape),f=l.backend_util.segment_util.collectGatherOpShapeInfo(r,a,u,p),m=Se({inputs:{x:r},backend:e,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),y=Se({inputs:{x:a},backend:e,attrs:{shape:[f.batchSize,h/f.batchSize]}}),g=[f.batchSize,f.outerSize,h/f.batchSize,f.sliceSize],x=e.bufferSync(y),S=ad(e.bufferSync(m),x,g);return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.makeTensorInfo(f.outputShape,S.dtype,S.values)}},id=Oe((n,t)=>n>t?1:0),iw=We(l.Greater,id,null,"bool"),ow={kernelName:l.Greater,backendName:"cpu",kernelFunc:iw},od=Oe((n,t)=>n>=t?1:0),lw=We(l.GreaterEqual,od,null,"bool"),uw={kernelName:l.GreaterEqual,backendName:"cpu",kernelFunc:lw},dw={kernelName:l.IFFT,backendName:"cpu",kernelFunc:function cw(n){const{inputs:t,backend:e}=n,{input:s}=t,r=l.util.sizeFromShape(s.shape),a=s.shape[s.shape.length-1],o=Se({inputs:{x:s},backend:e,attrs:{shape:[r/a,a]}}),u=nd(o,!0,e),c=Se({inputs:{x:u},backend:e,attrs:{shape:s.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(u),c}},pw=me(l.IsFinite,n=>Number.isFinite(n)?1:0,"bool"),hw={kernelName:l.IsFinite,backendName:"cpu",kernelFunc:pw},fw=me(l.IsInf,n=>Math.abs(n)===1/0?1:0,"bool"),mw={kernelName:l.IsInf,backendName:"cpu",kernelFunc:fw},gw=me(l.IsNan,n=>Number.isNaN(n)?1:0,"bool"),yw={kernelName:l.IsNan,backendName:"cpu",kernelFunc:gw},ld=Oe((n,t)=>n<t?1:0),xw=We(l.Less,ld,null,"bool"),bw={kernelName:l.Less,backendName:"cpu",kernelFunc:xw},ud=Oe((n,t)=>n<=t?1:0),Cw=We(l.LessEqual,ud,null,"bool"),vw={kernelName:l.LessEqual,backendName:"cpu",kernelFunc:Cw};function cd(n,t,e){const s=(t-n)/(e-1),r=l.util.makeZerosTypedArray(e,"float32");r[0]=n;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}const Iw={kernelName:l.LinSpace,backendName:"cpu",kernelFunc:function Sw(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:a}=e,i=cd(s,r,a);return t.makeTensorInfo([i.length],"float32",i)}},dd=zt(n=>Math.log(n)),ww=an(l.Log,dd),Nw={kernelName:l.Log,backendName:"cpu",kernelFunc:ww},Tw=me(l.Log1p,n=>Math.log1p(n)),kw={kernelName:l.Log1p,backendName:"cpu",kernelFunc:Tw},Rw=Oe((n,t)=>n&&t),Aw=We(l.LogicalAnd,Rw,null,"bool"),Dw={kernelName:l.LogicalAnd,backendName:"cpu",kernelFunc:Aw},$w=me(l.LogicalNot,n=>n?0:1,"bool"),Ew={kernelName:l.LogicalNot,backendName:"cpu",kernelFunc:$w},_w=Oe((n,t)=>n||t),Fw=We(l.LogicalOr,_w,null,"bool"),Ow={kernelName:l.LogicalOr,backendName:"cpu",kernelFunc:Fw},Lw={kernelName:l.LRN,backendName:"cpu",kernelFunc:function zw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=s;ee(r,"LRN");const c=r.shape[3],d=c-1,p=e.data.get(r.dataId).values,h=l.util.sizeFromShape(r.shape),f=new Float32Array(h);function m(y){const g=y%c;let x=y-g+Math.max(0,g-a);const b=y-g+Math.min(g+a,d);let S=0;for(;x<=b;x++){const v=p[x];S+=v*v}return S}for(let y=0;y<h;y++){const g=m(y),x=p[y]*Math.pow(i+o*g,-u);f[y]=x}return e.makeTensorInfo(r.shape,r.dtype,f)}},Vw={kernelName:l.LRNGrad,backendName:"cpu",kernelFunc:function Pw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:d}=s;ee(i,"LRNGrad");const p=l.util.sizeFromShape(i.shape),h=i.shape[3],f=e.data.get(i.dataId).values,m=e.data.get(r.dataId).values,y=e.data.get(a.dataId).values,g=new Float32Array(p),x=p;for(let b=0;b<x;b++){const S=b%h,v=b-S+Math.max(0,S-o),I=b-S+Math.min(h,S+o+1);let w=0;for(let N=v;N<I;N++)w+=Math.pow(m[N],2);w=c*w+u;for(let N=v;N<I;N++){let T=-2*c*d*m[N]*y[b]/w;b===N&&(T+=Math.pow(w,-d)),T*=f[b],g[N]+=T}}return e.makeTensorInfo(i.shape,r.dtype,g)}};function pd(n,t,e,s){const r=l.util.getTypedArrayFromDType(s,l.util.sizeFromShape(e));for(let a=0;a<r.length;++a){const i=a*t;let o=n[i];for(let u=0;u<t;++u){const c=n[i+u];(Number.isNaN(c)||c>o)&&(o=c)}r[a]=o}return r}function hd(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:a,keepDims:i}=s,o=e;let u=r.shape;const c=u.length,d=l.util.parseAxisParam(a,u);let p=d;const h=l.backend_util.getAxesPermutation(p,c);let f=o.data.get(r.dataId).values;if(null!=h){const v=new Array(c);for(let I=0;I<v.length;I++)v[I]=u[h[I]];f=_i(f,u,r.dtype,h,v),p=l.backend_util.getInnerMostAxes(p.length,c),u=v}ee(r,"max"),l.backend_util.assertAxesAreInnerMostDims("max",p,c);const[m,y]=l.backend_util.computeOutAndReduceShapes(u,p),x=pd(f,l.util.sizeFromShape(y),m,r.dtype),b=o.write(x,m,r.dtype);let S=m;return i&&(S=l.backend_util.expandShapeToKeepDim(m,d)),{dataId:b,shape:S,dtype:r.dtype}}const Bw={kernelName:l.Max,backendName:"cpu",kernelFunc:hd},fd=Oe((n,t)=>Math.max(n,t)),Mw=We(l.Maximum,fd),Ww={kernelName:l.Maximum,backendName:"cpu",kernelFunc:Mw},Uw={kernelName:l.MaxPool,backendName:"cpu",kernelFunc:function Gw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;ee(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const d=l.backend_util.computePool2DInfo(r.shape,a,i,1,o,u);let p;if(1===d.filterWidth&&1===d.filterHeight&&l.util.arraysEqual(d.inShape,d.outShape))p=Lt({inputs:{x:r},backend:e});else{const h=e.data.get(r.dataId).values,f=l.util.computeStrides(r.shape),m=Fi(h,0,r.dtype,f,d,"max");p=e.makeTensorInfo(d.outShape,r.dtype,m.values)}return p}},jw={kernelName:l.MaxPool3D,backendName:"cpu",kernelFunc:function Hw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=s;ee(r,"maxPool3d");const d=l.backend_util.computePool3DInfo(r.shape,a,i,1,o,u,c),h=Gc(e.data.get(r.dataId).values,0,r.dtype,l.util.computeStrides(r.shape),d,"max");return e.makeTensorInfo(h.shape,"float32",h.values)}},Kw={kernelName:l.MaxPool3DGrad,backendName:"cpu",kernelFunc:function Xw(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,{filterSize:i,strides:o,pad:u,dimRoundingMode:c}=s;ee([r,a],"maxPool3DGrad");const d=l.backend_util.computePool3DInfo(a.shape,i,o,1,u,c),h=function iS(n,t){const e=(0,l.buffer)(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,u=t.dilationWidth,c=t.effectiveFilterDepth,d=t.effectiveFilterHeight,p=t.effectiveFilterWidth,h=t.padInfo.front,f=t.padInfo.top,m=t.padInfo.left;for(let y=0;y<t.batchSize;++y)for(let g=0;g<t.inChannels;++g)for(let x=0;x<t.outDepth;++x){const b=x*s-h;let S=b;for(;S<0;)S+=i;const v=Math.min(t.inDepth,c+b);for(let I=0;I<t.outHeight;++I){const w=I*r-f;let N=w;for(;N<0;)N+=o;const T=Math.min(t.inHeight,d+w);for(let D=0;D<t.outWidth;++D){const A=D*a-m;let $=A;for(;$<0;)$+=u;const F=Math.min(t.inWidth,p+A);let O=Number.NEGATIVE_INFINITY,L=-1;for(let z=S;z<v;z+=i){const P=z-b;for(let B=N;B<T;B+=o){const _=B-w;for(let V=$;V<F;V+=u){const G=V-A,U=n.get(y,z,B,V,g);U>=O&&(O=U,L=P*d*p+_*d+G)}}}e.set(L,y,x,I,D,g)}}}return e}(e.bufferSync(a),d),f=d.strideDepth,m=d.strideHeight,y=d.strideWidth,g=d.dilationDepth,x=d.dilationHeight,b=d.dilationWidth,S=d.effectiveFilterDepth,v=d.effectiveFilterHeight,I=d.effectiveFilterWidth,w=S-1-d.padInfo.front,N=I-1-d.padInfo.left,T=v-1-d.padInfo.top,D=(0,l.buffer)(a.shape,"float32"),A=e.bufferSync(r);for(let $=0;$<d.batchSize;++$)for(let F=0;F<d.inChannels;++F)for(let O=0;O<d.inDepth;++O)for(let L=0;L<d.inHeight;++L)for(let z=0;z<d.inWidth;++z){const P=O-w,B=L-T,_=z-N;let V=0;for(let G=0;G<S;G+=g){const U=(P+G)/f;if(!(U<0||U>=d.outDepth||Math.floor(U)!==U))for(let j=0;j<v;j+=x){const H=(B+j)/m;if(!(H<0||H>=d.outHeight||Math.floor(H)!==H))for(let Z=0;Z<I;Z+=b){const X=(_+Z)/y;if(X<0||X>=d.outWidth||Math.floor(X)!==X)continue;const ae=S*v*I-1-h.get($,U,H,X,F)===G*v*I+j*I+Z?1:0;0!==ae&&(V+=A.get($,U,H,X,F)*ae)}}}D.set(V,$,O,L,z,F)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}},Zw={kernelName:l.MaxPoolGrad,backendName:"cpu",kernelFunc:function qw(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a,output:i}=t,o=a;ee([a,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=s,h=l.backend_util.computePool2DInfo(o.shape,u,c,1,d,p),f=e.data.get(o.dataId).values,m=(0,l.buffer)(h.outShape,o.dtype,Wc(f,o.shape,o.dtype,h).values),y=h.strideHeight,g=h.strideWidth,x=h.dilationHeight,b=h.dilationWidth,S=h.effectiveFilterHeight,v=h.effectiveFilterWidth,I=v-1-h.padInfo.left,w=S-1-h.padInfo.top,N=(0,l.buffer)(o.shape,"float32"),T=e.data.get(r.dataId).values,D=(0,l.buffer)(r.shape,"float32",T);for(let A=0;A<h.batchSize;++A)for(let $=0;$<h.inChannels;++$)for(let F=0;F<h.inHeight;++F)for(let O=0;O<h.inWidth;++O){const L=F-w,z=O-I;let P=0;for(let B=0;B<S;B+=x){const _=(L+B)/y;if(!(_<0||_>=h.outHeight||Math.floor(_)!==_))for(let V=0;V<v;V+=b){const G=(z+V)/g;if(G<0||G>=h.outWidth||Math.floor(G)!==G)continue;const H=S*v-1-m.get(A,_,G,$)===B*v+V?1:0;0!==H&&(P+=D.get(A,_,G,$)*H)}}N.set(P,A,F,O,$)}return e.makeTensorInfo(N.shape,N.dtype,N.values)}},Qw={kernelName:l.MaxPoolWithArgmax,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=t,u=e;ee(s,"MaxPoolWithArgmax");const c=u.data.get(s.dataId).values,d=l.backend_util.computePool2DInfo(s.shape,r,a,[1,1],i),[p,h]=function Yw(n,t,e,s,r){const i=Fi(n,0,e,l.util.computeStrides(t),r,"max"),o=Wc(n,t,e,r,!0,s);return[i.values,o.values]}(c,s.shape,s.dtype,o,d),f=u.write(p,d.outShape,s.dtype),m=u.write(h,d.outShape,s.dtype);return[{dataId:f,shape:d.outShape,dtype:s.dtype},{dataId:m,shape:d.outShape,dtype:"int32"}]}},eN={kernelName:l.Mean,backendName:"cpu",kernelFunc:function Jw(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s,o=l.util.parseAxisParam(a,r.shape),c=l.backend_util.computeOutAndReduceShapes(r.shape,o)[1],d=l.util.sizeFromShape(c),p=[],h=e.makeTensorInfo([],"float32",new Float32Array([d]));p.push(h);const f=on({inputs:{x:r},backend:e,attrs:{dtype:"float32"}});p.push(f);const m=Li({inputs:{a:f,b:h},backend:e});p.push(m);const y=Is({inputs:{x:m},backend:e,attrs:{axis:a,keepDims:i}});return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),y}},nN={kernelName:l.Min,backendName:"cpu",kernelFunc:function tN(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s;ee(r,"min");const o=l.util.parseAxisParam(a,r.shape);let u=o;const c=l.backend_util.getAxesPermutation(u,r.shape.length);let d=r;null!=c&&(d=nt({inputs:{x:r},backend:e,attrs:{perm:c}}),u=l.backend_util.getInnerMostAxes(u.length,r.shape.length)),l.backend_util.assertAxesAreInnerMostDims("min",u,d.shape.length);const[p,h]=l.backend_util.computeOutAndReduceShapes(d.shape,u),f=l.util.sizeFromShape(h),m=l.util.makeZerosTypedArray(l.util.sizeFromShape(p),d.dtype),y=e.data.get(d.dataId).values;for(let x=0;x<m.length;++x){const b=x*f;let S=y[b];for(let v=0;v<f;++v){const I=y[b+v];(Number.isNaN(I)||I<S)&&(S=I)}m[x]=S}null!=c&&e.disposeIntermediateTensorInfo(d);const g=e.makeTensorInfo(p,d.dtype,m);if(i){const b=Se({inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(p,o)}});return e.disposeIntermediateTensorInfo(g),b}return g}},md=Oe((n,t)=>Math.min(n,t)),sN=We(l.Minimum,md),rN={kernelName:l.Minimum,backendName:"cpu",kernelFunc:sN},iN={kernelName:l.MirrorPad,backendName:"cpu",kernelFunc:function aN(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:a,mode:i}=s;ee(r,"mirrorPad");const o=a.map((S,v)=>S[0]+r.shape[v]+S[1]),u=a.map(S=>S[0]),c=a.map((S,v)=>S[0]+r.shape[v]),d="reflect"===i?0:1,p=e.data.get(r.dataId).values,h=r.shape.length,f=l.util.computeStrides(r.shape),m=l.util.sizeFromShape(o),y=o.length,g=l.util.computeStrides(o),x=l.util.getTypedArrayFromDType(r.dtype,m);for(let S=0;S<m;S++){let v=l.util.indexToLoc(S,y,g);for(let w=0;w<y;w++)v[w]<u[w]?v[w]=2*u[w]-v[w]-d:v[w]>=c[w]&&(v[w]=2*(c[w]-1)-v[w]+d);v=v.map((w,N)=>w-u[N]);const I=l.util.locToIndex(v,h,f);x[S]=p[I]}return{dataId:e.write(x,o,r.dtype),shape:o,dtype:r.dtype}}},oN=Oe((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t}),lN=We(l.Mod,oN),uN={kernelName:l.Mod,backendName:"cpu",kernelFunc:lN};function gd(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:a}=s,i=r.shape.length;let o=a;if(-1===o&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const u=l.util.parseAxisParam([o],r.shape),c=hd({inputs:{x:r},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),d=l.backend_util.expandShapeToKeepDim(c.shape,u),p=Se({inputs:{x:c},backend:e,attrs:{shape:d}}),h=Vi({inputs:{a:r,b:p},backend:e}),f=Jc({inputs:{x:h},backend:e}),m=Is({inputs:{x:f},backend:e,attrs:{axis:u,keepDims:!1}}),y=Se({inputs:{x:m},backend:e,attrs:{shape:d}}),g=Li({inputs:{a:f,b:y},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),g}const cN={kernelName:l.Softmax,backendName:"cpu",kernelFunc:gd},pN={kernelName:l.Multinomial,backendName:"cpu",kernelFunc:function dN(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:a,seed:i,normalized:o}=s;ee(r,"multinomial");const u=o?r:gd({inputs:{logits:r},backend:e,attrs:{dim:-1}}),c=u.shape[0],d=u.shape[1],p=e.data.get(u.dataId).values,h=[c,a],f=l.util.makeZerosTypedArray(l.util.sizeFromShape(h),"int32");for(let m=0;m<c;++m){const y=m*d,g=new Float32Array(d-1);g[0]=p[y];for(let S=1;S<g.length;++S)g[S]=g[S-1]+p[y+S];const x=PC.alea(i.toString()),b=m*a;for(let S=0;S<a;++S){const v=x();f[b+S]=g.length;for(let I=0;I<g.length;I++)if(v<g[I]){f[b+S]=I;break}}}return o||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(h,"int32",f)}};function yd(n,t,e){const s=l.util.createScalarValue(-1,e);return zi([],t,s,n,e)}const fN={kernelName:l.Neg,backendName:"cpu",kernelFunc:function hN(n){const{inputs:t,backend:e}=n,{x:s}=t;ee(s,"neg");const r=e.data.get(s.dataId).values,[a,i]=yd(r,s.shape,s.dtype);return e.makeTensorInfo(i,s.dtype,a)}},mN=l.kernel_impls.nonMaxSuppressionV3Impl,yN={kernelName:l.NonMaxSuppressionV3,backendName:"cpu",kernelFunc:function gN(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=s;ee(r,"NonMaxSuppression");const c=e.data.get(r.dataId).values,d=e.data.get(a.dataId).values,{selectedIndices:p}=mN(c,d,i,o,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}},xN=l.kernel_impls.nonMaxSuppressionV4Impl,CN={kernelName:l.NonMaxSuppressionV4,backendName:"cpu",kernelFunc:function bN(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=s;ee(r,"NonMaxSuppressionPadded");const d=e.data.get(r.dataId).values,p=e.data.get(a.dataId).values,{selectedIndices:h,validOutputs:f}=xN(d,p,i,o,u,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},vN=l.kernel_impls.nonMaxSuppressionV5Impl,IN={kernelName:l.NonMaxSuppressionV5,backendName:"cpu",kernelFunc:function SN(n){const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=s;ee(r,"NonMaxSuppressionWithScore");const d=e.data.get(r.dataId).values,p=e.data.get(a.dataId).values,h=i,f=o,m=u,y=c,{selectedIndices:g,selectedScores:x}=vN(d,p,h,f,m,y);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([x.length],"float32",new Float32Array(x))]}},xd=Oe((n,t)=>n!==t?1:0),wN=We(l.NotEqual,xd,null,"bool"),NN={kernelName:l.NotEqual,backendName:"cpu",kernelFunc:wN},kN={kernelName:l.OneHot,backendName:"cpu",kernelFunc:function TN(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:a,depth:i,onValue:o,offValue:u}=s;ee(r,"oneHot");const c=l.util.sizeFromShape(r.shape),d=new Float32Array(c*i);d.fill(u);const p=e.data.get(r.dataId).values;for(let h=0;h<c;++h)p[h]>=0&&p[h]<i&&(d[h*i+p[h]]=o);return e.makeTensorInfo([...r.shape,i],a,d)}};function Nr(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const r=Rn({inputs:{input:s},backend:e}),a=Nr({inputs:{x:r},backend:e}),i=Xn({inputs:{input:s},backend:e}),o=Nr({inputs:{x:i},backend:e}),u=rt({inputs:{real:a,imag:o},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),u}return Mi({backend:e,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const RN={kernelName:l.ZerosLike,backendName:"cpu",kernelFunc:Nr},AN={kernelName:l.OnesLike,backendName:"cpu",kernelFunc:function bd(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===s.dtype){const r=Rn({inputs:{input:s},backend:e}),a=bd({inputs:{x:r},backend:e}),i=Xn({inputs:{input:s},backend:e}),o=Nr({inputs:{x:i},backend:e}),u=rt({inputs:{real:a,imag:o},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),u}return Mi({backend:e,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}};function Cd(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(1===t.length)return wr({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const a=t[0].shape,i=t[0].dtype;t.forEach(d=>{l.util.assertShapesMatch(a,d.shape,"All tensors passed to stack must have matching shapes"),l.util.assert(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=Kn({inputs:t.map(d=>{const p=wr({inputs:{input:d},backend:e,attrs:{dim:r}});return o.push(p),p}),backend:e,attrs:{axis:r}});return o.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}const DN={kernelName:l.Pack,backendName:"cpu",kernelFunc:Cd},vd={kernelName:l.PadV2,backendName:"cpu",kernelFunc:function $N(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:a,constantValue:i}=s;ee(r,"pad");const o=a.map((b,S)=>b[0]+r.shape[S]+b[1]),u=a.map(b=>b[0]),c=e.data.get(r.dataId).values,d=l.util.sizeFromShape(r.shape),p=r.shape.length,h=l.util.computeStrides(r.shape),f=l.util.sizeFromShape(o),m=o.length,y=l.util.computeStrides(o),g=l.util.getTypedArrayFromDType(r.dtype,f);0!==i&&g.fill(i);for(let b=0;b<d;b++){const v=l.util.indexToLoc(b,p,h).map((w,N)=>w+u[N]);g[l.util.locToIndex(v,m,y)]=c[b]}return{dataId:e.write(g,o,r.dtype),shape:o,dtype:r.dtype}}},EN=Oe((n,t)=>Math.pow(n,t)),_N=We(l.Pow,EN),FN={kernelName:l.Pow,backendName:"cpu",kernelFunc:_N};function Sd(n,t,e,s){const[r,a]=l.backend_util.computeOutAndReduceShapes(n,s),i=(0,l.upcastType)(t,"int32"),o=l.util.makeZerosTypedArray(l.util.sizeFromShape(r),i),u=l.util.sizeFromShape(a);for(let c=0;c<o.length;++c){const d=c*u;let p=1;for(let h=0;h<u;++h)p*=e[d+h];o[c]=p}return{outVals:o,outShape:r,outDtype:i}}const zN={kernelName:l.Prod,backendName:"cpu",kernelFunc:function ON(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s;ee(r,"prod");const o=r.shape.length,u=l.util.parseAxisParam(a,r.shape),c=l.backend_util.getAxesPermutation(u,o);let d=u,p=r;const h=[];null!=c&&(p=nt({inputs:{x:r},backend:e,attrs:{perm:c}}),h.push(p),d=l.backend_util.getInnerMostAxes(d.length,o));const f=e.data.get(p.dataId).values,{outVals:m,outShape:y,outDtype:g}=Sd(p.shape,p.dtype,f,d);let x=y;return i&&(x=l.backend_util.expandShapeToKeepDim(y,u)),h.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(x,g,m)}};function Id(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let s=t;s<n.length;s++)e[t-1]*=n[s];return e}function wd(n,t,e,s,r,a,i,o){if(0===n.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function LN(n,t,e){n.forEach((s,r)=>{if(s<0||s>=e){const a=l.util.indexToLoc(r,t.length,l.util.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${s} is not in [0, ${e})`)}})}(a,i,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:d,valueSlices:p,numValues:h}=function VN(n,t,e,s){const r=[];let a=0;const o=new Array(t.length-1+e.length).fill(null).map(()=>[0]);!function PN(n,t){for(let e=0;e<n.length;++e){const s=n[e],r=e===n.length-1?t:n[e+1].length;if(0===s.length)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let a=1;a<s.length;++a)if(s[a-1]>s[a])throw new Error("Ragged splits must be sorted in ascending order")}}(e,s);let u=1;for(let c=0;c<t.length-1;++c){u*=t[c];const d=t[c+1];for(let p=1;p<u+1;++p)o[c].push(p*d)}for(let c=0;c<n.length;++c){let d=n[c],p=n[c]+1;for(let h=0;h<e.length;++h){const f=e[h],m=h+t.length-1;if(m>=0){const y=o[m],g=y[y.length-1]-f[d];for(let x=d;x<p;++x)o[m].push(f[x+1]+g)}d=f[d],p=f[p]}p!==d&&(r.push([d,p]),a+=p-d)}return{outSplits:o,valueSlices:r,numValues:a}}(a,i,n,c),f=function BN(n){const t=[];for(let e=0;e<n.length;++e){const r=l.util.getArrayFromDType("int32",n[e].length);t.push(r),n[e].forEach((a,i)=>r[i]=a)}return t}(d),m=function WN(n,t,e,s,r){const a=t.slice();a[0]=r;const i=l.util.getArrayFromDType(e,l.util.sizeFromShape(a)),o=n.length;return function MN(n,t,e,s,r,a){const i=Id(t,2)[1],o=Id(a,2)[1];let u=0;for(const c of e)for(let d=c[0];d<c[1];++d){for(let p=0;p<s;++p)r[u*o+p]=n[d*i+p];++u}}(n,t,s,0===o?0:o/t[0],i,a),[i,a]}(e,s,r,p,h);return[f,m[0],m[1]]}const UN={kernelName:l.RaggedGather,backendName:"cpu",kernelFunc:function GN(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=t,u=r.map(x=>e.data.get(x.dataId).values),c=r.map(x=>x.shape),d=e.data.get(a.dataId).values,p=e.data.get(i.dataId).values,[h,f,m]=wd(u,c,d,a.shape,a.dtype,p,i.shape),y=h.map(x=>e.makeTensorInfo([x.length],"int32",x)),g=e.makeTensorInfo(m,a.dtype,f);return y.concat([g])}},Nd=2147483647;function Td(n,t,e,s,r,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,u=0===r.length,c=0===i.length,d=[];o||d.push(t[0]),u||d.push(r[0]),c||d.push(i[0]);for(let g=1;g<d.length;++g)if(d[g]!==d[g-1])throw new Error("starts, limits, and deltas must have the same shape");const p=0===d.length?1:d[0],h=l.util.getArrayFromDType("int32",p+1);h[0]=0;for(let g=0;g<p;++g){const x=o?n[0]:n[g],b=u?s[0]:s[g],S=c?a[0]:a[g];if(0===S)throw new Error("Requires delta != 0");let v;if(S>0&&b<x||S<0&&b>x)v=0;else if(v=Math.ceil(Math.abs((b-x)/S)),v>Nd)throw new Error(`Requires ((limit - start) / delta) <= ${Nd}`);h[g+1]=h[g]+v}const m=l.util.getArrayFromDType(e,h[p]);let y=0;for(let g=0;g<p;++g){const x=h[g+1]-h[g];let b=o?n[0]:n[g];const S=c?a[0]:a[g];for(let v=0;v<x;++v)m[y++]=b,b+=S}return[h,m]}const jN={kernelName:l.RaggedRange,backendName:"cpu",kernelFunc:function HN(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:a}=t,i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,[c,d]=Td(i,s.shape,s.dtype,o,r.shape,u,a.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],s.dtype,d)]}};var yt=l.backend_util.RowPartitionType;class Tr{constructor(t,e,s,r,a,i,o,u,c,d){this.shape=t,this.shapeShape=e,this.values=s,this.valuesShape=r,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=u,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=l.backend_util.getRowPartitionTypesHelper(d),this.raggedRank=l.backend_util.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===yt.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===yt.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case yt.VALUE_ROWIDS:return Tr.getMaxWidthValueRowID(e);case yt.ROW_SPLITS:return Tr.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${yt[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(0===e||1===e)return 0;let s=0;for(let r=0;r<e-1;++r){const a=t[r+1]-t[r];a>s&&(s=a)}return s}static getMaxWidthValueRowID(t){const e=t.length;if(0===e)return 0;let s=0,r=t[0],a=0;for(let i=1;i<e;++i){const o=t[i];o!==r&&(r=o,a=Math.max(i-s,a),s=i)}return Math.max(e-s,a)}tensorShapeFromTensor(t,e,s=!0){if(0===e.length){if(-1===t[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return Rd(t,s)}calculateOutputSize(t){const e=this.valuesShape;l.backend_util.validateDefaultValueShape(this.defaultValueShape,e);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=l.backend_util.combineRaggedTensorToTensorShapes(this.raggedRank,r,e);i[0]<0&&(i[0]=t);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(t,e,s){const r=Math.min(t,s),a=[];let i=0;for(let o=0;o<r;++o,i+=e)a.push(i);for(let o=r;o<t;++o)a.push(-1);return l.util.assert(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,e,s,r){const a=t.length,i=[];for(let o=0;o<a-1;++o){const u=t[o+1]-t[o];let c=Math.min(r,u),d=e[o];-1===d&&(c=0);for(let p=0;p<c;++p)i.push(d),d+=s;for(let p=0;p<u-c;++p)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,e,s,r){const a=t.length,i=[];if(0===a)return[];let o=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let c=e[u];i.push(c);for(let d=1;d<a;++d){const p=t[d];if(p===u)c>=0&&(++o,o<r?c+=s:c=-1);else{if(o=0,u=p,p>=e.length)throw new Error(`Got nextValueRowId=${p} which is not less than ${e.length}`);c=e[p]}i.push(c)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,e,s,r){const a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case yt.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,e,s,r);case yt.ROW_SPLITS:if(a.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(a,e,s,r);default:throw new Error(`Unsupported partition type: ${yt[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case yt.FIRST_DIM_SIZE:return t[0];case yt.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case yt.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${yt[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),s=this.calculateOutputSize(e),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let u=r.length-2;u>=0;--u)r[u]=r[u+1]*s[u+1];const a=Rd(s,!1),i=l.util.getArrayFromDType(this.valuesDType,l.util.sizeFromShape(a));if(r[0]*s[0]>0){let u=this.calculateFirstParentOutputIndex(e,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c)u=this.calculateOutputIndex(c-1,u,r[c],s[c]);this.setOutput(this.raggedRank,u,i,a)}return[a,i]}setOutput(t,e,s,r){if(0===s.length)return;const a=this.values,i=s;let o=r.slice();o=o.slice(t+1);const u=l.util.sizeFromShape(o),c=e.length;let d=this.defaultValue;if(d.length!==u&&1!==d.length){const m=this.defaultValueShape;(0,l.tidy)(()=>{const y=(0,l.reshape)(d,m);d=(0,l.broadcastTo)(y,o).dataSync()})}let p=0,h=0,f=0;for(let m=0;m<=c;++m){let y=m<c?e[m]:-1;if(y!==f){if(h<f){const g=a.subarray(p*u);kd(i.subarray(h*u),g,(f-h)*u)}if(m>=c&&(y=Math.floor(s.length/u)),y>f)if(1===this.defaultValue.length)i.subarray(f*u,y*u).fill(this.defaultValue[0]),f=y;else for(;y>f;)kd(i.slice(f*u),d,u),++f;y<0?(p=m+1,h=f):(p=m,h=f,f=h+1)}else++f}}}function kd(n,t,e){for(let s=0;s<e;s++)n[s]=t[s]}function Rd(n,t){const e=[];for(let s of n){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}e.push(s)}return e}function Ad(n,t,e,s,r,a,i,o,u,c){return new Tr(n,t,e,s,r,a,i,o,u,c).compute()}const KN={kernelName:l.RaggedTensorToTensor,backendName:"cpu",kernelFunc:function XN(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=s,c=e.data.get(r.dataId).values,d=e.data.get(a.dataId).values,p=e.data.get(i.dataId).values,h=o.map(g=>e.data.get(g.dataId).values),f=o.map(g=>g.shape),[m,y]=Ad(c,r.shape,d,a.shape,a.dtype,p,i.shape,h,f,u);return e.makeTensorInfo(m,a.dtype,y)}};function Dd(n,t,e,s){if(n===t||n<t&&e<0||t<n&&e>1)return l.util.makeZerosTypedArray(0,s);const o=Math.abs(Math.ceil((t-n)/e)),u=l.util.makeZerosTypedArray(o,s);t<n&&1===e&&(e=-1),u[0]=n;for(let c=1;c<u.length;c++)u[c]=u[c-1]+e;return u}const ZN={kernelName:l.Range,backendName:"cpu",kernelFunc:function qN(n){const{backend:t,attrs:e}=n,{start:s,stop:r,dtype:a,step:i}=e,o=Dd(s,r,i,a);return t.makeTensorInfo([o.length],a,o)}},YN=me(l.Reciprocal,n=>1/n),QN={kernelName:l.Reciprocal,backendName:"cpu",kernelFunc:YN},eT={kernelName:l.ResizeBilinear,backendName:"cpu",kernelFunc:function JN(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s;ee(r,"resizeBilinear");const u=l.util.computeStrides(r.shape),[c,d]=o,[p,h,f,m]=r.shape,y=e.data.get(r.dataId).values,g=new Float32Array(l.util.sizeFromShape([p,c,d,m])),x=[a&&c>1?h-1:h,a&&d>1?f-1:f],b=[a&&c>1?c-1:c,a&&d>1?d-1:d];let S=0;const v=x[0]/b[0],I=x[1]/b[1];for(let w=0;w<p;w++)for(let N=0;N<c;N++){let T;T=i?v*(N+.5)-.5:v*N;const D=Math.max(0,Math.floor(T)),A=T-D,$=Math.min(h-1,Math.ceil(T)),F=w*u[0]+D*u[1],O=w*u[0]+$*u[1];for(let L=0;L<d;L++){let z;z=i?I*(L+.5)-.5:I*L;const P=Math.max(0,Math.floor(z)),B=z-P,_=Math.min(f-1,Math.ceil(z)),V=F+P*u[2],G=O+P*u[2],U=F+_*u[2],j=O+_*u[2];for(let H=0;H<m;H++){const Z=y[V+H],X=y[G+H],ae=Z+(y[U+H]-Z)*B;g[S++]=ae+(X+(y[j+H]-X)*B-ae)*A}}}return e.makeTensorInfo([p,c,d,m],"float32",g)}},nT={kernelName:l.ResizeBilinearGrad,backendName:"cpu",kernelFunc:function tT(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:i}=s;ee([a,r],"resizeBilinearGrad");const o=l.util.computeStrides(r.shape),[u,c,d,p]=r.shape,[,h,f]=a.shape,m=new Float32Array(u*c*d*p),y=[i&&h>1?c-1:c,i&&f>1?d-1:d],g=[i&&h>1?h-1:h,i&&f>1?f-1:f],x=y[0]/g[0],b=y[1]/g[1],S=e.data.get(a.dataId).values;let v=0;for(let I=0;I<u;I++){const w=I*o[0];for(let N=0;N<h;N++){const T=N*x,D=Math.floor(T),A=Math.min(Math.ceil(T),c-1),$=w+D*o[1],F=w+A*o[1],O=T-D,L=1-O;for(let z=0;z<f;z++){const P=z*b,B=Math.floor(P),_=Math.min(Math.ceil(P),d-1),V=P-B,G=1-V,U=$+B*o[2],j=$+_*o[2],H=F+B*o[2],Z=F+_*o[2],X=L*G,Q=L*V,ne=O*G,ae=O*V;for(let re=0;re<p;re++){const le=S[v++];m[U+re]+=le*X,m[j+re]+=le*Q,m[H+re]+=le*ne,m[Z+re]+=le*ae}}}}return e.makeTensorInfo([u,d,c,p],"float32",m)}},rT={kernelName:l.ResizeNearestNeighbor,backendName:"cpu",kernelFunc:function sT(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s;ee(r,"resizeNearestNeighbor");const u=l.util.computeStrides(r.shape),[c,d]=o,[p,h,f,m]=r.shape,y=e.data.get(r.dataId).values,g=new Float32Array(p*c*d*m),x=[a&&c>1?h-1:h,a&&d>1?f-1:f],b=[a&&c>1?c-1:c,a&&d>1?d-1:d],S=x[0]/b[0],v=x[1]/b[1];let I=0;for(let w=0;w<p;w++){const N=w*u[0];for(let T=0;T<c;T++){const D=i?S*(T+.5):S*T;let A=Math.min(h-1,a?Math.round(D):Math.floor(D));i&&(A=Math.max(0,A));const $=N+A*u[1];for(let F=0;F<d;F++){const O=i?v*(F+.5):v*F;let L=Math.min(f-1,a?Math.round(O):Math.floor(O));i&&(L=Math.max(0,L));const z=$+L*u[2];for(let P=0;P<m;P++)g[I++]=y[z+P]}}}return e.makeTensorInfo([p,c,d,m],r.dtype,g)}},iT={kernelName:l.ResizeNearestNeighborGrad,backendName:"cpu",kernelFunc:function aT(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:i}=s;ee([a,r],"resizeNearestNeighborGrad");const o=l.util.computeStrides(r.shape),u=l.util.computeStrides(a.shape),[c,d,p,h]=r.shape,[,f,m]=a.shape,y=new Float32Array(c*d*p*h),g=e.data.get(a.dataId).values,x=[i&&f>1?d-1:d,i&&m>1?p-1:p],b=[i&&f>1?f-1:f,i&&m>1?m-1:m],S=x[0]/b[0],v=x[1]/b[1],I=1/S,w=1/v,N=2*Math.ceil(I)+2,T=2*Math.ceil(w)+2;for(let D=0;D<c;D++){const A=D*o[0];for(let $=0;$<d;$++){const F=A+$*o[1],O=Math.floor($*I),L=Math.floor(O-N/2);for(let z=0;z<p;z++){const P=F+z*o[2],B=Math.floor(z*w),_=Math.floor(B-T/2);for(let V=0;V<h;V++){let G=0;for(let U=0;U<N;U++){const j=U+L;if(j<0||j>=f)continue;const H=A+j*u[1],Z=j*S;if($===Math.min(d-1,i?Math.round(Z):Math.floor(Z)))for(let Q=0;Q<T;Q++){const ne=Q+_;if(ne<0||ne>=m)continue;const ae=H+ne*u[2],re=ne*v;z===Math.min(p-1,i?Math.round(re):Math.floor(re))&&(G+=g[ae+V])}}y[P+V]=G}}}}return e.makeTensorInfo(r.shape,r.dtype,y)}},lT={kernelName:l.Reverse,backendName:"cpu",kernelFunc:function oT(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:a}=s;ee(r,"reverse");const i=r.shape.length,o=l.util.parseAxisParam(a,r.shape);if(0===i)return Lt({inputs:{x:r},backend:e});const u=new l.TensorBuffer(r.shape,r.dtype),c=e.bufferSync(r);for(let d=0;d<u.size;d++){const p=u.indexToLoc(d),h=p.slice();o.forEach(f=>h[f]=r.shape[f]-1-h[f]),u.set(c.get(...h),...p)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}},uT={kernelName:l.RotateWithOffset,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:a,center:i}=t,o=e,u=l.util.getTypedArrayFromDType(s.dtype,l.util.sizeFromShape(s.shape)),[c,d,p,h]=s.shape,[f,m]=l.backend_util.getImageCenter(i,d,p),g=Math.sin(r),x=Math.cos(r),b=o.data.get(s.dataId).values;for(let v=0;v<c;v++){const I=v*p*d*h;for(let w=0;w<d;w++){const N=w*(p*h);for(let T=0;T<p;T++){const D=T*h;for(let A=0;A<h;A++){const $=[c,w,T,A],F=$[2],O=$[1];let L=(F-f)*x-(O-m)*g,z=(F-f)*g+(O-m)*x;L=Math.round(L+f),z=Math.round(z+m);let P=a;"number"!=typeof a&&(P=3===A?255:a[A]),L>=0&&L<p&&z>=0&&z<d&&(P=b[I+z*(p*h)+L*h+A]),u[I+N+D+A]=P}}}}return{dataId:o.write(u,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},cT=me(l.Round,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2==0?t:t+1}),dT={kernelName:l.Round,backendName:"cpu",kernelFunc:cT},$d=zt(n=>1/Math.sqrt(n)),pT=an(l.Rsqrt,$d),hT={kernelName:l.Rsqrt,backendName:"cpu",kernelFunc:pT};function Dn(n,t,e,s,r,a,i,o,u,c){const d=[s/r,r],p=n.values,h=t.values;if(0===s)return(0,l.buffer)(e,t.dtype);const f=u instanceof l.TensorBuffer?u:(0,l.buffer)(d,t.dtype);"string"==typeof u||"number"==typeof u?f.values.fill(u):"boolean"==typeof u&&f.values.fill(+u);for(let m=0;m<a;m++){const y=[];let g=0;for(let x=0;x<i;x++){const b=p[m*i+x];y.push(b),g+=b*o[x]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${y} does not index into ${e}`);for(let x=0;x<r;x++)c?f.values[g*r+x]+=h[m*r+x]:f.values[g*r+x]=0===t.rank?h[0]:h[m*r+x]}return f}const mT={kernelName:l.ScatterNd,backendName:"cpu",kernelFunc:function fT(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:a}=t,{shape:i}=s,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=l.backend_util.calculateShapes(a,r,i),y=Dn(e.bufferSync(r),e.bufferSync(a),i,p,c,u,o,d,0,!0);return e.makeTensorInfo(i,y.dtype,y.values)}};function gT(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<t?e=r+1:s=r;return s}function yT(n,t){let e=0,s=n.length,r=0;for(;e<s;)r=Math.floor((e+s)/2),n[r]<=t?e=r+1:s=r;return s}const CT={kernelName:l.SearchSorted,backendName:"cpu",kernelFunc:function bT(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:a}=t,{side:i}=s,c=function xT(n,t,e,s,r,a){const i=l.util.getArrayFromDType("int32",e*r);for(let o=0;o<e;++o){const u=n.slice(o*s,(o+1)*s),c=o*r;for(let d=0;d<r;++d)i[c+d]="left"===a?gT(u,t[d+c]):yT(u,t[d+c])}return i}(e.data.get(r.dataId).values,e.data.get(a.dataId).values,r.shape[0],r.shape[1],a.shape[1],i);return e.makeTensorInfo(a.shape,"int32",c)}},ST={kernelName:l.Select,backendName:"cpu",kernelFunc:function vT(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:a}=t;ee([s,r,a],"select");const i=s.shape.length,o=e.data.get(s.dataId).values,u=e.data.get(r.dataId).values,c=e.data.get(a.dataId).values,d=(0,l.upcastType)(r.dtype,a.dtype),p=l.util.makeZerosTypedArray(l.util.sizeFromShape(r.shape),d);let h=0;const f=0===i||i>1||1===r.shape.length?1:l.util.sizeFromShape(r.shape.slice(1));for(let m=0;m<o.length;m++)for(let y=0;y<f;y++)p[h++]=1===o[m]?u[m]:c[m];return e.makeTensorInfo(r.shape,d,p)}},IT=l.backend_util.SELU_SCALEALPHA,wT=l.backend_util.SELU_SCALE,NT=me(l.Selu,n=>n>=0?wT*n:IT*(Math.exp(n)-1)),TT={kernelName:l.Selu,backendName:"cpu",kernelFunc:NT},kT=me(l.Sign,n=>n<0?-1:n>0?1:0),RT={kernelName:l.Sign,backendName:"cpu",kernelFunc:kT},AT=me(l.Sin,n=>Math.sin(n)),DT={kernelName:l.Sin,backendName:"cpu",kernelFunc:AT},$T=me(l.Sinh,n=>Math.sinh(n)),ET={kernelName:l.Sinh,backendName:"cpu",kernelFunc:$T},Ed=Math.log(1.1920928955078125e-7)+2,_T=me(l.Softplus,n=>{const t=n>-Ed,e=n<Ed,s=Math.exp(n);let r;return r=e?s:t?n:Math.log(1+s),r}),FT={kernelName:l.Softplus,backendName:"cpu",kernelFunc:_T},zT={kernelName:l.SpaceToBatchND,backendName:"cpu",kernelFunc:function OT(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,paddings:i}=s;ee([r],"spaceToBatchND");const o=l.util.sizeFromShape(a),u=[[0,0]];u.push(...i);for(let w=1+a.length;w<r.shape.length;++w)u.push([0,0]);const c=vd.kernelFunc({inputs:{x:r},backend:e,attrs:{paddings:u,constantValue:0}}),d=l.backend_util.getReshaped(c.shape,a,o,!1),p=l.backend_util.getPermuted(d.length,a.length,!1),h=l.backend_util.getReshapedPermuted(c.shape,a,o,!1),y=Se({inputs:{x:c},backend:e,attrs:{shape:d}}),b=nt({inputs:{x:y},backend:e,attrs:{perm:p}}),I=Se({inputs:{x:b},backend:e,attrs:{shape:h}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),I}};function _d(n,t,e,s,r,a,i){const o=t[0],u=a[0],c=new Array(u),d=new Array(o),p=t[1];if(0===u){if(0!==o)throw new Error(l.backend_util.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));return[l.util.getArrayFromDType(e,0),[0,p],l.util.getArrayFromDType(r,0),c,d]}let h=!0,f=0;const m=new Array(u).fill(0);for(let g=0;g<o;++g){const x=n[g*p];if(x<0)throw new Error(l.backend_util.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=u)throw new Error(l.backend_util.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,u));++m[x],h=h&&x>=f,f=x}let y=!0;for(let g=0;g<u;++g){const x=0===m[g];c[g]=x,y=y&&!x,m[g]=Math.max(m[g],1),g>0&&(m[g]+=m[g-1])}if(y&&h){const g=n,x=s;for(let b=0;b<o;++b)d[b]=b;return[g,[o,p],x,c,d]}{const g=m[u-1],x=l.util.getArrayFromDType(e,g*p),b=l.util.getArrayFromDType(r,g),S=new Array(u).fill(0);for(let v=0;v<o;++v){const I=n[v*p],N=(0===I?0:m[I-1])+S[I];S[I]++;for(let T=0;T<p;++T)x[N*p+T]=n[v*p+T];b[N]=s[v],d[v]=N}for(let v=0;v<u;++v)if(0===S[v]){const w=0===v?0:m[v-1];x[w*p+0]=v;for(let N=1;N<p;++N)x[w*p+N]=0;b[w]=i}return[x,[g,p],b,c,d]}}const PT={kernelName:l.SparseFillEmptyRows,backendName:"cpu",kernelFunc:function LT(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=e.data.get(s.dataId).values,u=e.data.get(r.dataId).values,c=e.data.get(a.dataId).values,d=e.data.get(i.dataId).values[0],[p,h,f,m,y]=_d(o,s.shape,s.dtype,u,r.dtype,c,d);return[e.makeTensorInfo(h,s.dtype,p),e.makeTensorInfo([h[0]],r.dtype,f),e.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),e.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}};function Fd(n,t,e,s,r){const a=l.util.sizeFromShape(s),i=t[0],o=r.length,u=[];let c=1,d=-1;for(let g=0;g<o;++g){const x=r[g];if(-1===x){if(-1!==d)throw new Error(l.backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(d,g));d=g,u.push(1)}else{if(x<0)throw new Error(l.backend_util.getSparseReshapeNegativeOutputDimErrorMessage(g,x));c*=x,u.push(x)}}if(-1!==d){if(c<=0)throw new Error(l.backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const g=Math.trunc(a/c);if(c*g!==a)throw new Error(l.backend_util.getSparseReshapeInputOutputMultipleErrorMessage(s,u));u[d]=g}if(l.util.sizeFromShape(u)!==a)throw new Error(l.backend_util.getSparseReshapeInputOutputMismatchErrorMessage(s,u));const h=s.length,f=[];if(h>0){f[h-1]=1;for(let g=h-2;g>=0;--g)f[g]=f[g+1]*s[g+1]}const m=[];if(o>0){m[o-1]=1;for(let g=o-2;g>=0;--g)m[g]=m[g+1]*u[g+1]}const y=l.util.getArrayFromDType(e,i*o);for(let g=0;g<i;++g){let x=0;for(let b=0;b<h;++b)x+=n[g*h+b]*f[b];for(let b=0;b<o;++b)y[g*o+b]=Math.trunc(x/m[b]),x%=m[b]}return[y,[i,o],u]}const BT={kernelName:l.SparseReshape,backendName:"cpu",kernelFunc:function VT(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(e.data.get(r.dataId).values),o=e.data.get(s.dataId).values,u=Array.from(e.data.get(a.dataId).values),[c,d,p]=Fd(o,s.shape,s.dtype,i,u);return[e.makeTensorInfo(d,s.dtype,c),e.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}};function Wi(n,t,e,s,r,a=!1,i=0){const o=s.length,u=[t[0],n.length/t[0]],c=u[1],p=o>0?r[o-1]+1:0;if(p<0)throw new Error(l.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const h=t.slice();h[0]=p;const f=h.reduce((S,v)=>S*v,1),m=l.util.getArrayFromDType(e,f);if(0===o)return p>0&&m.fill(i),[m,h];if(p<=0)throw new Error(l.backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let y=0,g=1,x=0,b=r[y];for(;;){let S=0;if(g<o){if(S=r[g],b===S){++g;continue}if(b>=S)throw new Error(l.backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(b<0||b>=p)throw new Error(l.backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b,p));b>x&&m.fill(i,x*c,b*c);for(let v=y;v<g;++v){const I=s[v];if(I<0||I>=u[0])throw new Error(l.backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(v,s[v],u[0]));for(let w=0;w<c;w++)m[b*c+w]+=n[I*c+w]}if(a)for(let v=0;v<c;v++)m[b*c+v]/=g-y;if(y=g,++g,x=b+1,b=S,g>o)break}return x<p&&m.fill(i,x*c,p*c),[m,h]}const WT={kernelName:l.SparseSegmentMean,backendName:"cpu",kernelFunc:function MT(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,[c,d]=Wi(i,s.shape,s.dtype,o,u,!0);return e.makeTensorInfo(d,s.dtype,c)}},UT={kernelName:l.SparseSegmentSum,backendName:"cpu",kernelFunc:function GT(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${a.shape}`);if(r.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=e.data.get(s.dataId).values,o=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,[c,d]=Wi(i,s.shape,s.dtype,o,u);return e.makeTensorInfo(d,s.dtype,c)}},jT={kernelName:l.SparseToDense,backendName:"cpu",kernelFunc:function HT(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:i}=t,{outputShape:o}=s,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:h}=l.backend_util.calculateShapes(a,r,o),f=!1,m=e.bufferSync(r);let y;switch(a.dtype){case"bool":y=Dn(m,e.bufferSync(a),o,h,d,c,u,p,!!e.data.get(i.dataId).values[0],f);break;case"float32":case"int32":y=Dn(m,e.bufferSync(a),o,h,d,c,u,p,e.data.get(i.dataId).values[0],f);break;case"string":y=Dn(m,e.bufferSync(a),o,h,d,c,u,p,l.util.decodeString(e.data.get(i.dataId).values[0]),f);break;default:throw new Error(`Unsupported type ${a.dtype}`)}return e.makeTensorInfo(o,y.dtype,y.values)}},KT={kernelName:l.SplitV,backendName:"cpu",kernelFunc:function XT(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:a,axis:i}=s,o=l.util.parseAxisParam(i,r.shape)[0],u=l.backend_util.prepareSplitSize(r,a,o),c=new Array(r.shape.length).fill(0),d=r.shape.slice();return u.map(p=>{const h=[...d];h[o]=p;const f=An({inputs:{x:r},backend:e,attrs:{begin:c,size:h}});return c[o]+=p,f})}},qT=zt(n=>Math.sqrt(n)),ZT=me(l.Sqrt,n=>Math.sqrt(n)),YT={kernelName:l.Sqrt,backendName:"cpu",kernelFunc:ZT},QT={kernelName:l.Square,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,s=t;ee(e,"square");const r=s.data.get(e.dataId).values,a=new Float32Array(r.length);for(let o=0;o<r.length;++o){const u=r[o];a[o]=u*u}return{dataId:s.write(a,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}},JT=Oe((n,t)=>{const e=n-t;return e*e}),ek=We(l.SquaredDifference,JT),tk={kernelName:l.SquaredDifference,backendName:"cpu",kernelFunc:ek},Od=zt((n,t)=>{const{pattern:e,replaceGlobal:s,rewrite:r}=t;return n.replace(new RegExp(e,s?"g":""),r)}),nk=an(l.StaticRegexReplace,Od),sk={kernelName:l.StaticRegexReplace,backendName:"cpu",kernelFunc:nk},rk=me(l.Step,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),ak={kernelName:l.Step,backendName:"cpu",kernelFunc:rk};function zd(n,t,e,s){const r=(0,l.buffer)(n,t.dtype);for(let a=0;a<r.size;a++){const i=r.indexToLoc(a),o=new Array(i.length);for(let u=0;u<o.length;u++)o[u]=i[u]*e[u]+s[u];r.set(t.get(...o),...i)}return r}const ok={kernelName:l.StridedSlice,backendName:"cpu",kernelFunc:function ik(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:h}=s;ee(r,"stridedSlice");const{finalShapeSparse:f,finalShape:m,isIdentity:y,sliceDim0:g,isSimpleSlice:x,begin:b,end:S,strides:v}=l.slice_util.sliceInfo(r.shape,a,i,o,u,c,d,p,h);let I;if(y)I=Se({inputs:{x:r},backend:e,attrs:{shape:m}});else if(g||x){l.util.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const w=l.slice_util.computeOutShape(b,S,v),N=An({inputs:{x:r},backend:e,attrs:{begin:b,size:w}});I=Se({inputs:{x:N},backend:e,attrs:{shape:m}}),e.disposeIntermediateTensorInfo(N)}else{const N=zd(f,e.bufferSync(r),v,b);I=e.makeTensorInfo(m,N.dtype,N.values)}return I}};class lk{constructor(t,e,s,r,a,i){this.separator=l.util.encodeString(t),this.nGramWidths=e,this.leftPad=l.util.encodeString(s),this.rightPad=l.util.encodeString(r),this.padWidth=a,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const s=this.getPadWidth(e);return Math.max(0,t+2*s-e+1)}createNGrams(t,e,s,r,a,i){for(let o=0;o<a;++o){const u=this.getPadWidth(i),c=Math.max(0,u-o),d=Math.max(0,u-(a-(o+1))),p=i-(c+d),h=e+(c>0?0:o-u);let f=0;f+=c*this.leftPad.length;for(let b=0;b<p;++b)f+=t[h+b].length;f+=d*this.rightPad.length,f+=(c+d+p-1)*this.separator.length,s[r+o]=new Uint8Array(f);const y=s[r+o];let g=0;const x=b=>b.forEach(S=>y[g++]=S);for(let b=0;b<c;++b)x(this.leftPad),x(this.separator);for(let b=0;b<p-1;++b)x(t[h+b]),x(this.separator);if(p>0){x(t[h+p-1]);for(let b=0;b<d;++b)x(this.separator),x(this.rightPad)}else{for(let b=0;b<d-1;++b)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(t,e){const s=t.length,r=e.length;if(r>0){let u=e[0];if(0!==u)throw new Error(`First split value must be 0, got ${u}`);for(let c=1;c<r;++c){let d=e[c]>=u;if(d=d&&e[c]<=s,!d)throw new Error(`Invalid split value ${e[c]}, must be in [${u}, ${s}]`);u=e[c]}if(u!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${u}`)}const a=r-1,i=l.util.getArrayFromDType("int32",r);if(0===s||0===r){const u=new Array(s);for(let c=0;c<=a;++c)i[c]=0;return[u,i]}i[0]=0;for(let u=1;u<=a;++u){const c=e[u]-e[u-1];let d=0;this.nGramWidths.forEach(p=>{d+=this.getNumNGrams(c,p)}),this.preserveShort&&c>0&&0===d&&(d=1),i[u]=i[u-1]+d}const o=new Array(i[a]);for(let u=0;u<a;++u){const c=e[u];let d=i[u];if(this.nGramWidths.forEach(p=>{const f=this.getNumNGrams(e[u+1]-e[u],p);this.createNGrams(t,c,o,d,f,p),d+=f}),this.preserveShort&&d===i[u]){const p=e[u+1]-e[u];if(0===p)continue;this.createNGrams(t,c,o,d,1,p+2*this.padWidth)}}return[o,i]}}function Ld(n,t,e,s,r,a,i,o){return new lk(e,s,r,a,i,o).compute(n,t)}const ck={kernelName:l.StringNGrams,backendName:"cpu",kernelFunc:function uk(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:c}=s,{data:d,dataSplits:p}=t,h=e.data.get(d.dataId).values,f=e.data.get(p.dataId).values,[m,y]=Ld(h,f,r,a,i,o,u,c);return[e.makeTensorInfo([m.length],"string",m),e.makeTensorInfo(p.shape,"int32",y)]}};function dk(n,t,e,s){if(!n.length)return;if(0===t.length){for(let a=0;a<n.length;++a)s.push(n.subarray(a,a+1));return}if(1===t.length){const a=t[0];let i=n.indexOf(a);for(;-1!==i;){const o=n.subarray(0,i);(!e||0!==o.length)&&s.push(o),i=(n=n.subarray(i+1)).indexOf(a)}return void((!e||0!==n.length)&&s.push(n))}let r=0;for(let a=0;a<n.length+1;a++)if(a===n.length||-1!==t.indexOf(n[a])){const i=n.subarray(r,a);(!e||0!==i.length)&&s.push(i),r=a+1}}function Pd(n,t,e){const s=n.length,r=[];let a=0,i=0;const o=new Array(s);for(let h=0;h<s;++h){const f=r.length;dk(n[h],t,e,r);const m=r.length-f;o[h]=m,a+=m,i=Math.max(i,m)}const u=l.util.getArrayFromDType("int32",2*a),c=new Array(a),d=[s,i];let p=0;for(let h=0;h<s;++h)for(let f=0;f<o[h];++f)u[2*p]=h,u[2*p+1]=f,c[p]=r[p],++p;return[u,c,d]}const hk={kernelName:l.StringSplit,backendName:"cpu",kernelFunc:function pk(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=e.data.get(a.dataId).values,u=e.data.get(i.dataId).values[0],[c,d,p]=Pd(o,u,r),h=d.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}};function Vd(n,t){const e=l.util.getArrayFromDType("int32",n.length);for(let s=0;s<n.length;++s)e[s]=l.util.fingerPrint64(n[s]).modulo(t).getLowBitsUnsigned();return e}const mk={kernelName:l.StringToHashBucketFast,backendName:"cpu",kernelFunc:function fk(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=Vd(e.data.get(a.dataId).values,r);return e.makeTensorInfo(a.shape,"int32",o)}},gk=me(l.Tan,n=>Math.tan(n)),yk={kernelName:l.Tan,backendName:"cpu",kernelFunc:gk},xk=me(l.Tanh,n=>Math.tanh(n));function Bd(n,t){const e=new Array(n.rank);for(let r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];const s=(0,l.buffer)(e,n.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),i=new Array(n.rank);for(let u=0;u<i.length;u++)i[u]=a[u]%n.shape[u];const o=n.locToIndex(i);s.values[r]=n.values[o]}return s}const ws=(n,t)=>{const e=t.value-n.value;return 0===e?n.index-t.index:e};function Md(n,t,e=0,s=n.length-1){for(;s>e;){if(s-e>600){const o=s-e+1,u=t-e+1,c=Math.log(o),d=.5*Math.exp(2*c/3),p=.5*Math.sqrt(c*d*(o-d)/o)*Math.sign(u-o/2);Md(n,t,Math.max(e,Math.floor(t-u*d/o+p)),Math.min(s,Math.floor(t+(o-u)*d/o+p)))}const r=n[t];let a=e,i=s;for(l.util.swap(n,e,t),ws(n[s],r)>0&&l.util.swap(n,e,s);a<i;){for(l.util.swap(n,a,i),a++,i--;ws(n[a],r)<0;)a+=1;for(;ws(n[i],r)>0;)i-=1}0===ws(n[e],r)?l.util.swap(n,e,i):(i+=1,l.util.swap(n,i,s)),i<=t&&(e=i+1),t<=i&&(s=i-1)}}function Wd(n,t,e,s,r){const a=t[t.length-1],[i,o]=[n.length/a,a],u=l.util.getTypedArrayFromDType(e,i*s),c=l.util.getTypedArrayFromDType("int32",i*s);for(let p=0;p<i;p++){const h=p*o,f=n.subarray(h,h+o);let m=new Array(f.length);f.forEach((b,S)=>m[S]={value:b,index:S}),s<m.length&&(Md(m,s),m=m.slice(0,s)),r&&m.sort(ws);const y=p*s,g=u.subarray(y,y+s),x=c.subarray(y,y+s);for(let b=0;b<s;b++)g[b]=m[b].value,x[b]=m[b].index}const d=t.slice();return d[d.length-1]=s,[(0,l.buffer)(d,e,u),(0,l.buffer)(d,"int32",c)]}function Gd(n,t,e){switch(e){case"reflect":return function Rk(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const s=2*t;e<s&&(e=s*Math.trunc(-e/s)+e),e=e<-t?e+s:-e-1}else if(e>t-1)if(t<=1)e=0;else{const s=2*t;e-=s*Math.trunc(e/s),e>=t&&(e=s-e-1)}return l.util.clamp(0,e,t-1)}(n,t);case"wrap":return function Ak(n,t){let e=n;return e<0?t<=1?e=0:e+=t*(Math.trunc(-e/(t-1))+1):e>t-1&&(t<=1?e=0:e-=t*Math.trunc(e/(t-1))),l.util.clamp(0,e,t-1)}(n,t);case"nearest":return function $k(n,t){return l.util.clamp(0,n,t-1)}(n,t);default:return function Dk(n,t){return n}(n)}}function Ns(n,t,e,s,r,a,i,o,u,c,d){return 0<=o&&o<t&&0<=u&&u<e?n[i*s+o*r+u*a+c]:d}function Ek(n,t,e,s,r,a,i,o,u,c,d){return Ns(n,t,e,s,r,a,i,Math.round(o),Math.round(u),c,d)}function _k(n,t,e,s,r,a,i,o,u,c,d){const p=Math.floor(o),h=Math.floor(u),f=p+1,m=h+1;return(f-o)*((m-u)*Ns(n,t,e,s,r,a,i,p,h,c,d)+(u-h)*Ns(n,t,e,s,r,a,i,p,m,c,d))+(o-p)*((m-u)*Ns(n,t,e,s,r,a,i,f,h,c,d)+(u-h)*Ns(n,t,e,s,r,a,i,f,m,c,d))}function Ud(n,t,e,s){const r=l.util.parseAxisParam(t,e)[0],a=[1,e[0],1];for(let m=0;m<r;m++)a[0]*=e[m];a[1]=e[r];for(let m=r+1;m<e.length;m++)a[2]*=e[m];const i=new Map,o=new Int32Array(e[r]),u=new l.TensorBuffer(a,s,n),c=[],d=1===a[0]&&1===a[2];for(let m=0;m<e[r];m++){let y;if(d)y=n[m].toString();else{const x=[];for(let b=0;b<a[0];b++)for(let S=0;S<a[2];S++)x.push(u.get(b,m,S));y=x.join(",")}const g=i.get(y);if(null!=g)o[m]=g;else{const x=i.size;i.set(y,x),o[m]=x,c.push(m)}}const p=a.slice();p[1]=i.size;const h=new l.TensorBuffer(p,s);c.forEach((m,y)=>{for(let g=0;g<a[0];g++)for(let x=0;x<a[2];x++)h.set(u.get(g,m,x),g,y,x)});const f=e.slice();return f[r]=p[1],{outputValues:h.values,outputShape:f,indices:o}}const Bk=[$v,_v,Ov,Lv,kv,Vv,Wv,Uv,jv,Kv,Zv,Qv,eS,sS,aS,lS,cS,pS,fS,Av,gS,bS,vS,wS,TS,Nv,RS,DS,Iv,ES,FS,OS,LS,VS,MS,GS,HS,XS,qS,YS,JS,tI,sI,aI,iI,lI,cI,pI,hI,fI,mI,CI,fv,SI,II,$I,EI,_I,OI,GI,UI,jI,KI,YI,JI,tw,sw,aw,ow,uw,mv,dw,_S,hw,mw,yw,gv,bw,vw,Iw,Nw,kw,Dw,Ew,Ow,Lw,Vw,Bw,Ww,Uw,jw,Kw,Zw,Qw,eN,nN,rN,iN,uN,pN,yI,fN,yN,CN,IN,NN,kN,AN,DN,vd,FN,xv,zN,UN,jN,KN,ZN,wv,Pi,QN,bv,Cv,Rv,eT,nT,rT,iT,lT,uT,dT,hT,mT,CT,ST,TT,Sv,RT,DT,ET,yS,cN,FT,zT,PT,BT,WT,UT,jT,KT,YT,QT,tk,sk,ak,ok,ck,hk,mk,PI,xI,yk,{kernelName:l.Tanh,backendName:"cpu",kernelFunc:xk},{kernelName:l.TensorScatterUpdate,backendName:"cpu",kernelFunc:function Ck(n){const{inputs:t,backend:e}=n,{tensor:s,indices:r,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:u,strides:c,outputSize:d}=l.backend_util.calculateShapes(a,r,s.shape),h=e.bufferSync(r),f=e.bufferSync(a),m=e.bufferSync(s),y=Dn(h,f,s.shape,d,u,o,i,c,m,!1);return e.makeTensorInfo(s.shape,y.dtype,y.values)}},{kernelName:l.Tile,backendName:"cpu",kernelFunc:function Sk(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:a}=s;ee(r,"tile");const i=Bd(e.bufferSync(r),a);return e.makeTensorInfo(i.shape,i.dtype,i.values)}},{kernelName:l.TopK,backendName:"cpu",kernelFunc:function wk(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:a,sorted:i}=s;ee(r,"topk");const o=e.data.get(r.dataId).values,[u,c]=Wd(o,r.shape,r.dtype,a,i);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(c.shape,c.dtype,c.values)]}},{kernelName:l.Transform,backendName:"cpu",kernelFunc:function Tk(n){const{inputs:t,attrs:e,backend:s}=n,{image:r,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=e,[d,p,h,f]=r.shape,[m,y]=c??[p,h],g=[d,m,y,f],x=l.util.computeStrides(r.shape),b=x[0],S=x[1],v=x[2],I=l.util.computeStrides(g),w=I[0],N=I[1],T=I[2],D=l.util.getTypedArrayFromDType(r.dtype,l.util.sizeFromShape(g));D.fill(u);const A=s.data.get(r.dataId).values,$=s.data.get(a.dataId).values;for(let O=0;O<d;++O){const L=1===a.shape[0]?$:$.subarray(8*O,8*O+8);for(let z=0;z<m;++z)for(let P=0;P<y;++P)for(let B=0;B<f;++B){let _;const V=L[6]*P+L[7]*z+1;if(0===V)continue;const U=(L[3]*P+L[4]*z+L[5])/V,j=Gd((L[0]*P+L[1]*z+L[2])/V,h,o),H=Gd(U,p,o);switch(i){case"nearest":_=Ek(A,p,h,b,S,v,O,H,j,B,u);break;case"bilinear":_=_k(A,p,h,b,S,v,O,H,j,B,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}D[O*w+z*N+P*T+B]=_}return s.makeTensorInfo(g,r.dtype,D)}return{dataId:s.write(D,g,r.dtype),shape:r.shape,dtype:r.dtype}}},Bv,{kernelName:l.Unique,backendName:"cpu",kernelFunc:function Fk(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:a}=t;ee(a,"unique");const i=s.data.get(a.dataId).values,{outputValues:o,outputShape:u,indices:c}=Ud(i,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}},{kernelName:l.Unpack,backendName:"cpu",kernelFunc:function zk(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r.shape.length,o=r.shape[a],u=new Array(i-1);let c=0;for(let f=0;f<i;f++)f!==a&&(u[c++]=r.shape[f]);const d=new Array(i).fill(0),p=r.shape.slice();p[a]=1;const h=new Array(o);for(let f=0;f<h.length;f++){d[a]=f;const m=An({inputs:{x:r},backend:e,attrs:{begin:d,size:p}});h[f]=Se({inputs:{x:m},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(m)}return h}},{kernelName:l.UnsortedSegmentSum,backendName:"cpu",kernelFunc:function Pk(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:a}=t,{numSegments:i}=s;ee(r,"unsortedSegmentSum");const c=[],d=[],p=r.shape.length-a.shape.length;let h=a;for(let m=0;m<p;++m){const y=wr({inputs:{input:h},backend:e,attrs:{dim:m+1}});h=y,d.push(y)}for(let m=0;m<i;++m){const y=l.util.createScalarValue(m,"int32"),g=e.makeTensorInfo([],"int32",y),x=Yc({inputs:{a:g,b:h},backend:e}),b=on({inputs:{x},backend:e,attrs:{dtype:"float32"}}),S=Ir({inputs:{a:b,b:r},backend:e}),v=Is({inputs:{x:S},backend:e,attrs:{axis:0,keepDims:!1}});c.push(v),d.push(g),d.push(x),d.push(b),d.push(S),d.push(v)}const f=Cd({inputs:c,backend:e,attrs:{axis:0}});return d.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}},RN];for(const n of Bk)(0,l.registerKernel)(n);const ln={},kr={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function kt(n,t){if(!(n in ln)||null!=t){const s=function Gk(n,t){if(1!==n&&2!==n)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??function Wk(n){if(!(0,l.env)().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&2===n)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}(n);return e.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete ln[n]},!1),(0,l.env)().getBool("SOFTWARE_WEBGL_ENABLED")&&(kr.failIfMajorPerformanceCaveat=!1),1===n?e.getContext("webgl",kr)||e.getContext("experimental-webgl",kr):e.getContext("webgl2",kr)}(n,t);if(null===s)return console.log("Could not get context for WebGL version",n),null;ln[n]=s}const e=ln[n];return null==e||e.isContextLost()?(delete ln[n],kt(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),ln[n])}var Pt=(()=>((Pt=Pt||{})[Pt.DENSE=0]="DENSE",Pt[Pt.SHARED_BATCH=1]="SHARED_BATCH",Pt))(),ze=(()=>((ze=ze||{})[ze.RENDER=0]="RENDER",ze[ze.UPLOAD=1]="UPLOAD",ze[ze.PIXELS=2]="PIXELS",ze[ze.DOWNLOAD=3]="DOWNLOAD",ze))(),ye=(()=>((ye=ye||{})[ye.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",ye[ye.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",ye[ye.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",ye[ye.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",ye[ye.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",ye))();function Ts(n,t){return[t,n]}function Rr(n){const t=l.util.sizeFromShape(n),e=Math.ceil(t/4);return l.util.sizeToSquarishShape(e)}function qn(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function Gi(n,t){const e=n;let s,r,a,i,o,u,c,d,p,h;return 2===(0,l.env)().getNumber("WEBGL_VERSION")?(s=e.R32F,r=e.R16F,a=e.RGBA16F,i=e.RGBA32F,o=e.RED,c=4,d=1,p=e.HALF_FLOAT,h=e.FLOAT,u=e.RGBA8):(s=n.RGBA,r=n.RGBA,a=n.RGBA,i=e.RGBA,o=n.RGBA,c=4,d=4,p=null!=t?t.HALF_FLOAT_OES:null,h=n.FLOAT,u=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:u,downloadUnpackNumChannels:c,defaultNumChannels:d,textureTypeHalfFloat:p,textureTypeFloat:h}}function q(n,t){const e=t();return(0,l.env)().getBool("DEBUG")&&function jk(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+function Zk(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(n,t))}(n),e}function qk(n){return!!((0,l.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===n||5.96e-8<Math.abs(n)&&Math.abs(n)<65504)}function Ar(n,t){return Ht(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}const Jk=/ERROR: [0-9]+:([0-9]+):/g;function Hd(n,t){const e=Jk.exec(t);if(null==e)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(n);const s=+e[1],r=n.split("\n"),a=r.length.toString().length+2,i=r.map((p,h)=>l.util.rightPad((h+1).toString(),a)+p);let o=0;for(let p=0;p<i.length;p++)o=Math.max(i[p].length,o);const u=i.slice(0,s-1),c=i.slice(s-1,s),d=i.slice(s);console.log(u.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${l.util.rightPad(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(d.join("\n"))}function Ui(n,t){if(q(n,()=>n.validateProgram(t)),!1===n.getProgramParameter(t,n.VALIDATE_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function jd(n,t,e,s,r,a,i){const o=n.getAttribLocation(t,e);return-1!==o&&(q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),q(n,()=>n.vertexAttribPointer(o,r,n.FLOAT,!1,a,i)),q(n,()=>n.enableVertexAttribArray(o)),!0)}function c1(n,t,e,s){q(n,()=>function o1(n,t,e){(function Kd(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+n.TEXTURE0;if(s<n.TEXTURE0||s>e)throw new Error(`textureUnit must be in [gl.TEXTURE0, gl.TEXTURE${e}].`)})(n,e),q(n,()=>n.activeTexture(n.TEXTURE0+e)),q(n,()=>n.bindTexture(n.TEXTURE_2D,t))}(n,t,s)),q(n,()=>n.uniform1i(e,s))}function Hi(n,t,e){q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function Xd(n,t){q(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),q(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Dr(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function d1(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(n,t))}function Ht(n,t,e){const s=q(n,()=>t());if(null==s)throw new Error(e);return s}function Zn(n,t=2){return l.util.sizeFromShape(n.slice(0,n.length-t))}function Yn(n){if(0===n.length)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function $r(n){let t=[1,1,1];return 0===n.length||1===n.length&&1===n[0]||(t=[Zn(n),...Yn(n)]),t}function Er(n){return n%2==0}function _r(n,t){if(n=n.slice(-2),t=t.slice(-2),l.util.arraysEqual(n,t)||!n.length||!t.length||0===n[0]||0===n[1]||0===t[0]||0===t[1])return!0;if(n.length!==t.length){const e=n[n.length-1],s=t[t.length-1];if(e===s||Er(e)&&Er(s)&&(1===n[0]||1===t[0]))return!0}return n[1]===t[1]&&Er(n[0])&&Er(t[0])}let Fr,Or;function xt(n,t){return null!=n.getExtension(t)}function qd(n){try{if(null!=kt(n))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function ji(n){const t=Gi(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(a),i}function ks(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{null!=e&&l.util.assert("complex64"!==e.dtype,()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const te=(0,l.env)();function Ye(){let n,t,e,s,r,a,i,o,u,c;return 2===(0,l.env)().getNumber("WEBGL_VERSION")?(n="#version 300 es",t="in",e="out",s="in",r="texture",a="outputColor",i="out vec4 outputColor;",o=(0,l.env)().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",u="",c="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(n="",t="attribute",e="varying",s="varying",r="texture2D",a="gl_FragColor",i="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",u="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",c="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:n,attribute:t,varyingVs:e,varyingFs:s,texture2D:r,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:u,defineRound:c}}function $n(n,t,e="index"){const s=l.util.computeStrides(t);return s.map((r,a)=>`int ${n[a]} = ${e} / ${r}; ${a===s.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * ${r}`:`index -= ${n[a]} * ${r}`};`).join("")}function zr(n,t,e="index"){const s=l.util.computeStrides(t);return s.map((r,a)=>`int ${n[a]} = ${e} / outShapeStrides[${a}]; ${a===s.length-1?`int ${n[a+1]} = ${e} - ${n[a]} * outShapeStrides[${a}]`:`index -= ${n[a]} * outShapeStrides[${a}]`};`).join("")}function Xi(n){const t=l.util.computeStrides(n).map(e=>e.toString());return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}te.registerFlag("HAS_WEBGL",()=>te.getNumber("WEBGL_VERSION")>0),te.registerFlag("WEBGL_VERSION",()=>qd(2)?2:qd(1)?1:0),te.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),te.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>2===te.get("WEBGL_VERSION")),te.registerFlag("WEBGL_CPU_FORWARD",()=>!0),te.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),te.registerFlag("WEBGL_PACK",()=>te.getBool("HAS_WEBGL")),te.registerFlag("WEBGL_PACK_NORMALIZATION",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_CLIP",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_PACK_REDUCE",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_LAZILY_UNPACK",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_CONV_IM2COL",()=>te.getBool("WEBGL_PACK")),te.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>function h1(n){if(null==Fr){const t=kt(n);Fr=t.getParameter(t.MAX_TEXTURE_SIZE)}return Fr}(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>function f1(n){if(null==Or){const t=kt(n);Or=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Or)}(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=te.getNumber("WEBGL_VERSION");return 0===n?0:function m1(n){if(0===n)return 0;let t;const e=kt(n);return t=xt(e,"EXT_disjoint_timer_query_webgl2")&&2===n?2:xt(e,"EXT_disjoint_timer_query")?1:0,t}(n)}),te.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>te.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!l.device_util.isMobile()),te.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>function g1(n){if(0===n)return!1;const t=kt(n);if(1===n){if(!xt(t,"OES_texture_float"))return!1}else if(!xt(t,"EXT_color_buffer_float"))return!1;return ji(t)}(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>!te.getBool("WEBGL_FORCE_F16_TEXTURES")&&te.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),te.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>function y1(n){if(0===n)return!1;const t=kt(n);if(1!==n){if(xt(t,"EXT_color_buffer_float"))return ji(t);const s="EXT_color_buffer_half_float";if(xt(t,s)){const r=t.getExtension(s);return function x1(n,t){const e=Gi(n,t),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(i),o}(t,r)}return!1}return!(!xt(t,"OES_texture_float")||!xt(t,"WEBGL_color_buffer_float"))&&ji(t)}(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_FENCE_API_ENABLED",()=>function b1(n){return 2===n&&null!=kt(n).fenceSync}(te.getNumber("WEBGL_VERSION"))),te.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>te.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),te.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)}),te.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>l.device_util.isMobile()?1:-1,n=>{if(n<0&&-1!==n)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)}),te.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),te.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),te.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),te.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),te.registerFlag("WEBGL_EXP_CONV",()=>!1),te.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>te.getBool("IS_TEST")),te.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),te.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),te.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),te.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);const Zd="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:Yd}=l.backend_util;function S1(n,t,e){const s=[];if(n.forEach(f=>{const m=l.util.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?s.push(`uniform float ${f.name}${m>1?`[${m}]`:""};`):(s.push(`uniform sampler2D ${f.name};`),s.push(`uniform int offset${f.name};`)),e.enableShapeUniforms){const{uniformShape:y}=qi(e.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(y.length){case 1:s.push(`uniform int ${f.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${f.name}Shape;`)}s.push(`uniform ivec2 ${f.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;")}s.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(f=>{s.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});const r=s.join("\n"),a=n.map(f=>function I1(n,t,e=!1,s){let r="";r+=e?Qd(n,s):Qn(n,s);return n.shapeInfo.logicalShape.length<=t.logicalShape.length&&(r+=e?function nR(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",a=n.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=Yd(n.shapeInfo.logicalShape,t.logicalShape),u=xe(i),c=i-a;let d;const p=["x","y","z","w","u","v"];d=0===a?"":i<2&&o.length>=1?"coords = 0;":o.map(b=>`coords.${p[b+c]} = 0;`).join("\n");let h="";h=i<2&&a>0?"coords":n.shapeInfo.logicalShape.map((b,S)=>`coords.${p[S+c]}`).join(", ");let f="return outputValue;";const y=1===l.util.sizeFromShape(n.shapeInfo.logicalShape),x=1===l.util.sizeFromShape(t.logicalShape);if(1!==a||y||x){if(y&&!x)f=1===i?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const b=a-2,S=a-1;o.indexOf(b)>-1&&o.indexOf(S)>-1?f="return vec4(outputValue.x);":o.indexOf(b)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(S)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}}else f="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      vec4 outputValue = get${s}(${h});\n      ${f}\n    }\n  `}(n,t):function sR(n,t){const e=n.name,s=e.charAt(0).toUpperCase()+e.slice(1),r="get"+s+"AtOutCoords",o=n.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!n.shapeInfo.isUniform&&o===u&&null==n.shapeInfo.flatOffset&&l.util.arraysEqual(n.shapeInfo.texShape,t.texShape))return`\n      float ${r}() {\n        return sampleTexture(${e}, resultUV);\n      }\n    `;const c=xe(u),d=Yd(n.shapeInfo.logicalShape,t.logicalShape),p=u-o;let h;const f=["x","y","z","w","u","v"];h=0===o?"":u<2&&d.length>=1?"coords = 0;":d.map(y=>`coords.${f[y+p]} = 0;`).join("\n");let m="";return m=u<2&&o>0?"coords":n.shapeInfo.logicalShape.map((y,g)=>`coords.${f[g+p]}`).join(", "),`\n    float ${r}() {\n      ${c} coords = getOutputCoords();\n      ${h}\n      return get${s}(${m});\n    }\n  `}(n,t)),r}(f,t,e.packedInputs,e.enableShapeUniforms)).join("\n"),i=t.texShape,o=Ye(),u=function T1(n){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${n.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let c,d,p=function A1(n){return`${n.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${n.varyingFs} vec2 resultUV;\n    ${n.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${n.defineSpecialNaN}\n    ${n.defineSpecialInf}\n    ${n.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${D1}\n    ${$1}\n    ${E1}\n  `}(o);return t.isPacked?(c=function w1(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function F1(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return 1===s[0]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `:1===s[1]?e?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `}(0,t,e);case 2:return function W1(n,t,e){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(l.util.arraysEqual(n,t))return e?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `;const r=Math.ceil(n[1]/2);return e?"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function z1(n,t,e){if(e)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[2]/2),a=r*Math.ceil(n[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(n,t,e);default:return function P1(n,t,e){if(e)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(n[n.length-1]/2),a=r*Math.ceil(n[n.length-2]/2);let i=a,o="",u="b, r, c";for(let c=2;c<n.length-1;c++)i*=n[n.length-c-1],o=`\n      int b${c} = index / ${i};\n      index -= b${c} * ${i};\n    `+o,u=`b${c}, `+u;return`\n    ivec${n.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${a};\n      index -= b * ${a};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${n.length}(${u});\n    }\n  `}(n,t,e)}}(t.logicalShape,i,e.enableShapeUniforms),d=function R1(n){return`\n    void setOutput(vec4 val) {\n      ${n.output} = val;\n    }\n  `}(o)):(c=function N1(n,t,e){switch(n.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function O1(n,t,e){return 1===t[0]?e?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `:1===t[1]?e?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `:e?"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ":`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,e);case 2:return function G1(n,t,e){return l.util.arraysEqual(n,t)?e?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `:1===n[1]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `:1===n[0]?e?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `:e?"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ":`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${n[1]};\n      int c = index - r * ${n[1]};\n      return ivec2(r, c);\n    }\n  `}(n,t,e);case 3:return function L1(n,t,e){if(e)return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${zr(["r","c","d"],n)}\n    return ivec3(r, c, d);\n  }\n`;const s=$n(["r","c","d"],n);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `}(n,t,e);case 4:return function V1(n,t,e){if(e)return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${zr(["r","c","d","d2"],n)}\n      return ivec4(r, c, d, d2);\n    }\n  `;const s=$n(["r","c","d","d2"],n);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `}(n,t,e);case 5:return function B1(n,t){const e=$n(["r","c","d","d2","d3"],n);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(n,t);case 6:return function M1(n,t){const e=$n(["r","c","d","d2","d3","d4"],n);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${e}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}(t.logicalShape,i,e.enableShapeUniforms),d=function k1(n){return`\n    void setOutput(float val) {\n      ${n.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),e.packedInputs&&(p+=_1),[p,u,d,r,c,a,e.userCode].join("\n")}function Qn(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return function H1(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${e};}`;const[r,a]=n.shapeInfo.texShape;if(1===r&&1===a)return`\n      float ${s}() {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const i=En(e);if(t)return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `;const[o,u]=n.shapeInfo.texShape;return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${o}, ${u}, ${i});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 1:return function X1(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\n      float ${s}(int index) {\n        ${Jn(n)}\n      }\n    `;const r=n.shapeInfo.texShape,a=r[0],i=r[1];if(1===i&&1===a)return`\n      float ${s}(int index) {\n        return sampleTexture(${e}, halfCR);\n      }\n    `;const o=En(e);return 1===i?t?`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${e}TexShape[0]));\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `:1===a?t?`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${e}TexShape[1]), 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);\n        return sampleTexture(${e}, uv);\n      }\n    `:t?`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `:`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});\n      return sampleTexture(${e}, uv);\n    }\n  `}(n,t);case 2:return function q1(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape;if(null!=a&&l.util.arraysEqual(e,a))return t?`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${a[1]}.0, ${a[0]}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const{newShape:i,keptDims:o}=l.util.squeezeShape(e);if(i.length<e.length){const f=["row","col"];return`\n      ${Qn(es(n,i),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${ts(f,o)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));\n        ${Jn(n)}\n      }\n    `;const c=a[0],d=a[1],p=En(s);return 1===d?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `:1===c?t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${p}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${p}), vec3(${e[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `:t?`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${p};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${e[1]} + col + ${p};\n    vec2 uv = uvFromFlat(${c}, ${d}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}(n,t);case 3:return function Y1(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=e[1]*e[2],i=e[2],{newShape:o,keptDims:u}=l.util.squeezeShape(e);if(o.length<e.length){const g=["row","col","depth"];return`\n        ${Qn(es(n,o),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${ts(g,u)});\n        }\n      `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${a}, ${i}, 1)));\n        ${Jn(n)}\n      }\n    `;const d=n.shapeInfo.texShape,p=d[0],h=d[1],f=n.shapeInfo.flatOffset;if(h===a&&null==f)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${i}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${h}.0, ${p}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `;if(h===i&&null==f)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${p}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const m=En(s);return t?`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${m};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `:`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${a} + col * ${i} + depth + ${m};\n        vec2 uv = uvFromFlat(${p}, ${h}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}(n,t);case 4:return function J1(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=e[3],i=e[2]*a,o=e[1]*i,{newShape:u,keptDims:c}=l.util.squeezeShape(e);if(u.length<e.length){const S=["row","col","depth","depth2"];return`\n      ${Qn(es(n,u),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${ts(S,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${i}, ${a}, 1)));\n        ${Jn(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,h=p[0],f=p[1],m=`int stride2 = ${s}Shape[3];`,y=`int stride1 = ${s}Shape[2] * stride2;`,g=`int stride0 = ${s}Shape[1] * stride1;`;if(f===o&&null==d)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${m}\n        ${y}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${i}, ${a}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;if(f===a&&null==d)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${e[1]*e[2]}, ${e[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;const x=En(s);return t?`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${m}\n      ${y}\n      ${g}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${x});\n      return sampleTexture(${s}, uv);\n    }\n  `:`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} +\n          depth * ${a} + depth2;\n      vec2 uv = uvFromFlat(${h}, ${f}, index + ${x});\n      return sampleTexture(${s}, uv);\n    }\n  `}(n,t);case 5:return function eR(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=t[4],a=t[3]*r,i=t[2]*a,o=t[1]*i,{newShape:u,keptDims:c}=l.util.squeezeShape(t);if(u.length<t.length){const g=["row","col","depth","depth2","depth3"];return`\n      ${Qn(es(n,u))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${ts(g,c)});\n      }\n    `}if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${i}, ${a}, ${r})) +\n          depth3;\n        ${Jn(n)}\n      }\n    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,h=p[0],f=p[1];if(f===o&&null==d)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${i}, ${a}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(f===r&&null==d)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${h}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${i} + depth * ${a} +\n          depth2 * ${r} + depth3 + ${En(e)};\n      vec2 uv = uvFromFlat(${h}, ${f}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);case 6:return function tR(n){const t=n.shapeInfo.logicalShape,e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:r,keptDims:a}=l.util.squeezeShape(t);if(r.length<t.length){const x=["row","col","depth","depth2","depth3","depth4"];return`\n      ${Qn(es(n,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${ts(x,a)});\n      }\n    `}const i=t[5],o=t[4]*i,u=t[3]*o,c=t[2]*u,d=t[1]*c;if(n.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${d}, ${c}, ${u}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${i}, 1)));\n        ${Jn(n)}\n      }\n    `;const p=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,f=h[0],m=h[1];if(m===d&&null==p)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${c}, ${u}, ${o}, ${i})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${m}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;if(m===i&&null==p)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${m}.0, ${f}.0);\n        return sampleTexture(${e}, uv);\n      }\n    `;return`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${d} + col * ${c} + depth * ${u} +\n          depth2 * ${o} + depth3 * ${i} + depth4 + ${En(e)};\n      vec2 uv = uvFromFlat(${f}, ${m}, index);\n      return sampleTexture(${e}, uv);\n    }\n  `}(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function Qd(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return function U1(n){const t=n.name;return`\n    vec4 ${"get"+t.charAt(0).toUpperCase()+t.slice(1)}() {\n      return ${Ye().texture2D}(${t}, halfCR);\n    }\n  `}(n);case 1:return function j1(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=n.shapeInfo.texShape,a=Ye();if(t)return`\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `;const i=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${i[0]}, ${i[1]}, index);\n      return ${a.texture2D}(${e}, uv);\n    }\n  `}(n,t);case 2:return function K1(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,i=a[0],o=a[1],u=Ye();if(null!=a&&l.util.arraysEqual(e,a))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${u.texture2D}(${s}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);\n\n        return ${u.texture2D}(${s}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${u.texture2D}(${s}, uv);\n    }\n  `;const c=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${Math.ceil(e[1]/2)}, ${c[0]}, ${c[1]}, row, col);\n      return ${u.texture2D}(${s}, uv);\n    }\n  `}(n,t);case 3:return function Z1(n,t){const e=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(1===e[0]){const f=[1,2],y=["b","row","col"];return`\n        ${Qd(es(n,e.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${ts(y,f)});\n        }\n      `}const o=Ye();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${s}, uv);\n    }\n  `;const u=i[0],c=i[1],d=Math.ceil(e[2]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${u}, ${c}, ${d*Math.ceil(e[1]/2)}, ${d}, b, row, col);\n      return ${o.texture2D}(${s}, uv);\n    }\n  `}(n,t);default:return function Q1(n,t){const e=n.name,s="get"+e.charAt(0).toUpperCase()+e.slice(1),r=Ye();if(t)return`\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${e}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${e}, uv);\n    }\n  `;const a=n.shapeInfo.logicalShape,i=a.length,o=n.shapeInfo.texShape,u=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=u[0],d=u[1],p=Math.ceil(a[i-1]/2);let h=p*Math.ceil(a[i-2]/2),f="int b, int row, int col",m=`b * ${h} + (row / 2) * ${p} + (col / 2)`;for(let y=2;y<i-1;y++)f=`int b${y}, `+f,h*=a[i-y-1],m=`b${y} * ${h} + `+m;return`\n    vec4 ${s}(${f}) {\n      int index = ${m};\n      int texR = index / ${d};\n      int texC = index - texR * ${d};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}, ${c});\n      return ${r.texture2D}(${e}, uv);\n    }\n  `}(n,t)}}const D1="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",$1="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",E1="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",_1="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function En(n){return`offset${n}`}function Jn(n){const t=n.name,e=l.util.sizeFromShape(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`\n    for (int i = 0; i < ${e}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function xe(n){if(n<=1)return"int";if(2===n)return"ivec2";if(3===n)return"ivec3";if(4===n)return"ivec4";if(5===n)return"ivec5";if(6===n)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function qi(n,t,e){const{newShape:s,keptDims:r}=l.util.squeezeShape(t),a=t.length,i=n&&3===a&&1===t[0],o=i?t.slice(1):s,u=!n&&a>1&&!l.util.arraysEqual(t,e)&&s.length<a||i;return{useSqueezeShape:u,uniformShape:u?o:t,keptDims:r}}function es(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function ts(n,t){return t.map(e=>n[e]).join(", ")}function ep(n,t,e){const s=[],r=[];let a,i,o,u=null,c=null;c=n.getUniformLocation(e,"NAN",!1),1===(0,l.env)().getNumber("WEBGL_VERSION")&&(u=n.getUniformLocation(e,"INFINITY",!1));const d=!1;for(const p of t.variableNames){const h={name:p,uniform:n.getUniformLocation(e,p,d),offset:n.getUniformLocation(e,`offset${p}`,d)};t.enableShapeUniforms&&(h.shape=n.getUniformLocation(e,`${p}Shape`,d),h.texShape=n.getUniformLocation(e,`${p}TexShape`,d)),s.push(h)}if(t.enableShapeUniforms&&(a=n.getUniformLocation(e,"outShape",d),o=n.getUniformLocation(e,"outShapeStrides",d),i=n.getUniformLocation(e,"outTexShape",d)),t.customUniforms)for(const p of t.customUniforms)r.push(n.getUniformLocation(e,p.name,d));return{variablesLocations:s,customUniformLocations:r,infLoc:u,nanLoc:c,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function tp(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,s)=>{const r=e.logicalShape,a=t[s],i=a.shape;if(!l.util.arraysEqual(r,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${i} must match`);if(e.isUniform&&a.isUniform)return;const o=e.texShape,u=a.isUniform?null:a.texData.texShape;if(!l.util.arraysEqual(o,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${u} must match`)})}function Ze(n){return(0,l.env)().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class oR{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Pt.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ye();this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?zr(["r","c","d"],t):$n(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${e.output} = result;\n      }\n    `}}class lR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Pt.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=Ye();this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?zr(["r","c","d"],t):$n(["r","c","d"],t)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${e.output} = result;\n      }\n    `}}class uR{constructor(t){this.variableNames=["A"],this.outTexUsage=ze.DOWNLOAD;const e=Ye();this.outputShape=t,this.userCode=`\n      ${Zd}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${e.output} = encode_float(x);\n      }\n    `}}class cR{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ze.DOWNLOAD;const e=Ye();this.outputShape=t,this.userCode=`\n      ${Zd}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${e.output} = encode_float(x);\n      }\n    `}}const dR={R:0,G:1,B:2,A:3};class np{constructor(t,e=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=Ye();this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length);let a="result";e&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<s.length;o++)i+=`\n          if(offset == ${o}) {\n            result = values[${dR[s[o]]}];\n          }`;this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Xi(t)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${s.length});\n\n        flatIndex = idiv(flatIndex, ${s.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${r.texture2D}(A, uv);\n          ${i}\n        }\n        ${r.output} = vec4(${a}, 0., 0., 0.);\n      }\n    `}}class pR{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Ye();this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length);let r="",a="result";e&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const u=2*i+o;r+=`\n          localCoords = coords;\n          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {\n          localCoords[2] += ${o};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${s.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${u}] = values[0];\n            } else if (offset == 1) {\n              result[${u}] = values[1];\n            } else if (offset == 2) {\n              result[${u}] = values[2];\n            } else {\n              result[${u}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Xi(t)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${r}\n\n          ${s.output} = ${a};\n        }\n    `}}function Rs(n,t,e,s,r,a){!function a1(n,t){const e=(0,l.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0)throw new Error(`Requested texture size [${n}x${t}] is invalid.`);if(n>e||t>e)throw new Error(`Requested texture size [${n}x${t}] greater than WebGL maximum on this browser / GPU [${e}x${e}].`)}(t,e);const i=function r1(n){return Ht(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}(n),o=n.TEXTURE_2D;return q(n,()=>n.bindTexture(o,i)),q(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),q(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),q(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),q(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),1===(0,l.env)().getNumber("WEBGL_VERSION")?q(n,()=>n.texImage2D(o,0,s,t,e,0,r,a,null)):q(n,()=>n.texStorage2D(o,1,s,t,e)),q(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:i,texShape:[e,t]}}function sp(n){return n.internalFormatFloat}function rp(n){return n.internalFormatHalfFloat}function ap(n){return n.downloadTextureFormat}function ip(n){return n.internalFormatPackedFloat}function op(n){return n.internalFormatPackedHalfFloat}class Zi{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=(0,l.env)().getNumber("WEBGL_VERSION");if(null!=t?(this.gl=t,function Mk(n,t){ln[n]=t}(e,t)):this.gl=kt(e),t=this.gl,2===(0,l.env)().getNumber("WEBGL_VERSION")){const a=t;this.createVertexArray=()=>q(a,()=>a.createVertexArray()),this.bindVertexArray=i=>q(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>q(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>q(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(null!=t){const a=t.getExtension("OES_vertex_array_object");if(null==a)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>q(t,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>q(t,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>q(t,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>q(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===(0,l.env)().getNumber("WEBGL_VERSION")){const i="OES_texture_half_float";if(this.textureFloatExtension=Ar(this.gl,"OES_texture_float"),xt(this.gl,i))this.textureHalfFloatExtension=Ar(this.gl,i);else if((0,l.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),xt(this.gl,r))this.colorBufferHalfFloatExtension=Ar(this.gl,r);else if((0,l.env)().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",xt(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else{if(!xt(this.gl,r))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(r)}this.vertexBuffer=function fR(n){return function n1(n,t){const e=Ht(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),q(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}(this.gl),this.indexBuffer=function mR(n){return function s1(n,t){const e=Ht(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return q(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),q(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}(n,new Uint16Array([0,1,2,2,1,3]))}(this.gl),this.framebuffer=function i1(n){return Ht(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=Gi(this.gl,this.textureHalfFloatExtension)}get debug(){return(0,l.env)().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;q(t,()=>t.finish()),q(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),q(t,()=>t.deleteFramebuffer(this.framebuffer)),q(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),q(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),q(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),function gR(n,t,e,s){const[r,a]=Ts(t,e);return Rs(n,r,a,sp(s),s.textureFormatFloat,n.FLOAT)}(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),function yR(n,t,e,s){const[r,a]=Ts(t,e);return Rs(n,r,a,rp(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),function xR(n,t,e,s){const[r,a]=Ts(t,e);return Rs(n,r,a,ap(s),n.RGBA,n.UNSIGNED_BYTE)}(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),function IR(n,t,e){q(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?2===(0,l.env)().getNumber("WEBGL_VERSION")?q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):2===(0,l.env)().getNumber("WEBGL_VERSION")?q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):q(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,s,r){this.throwIfDisposed(),function SR(n,t,e,s,r,a){let i,o,u;q(n,()=>n.bindTexture(n.TEXTURE_2D,t)),r instanceof Uint8Array?(i=new Uint8Array(e*s*4),o=n.UNSIGNED_BYTE,u=n.RGBA):(i=new Float32Array(e*s*4),o=n.FLOAT,u=a.internalFormatPackedFloat),i.set(r),2===(0,l.env)().getNumber("WEBGL_VERSION")?q(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,s,n.RGBA,o,i)):q(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,e,s,0,n.RGBA,o,i)),q(n,()=>n.bindTexture(n.TEXTURE_2D,null))}(this.gl,t,e,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),function CR(n,t,e,s){const[r,a]=qn(t,e);return Rs(n,r,a,op(s),n.RGBA,s.textureTypeHalfFloat)}(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),function bR(n,t,e,s){const[r,a]=qn(t,e);return Rs(n,r,a,ip(s),n.RGBA,n.FLOAT)}(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Xd(this.gl,this.framebuffer),this.outputTexture=null),q(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,s){return this.downloadMatrixDriver(t,()=>function TR(n,t,e,s){const[r,a]=Ts(t,e),o=new Uint8Array(function Uk(n,t){return n*t}(t*e,4));return q(n,()=>n.readPixels(0,0,r,a,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}(this.gl,e,s,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,s,r,a,i){return function kR(n,t,e,s,r,a,i,o){const u=n,c=new Float32Array(function Hk(n,t){const[e,s]=qn(n,t);return e*s*4}(a,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,c),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),c}(this.gl,t,0,0,0,a,i)}downloadFloat32MatrixFromBuffer(t,e){return function NR(n,t,e){const s=n,r=new Float32Array(e);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,t,e)}createBufferFromTexture(t,e,s){this.bindTextureToFrameBuffer(t);const r=function wR(n,t,e,s){const r=n.createBuffer();q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const o=16*t*e;return q(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),q(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),q(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}(this.gl,e,s);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,s;if((0,l.env)().getBool("WEBGL_FENCE_API_ENABLED")){const r=t,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),s=()=>{const i=r.clientWaitSync(a,0,0);return i===r.ALREADY_SIGNALED||i===r.CONDITION_SATISFIED},e=a}else(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(e,(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:e,isFencePassed:s}}downloadMatrixFromPackedTexture(t,e,s){return this.downloadMatrixDriver(t,()=>function RR(n,t,e){const s=new Float32Array(t*e*4);return q(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,s)),s}(this.gl,e,s))}createProgram(t){this.throwIfDisposed();const e=this.gl;null==this.vertexShader&&(this.vertexShader=function hR(n){const t=Ye();return function Yk(n,t){const e=Ht(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(q(n,()=>n.shaderSource(e,t)),q(n,()=>n.compileShader(e)),!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}(n,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}(e));const s=function e1(n){return Ht(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}(e);q(e,()=>e.attachShader(s,this.vertexShader)),q(e,()=>e.attachShader(s,t)),function t1(n,t){if(q(n,()=>n.linkProgram(t)),!(0,l.env)().get("ENGINE_COMPILE_ONLY")&&!1===n.getProgramParameter(t,n.LINK_STATUS))throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(e,s);const r=Object.assign(s,{vao:this.createVertexArray()});return this.debug&&Ui(e,r),r}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;q(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),function vR(n,t,e){q(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),jd(n,t,"clipSpacePos",e,3,20,0)&&jd(n,t,"uv",e,2,20,12)}(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),null!=t&&(q(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,null!=this.program&&this.debug&&Ui(this.gl,this.program),q(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,s=!0){return this.throwIfDisposed(),s?function l1(n,t,e){return Ht(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}(this.gl,t,e):function u1(n,t,e){return n.getUniformLocation(t,e)}(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),q(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,s){this.throwIfDisposed(),this.throwIfNoProgram(),c1(this.gl,t,e,s)}setOutputMatrixTexture(t,e,s){this.setOutputMatrixTextureDriver(t,s,e)}setOutputPackedMatrixTexture(t,e,s){this.throwIfDisposed();const[r,a]=qn(e,s);this.setOutputMatrixTextureDriver(t,r,a)}setOutputMatrixWriteRegion(t,e,s,r){this.setOutputMatrixWriteRegionDriver(s,t,r,e)}setOutputPackedMatrixWriteRegion(t,e,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&Ui(this.gl,this.program),Dr(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}q(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),q(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=Ar(this.gl,2===(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(2===(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,s=this.getQueryTimerExtensionWebGL2();return void e.endQuery(s.TIME_ELAPSED_EXT)}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}waitForQueryAndGetTime(t){var e=this;return(0,J.Z)(function*(){return yield l.util.repeatedTry(()=>e.disposed||e.isQueryAvailable(t,(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),e.getQueryTime(t,(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))})()}getQueryTime(t,e){if(0===e)return null;if(2===e){const s=this.gl;return s.getQueryParameter(t,s.QUERY_RESULT)/1e6}{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(t,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(0===e)return!0;if(2===e){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(t,s.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(t,s.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=function AR(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:s}=this.itemsToPoll[e];s()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in(0,l.env)().platform&&(s=(0,l.env)().platform.setTimeoutCustom.bind((0,l.env)().platform)),l.util.repeatedTry(()=>(this.pollItems(),0===this.itemsToPoll.length),()=>0,null,s)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Hi(this.gl,t,this.framebuffer),this.debug&&Dr(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(Hi(this.gl,this.outputTexture,this.framebuffer),this.debug&&Dr(this.gl)):Xd(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const s=e();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(t,e,s){this.throwIfDisposed();const r=this.gl;Hi(r,t,this.framebuffer),this.debug&&Dr(r),this.outputTexture=t,q(r,()=>r.viewport(0,0,e,s)),q(r,()=>r.scissor(0,0,e,s))}setOutputMatrixWriteRegionDriver(t,e,s,r){this.throwIfDisposed(),q(this.gl,()=>this.gl.scissor(t,e,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:DR,bincountImpl:lp,bincountReduceImpl:$R,castImpl:ER,ceilImpl:_R,concatImpl:FR,equalImpl:OR,expImpl:zR,expm1Impl:LR,floorImpl:PR,gatherNdImpl:VR,gatherV2Impl:BR,greaterImpl:MR,greaterEqualImpl:WR,lessImpl:GR,lessEqualImpl:UR,linSpaceImpl:HR,logImpl:jR,maxImpl:XR,maximumImpl:KR,minimumImpl:qR,multiplyImpl:ZR,negImpl:YR,notEqualImpl:QR,prodImpl:JR,raggedGatherImpl:eA,raggedRangeImpl:tA,raggedTensorToTensorImpl:nA,rangeImpl:sA,rsqrtImpl:rA,scatterImpl:aA,sigmoidImpl:iA,simpleAbsImpl:up,sliceImpl:oA,sparseFillEmptyRowsImpl:lA,sparseReshapeImpl:uA,sparseSegmentReductionImpl:cp,sqrtImpl:cA,staticRegexReplaceImpl:dA,stridedSliceImpl:pA,stringNGramsImpl:hA,stringSplitImpl:fA,stringToHashBucketFastImpl:mA,subImpl:gA,tileImpl:yA,topKImpl:xA,transposeImpl:Yi,uniqueImpl:bA}=fa;function dp(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function Qe(n,t){return 1===t?[n]:dp(n,t)}class vA{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Ze(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=Qe("rc",this.rank),s=xe(this.rank),r=this.getOutOfBoundsCondition(e),a=this.getSetup(e),i=this.getOutput(e);this.userCode=`\n        void main() {\n          ${s} rc = getOutputCoords();\n\n          if(${r}) {\n            setOutput(vec4(0));\n          } else {\n            ${a}\n\n            setOutput(vec4(${i}));\n          }\n        }\n      `}}getSourceCoordsArr(t){const e=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${0===s?"r":"rp1"}, ${0===r?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${t[t.length-1-i]},`+a;e.push(a)}return e}getOutOfBoundsCondition(t){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let s=this.rank-2;s<this.rank;s++)e+=`${t[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(e+="||");return e}getSetup(t){if(1===this.rank)return"";const e=t.slice(-2);return`\n      int r = ${e[0]};\n      int c = ${e[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1]};\n      bool rEdge = rp1 >= ${this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2]};\n    `}getOutput(t){const e=this.getSourceCoordsArr(t);return 1===this.rank?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),\n            cEdge ? 0. : getA(${e[1]}),\n            rEdge ? 0. : getA(${e[2]}),\n            rEdge || cEdge ? 0. : getA(${e[3]})`}}class pp{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length);let s="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2==1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),s+=`\n        ${a}\n        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${r}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${r>0?"}":""}\n      `}this.userCode=`\n      ${function SA(n,t){return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t?function v1(n,t,e="index"){const r=function C1(n,t){const e=n.length,s=n.map(a=>`${t}[${a}]`),r=new Array(e-1);r[e-2]=s[e-1];for(let a=e-3;a>=0;--a)r[a]=`(${r[a+1]} * ${s[a+1]})`;return r}(n.map((a,i)=>i),t);return r.map((a,i)=>`int ${n[i]} = ${e} / ${r[i]}; ${i===r.length-1?`int ${n[i+1]} = ${e} - ${n[i]} * ${r[i]}`:`index -= ${n[i]} * ${r[i]}`};`).join("")}(["r","c","d"],"inputShape"):$n(["r","c","d"],n)}\n      return ivec3(r, c, d);\n    }\n  `}(e,this.enableShapeUniforms)}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":Xi(t)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};\n\n        ${s}\n\n        setOutput(result);\n      }\n    `}}class IA{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,s){const r=fp(e,s),a=mp(t,r,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=hp(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const u=this.freeTextures[a].pop();return this.usedTextures[a].push(u),u}let o;return r===ye.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):r===ye.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):r===ye.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):r===ye.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):r===ye.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,e,s,r){if(null==this.freeTextures)return;const a=fp(s,r),i=mp(e,a,r);i in this.freeTextures||(this.freeTextures[i]=[]);const o=hp(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),u=(0,l.env)().get("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==u&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[i],d=c&&c.indexOf(t);if(null==d||d<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[d]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${this.numFreeTextures+this.numUsedTextures})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function hp(n,t,e,s,r){const a=function NA(n,t){switch(n){case ye.PACKED_2X2_FLOAT32:return ip(t);case ye.PACKED_2X2_FLOAT16:return op(t);case ye.UNPACKED_FLOAT32:return sp(t);case ye.UNPACKED_FLOAT16:return rp(t);case ye.PACKED_4X1_UNSIGNED_BYTE:return ap(t);default:throw new Error(`Unknown physical texture type ${n}`)}}(t,s);let i;if(r){const[u,c]=qn(n[0],n[1]);i=u*c}else{const[u,c]=Ts(n[0],n[1]);i=u*c}const o=function wA(n,t){if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(e,a);return i*o}function fp(n,t){if(n===ze.UPLOAD)return ye.PACKED_2X2_FLOAT32;if(n===ze.RENDER||null==n)return function TA(n){return(0,l.env)().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?ye.PACKED_2X2_FLOAT32:ye.UNPACKED_FLOAT32:n?ye.PACKED_2X2_FLOAT16:ye.UNPACKED_FLOAT16}(t);if(n===ze.DOWNLOAD||n===ze.PIXELS)return ye.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function mp(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Vt{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${e}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const ct="if (isnan(x)) return x;",kA="return x;",gp="return abs(x);",RA="return (x >= 0.0) ? x : (exp(x) - 1.0);",AA=ct+"\n  return (x < 0.0) ? 0.0 : x;\n",DA=ct+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",un="return x;",$A="return 1.0 / (1.0 + exp(-1.0 * x));",EA="return x;",_A="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",FA="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",OA="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",zA="return 1.0 / (1.0 + exp(-1.0 * x));";class cn{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${e}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class LA{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length);const e=t.length,s=Qe("rc",e),r=xe(e),a=function CA(n,t){if(1===n)return"rc";let e="";for(let s=0;s<n;s++)e+=t[s],s<n-1&&(e+=",");return e}(e,s),i=s.slice(-2),o=e<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${r} rc = getOutputCoords();\n        vec4 packedInput = getA(${a});\n\n        setOutput(getChannel(packedInput, ${o}));\n      }\n    `}}const PA=l.kernel_impls.whereImpl,Pr={},WA=(0,l.env)().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");let HA=(()=>{class n extends l.KernelBackend{nextDataId(){return n.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!(0,l.env)().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let s;if(null!=e){if(e instanceof Zi)s=e;else{const r=kt((0,l.env)().getNumber("WEBGL_VERSION"),e);s=new Zi(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=kt((0,l.env)().getNumber("WEBGL_VERSION"));s=new Zi(r),this.binaryCache=function MA(n){return n in Pr||(Pr[n]={}),Pr[n]}((0,l.env)().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=s,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new IA(this.gpgpu),this.numMBBeforeWarning=function UA(){return null==(0,l.env)().global.screen?1024:(0,l.env)().global.screen.height*(0,l.env)().global.screen.width*window.devicePixelRatio*600/1024/1024}(),this.texData=new l.DataStorage(this,(0,l.engine)())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,s,r,a,i,o){const u=this.makeTensorInfo(s,r),c=this.texData.get(u.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[a,i]},c.texShape=[a,i];const d=$r(s),p=new np(d,!1,o),h=this.runWebGLProgram(p,[u],r,[[a,i]]);return h.shape=s,c.texture=null,this.disposeIntermediateTensorInfo(u),h.dataId}write(e,s,r){if(((0,l.env)().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||(0,l.env)().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===r&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:s,dtype:r,values:e,usage:ze.UPLOAD,refCount:1}),a}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){this.texData.get(e).refCount++}decRef(e){this.texData.has(e)&&this.texData.get(e).refCount--}move(e,s,r,a,i){if((0,l.env)().getBool("DEBUG")&&this.checkNumericalProblems(s),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:a,values:s,usage:ze.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const s=this.texData.get(e),{values:r,dtype:a,complexTensorInfos:i,slice:o,shape:u,isPacked:c}=s;if(null!=o){let f;f=c?new cn(u,un):new Vt(u,un);const m=this.runWebGLProgram(f,[{dataId:e,shape:u,dtype:a}],a),y=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(null!=r)return this.convertAndCacheOnCPU(e);if("string"===a)return r;const d=null!=this.activeTimers;let p,h;if(d&&(p=l.util.now()),"complex64"===a){const f=this.readSync(i.real.dataId),m=this.readSync(i.imag.dataId);h=l.backend_util.mergeRealAndImagArrays(f,m)}else h=this.getValuesFromTexture(e);return d&&(this.downloadWaitMs+=l.util.now()-p),this.convertAndCacheOnCPU(e,h)}read(e){var s=this;return(0,J.Z)(function*(){if(s.pendingRead.has(e)){const g=s.pendingRead.get(e);return new Promise(x=>g.push(x))}const r=s.texData.get(e),{values:a,shape:i,slice:o,dtype:u,complexTensorInfos:c,isPacked:d}=r;if(null!=o){let g;g=d?new cn(i,un):new Vt(i,un);const x=s.runWebGLProgram(g,[{dataId:e,shape:i,dtype:u}],u),b=s.read(x.dataId);return s.disposeIntermediateTensorInfo(x),b}if(null!=a)return s.convertAndCacheOnCPU(e);if((0,l.env)().getBool("DEBUG")&&!(0,l.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===(0,l.env)().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let h,f,p=null;if("complex64"!==u&&(0,l.env)().get("WEBGL_BUFFER_SUPPORTED")){h=s.decode(e);const g=s.texData.get(h.dataId);p=s.gpgpu.createBufferFromTexture(g.texture.texture,...Rr(i))}if(s.pendingRead.set(e,[]),"complex64"!==u&&(yield s.gpgpu.createAndWaitForFence()),"complex64"===u){const g=yield Promise.all([s.read(c.real.dataId),s.read(c.imag.dataId)]);f=l.backend_util.mergeRealAndImagArrays(g[0],g[1])}else if(null==p)f=s.getValuesFromTexture(e);else{const g=l.util.sizeFromShape(i);f=s.gpgpu.downloadFloat32MatrixFromBuffer(p,g)}if(null!=h&&s.disposeIntermediateTensorInfo(h),null!=p){const g=s.gpgpu.gl;q(g,()=>g.deleteBuffer(p))}const m=s.convertAndCacheOnCPU(e,f),y=s.pendingRead.get(e);return s.pendingRead.delete(e),y.forEach(g=>g(m)),s.pendingDisposal.has(e)&&(s.pendingDisposal.delete(e),s.disposeData(e)&&(0,l.engine)().removeDataId(e,s),s.pendingDeletes--),m})()}readToGPU(e,s={}){const r=this.texData.get(e),{values:a,shape:i,slice:o,dtype:u,isPacked:c,texture:d}=r;if("complex64"===u)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=o){let m;m=c?new cn(i,un):new Vt(i,un);const y=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:u}],u),g=this.readToGPU(y,s);return this.disposeIntermediateTensorInfo(y),g}if(null==d)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const p=this.decode(e,s.customTexShape),h=(0,l.engine)().makeTensorFromTensorInfo(p),f=this.texData.get(p.dataId);return Object.assign({tensorRef:h},f.texture)}bufferSync(e){const s=this.readSync(e.dataId);if("string"===e.dtype)try{const r=s.map(a=>l.util.decodeString(a));return(0,l.buffer)(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return(0,l.buffer)(e.shape,e.dtype,s)}checkNumericalProblems(e){if(null!=e)for(let s=0;s<e.length;s++){const r=e[s];if(!qk(r))throw(0,l.env)().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:s,dtype:r,isPacked:a}=this.texData.get(e),i=l.util.sizeFromShape(s);if((0,l.env)().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),m=this.texData.get(f.dataId),y=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...Rr(s)).subarray(0,i);return this.disposeIntermediateTensorInfo(f),y}const o=(0,l.env)().getBool("WEBGL_PACK")&&!0===a,u=o?$r(s):s,c=o?new cR(u):new uR(u),d=this.runWebGLProgram(c,[{shape:u,dtype:r,dataId:e}],"float32"),p=this.texData.get(d.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(d),h}timerAvailable(){return(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){var s=this;const r=this.activeTimers,a=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=a,i=!0):this.activeTimers.push(a),this.activeTimers=a,e();const o=l.util.flatten(this.activeTimers.map(d=>d.query)).filter(d=>null!=d),u=l.util.flatten(this.activeTimers.map(d=>d.name)).filter(d=>null!=d);this.activeTimers=r,i&&(this.programTimersStack=null);const c={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(0,J.Z)(function*(){if((0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const d=yield Promise.all(o);c.kernelMs=l.util.sum(d),c.getExtraProfileInfo=()=>d.map((p,h)=>({name:u[h],ms:p})).map(p=>`${p.name}: ${p.ms}`).join(", ")}else c.kernelMs={error:"WebGL query timers are not supported in this environment."};return s.uploadWaitMs=0,s.downloadWaitMs=0,c})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:l.util.now(),endMs:null}}endTimer(e){return(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=l.util.now(),e)}getQueryTime(e){var s=this;return(0,J.Z)(function*(){return(0,l.env)().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?s.gpgpu.waitForQueryAndGetTime(e):e.endMs-e.startMs})()}disposeData(e,s=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(s?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!s&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return null!=r&&(this.disposeData(r.real.dataId,s),this.disposeData(r.imag.dataId,s)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:s,dtype:r,texShape:a,usage:i,isPacked:o,slice:u}=this.texData.get(e),c=u&&u.origDataId||e,d=this.dataRefCount.get(c);d>1?this.dataRefCount.set(c,d-1):(this.dataRefCount.delete(c),null!=s&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(s,a,i,o)));const p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,s=WA){return(0,l.env)().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>null==this.texData.get(r.dataId).texture&&l.util.sizeFromShape(r.shape)<s)}getGPGPUContext(){return this.gpgpu}where(e){l.backend_util.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const s=e.dataSync();return PA(e.shape,s)}packedUnaryOp(e,s,r){const a=new cn(e.shape,s),i=this.compileAndRun(a,[e],r);return(0,l.engine)().makeTensorFromTensorInfo(i)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const a=up(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,a)}if((0,l.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,gp,e.dtype);const s=new Vt(e.shape,gp),r=this.compileAndRun(s,[e]);return(0,l.engine)().makeTensorFromTensorInfo(r)}makeTensorInfo(e,s,r){let a;if("string"===s&&null!=r&&r.length>0&&l.util.isString(r[0])){const i=r.map(o=>l.util.encodeString(o));a=this.write(i,e,s)}else a=this.write(r,e,s);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:s}}makeOutput(e,s,r){return(0,l.engine)().makeTensorFromTensorInfo(this.makeTensorInfo(e,s,r),this)}unpackTensor(e){const s=new LA(e.shape);return this.runWebGLProgram(s,[e],e.dtype)}packTensor(e){const s=new vA(e.shape);return this.runWebGLProgram(s,[e],e.dtype,null,!0)}packedReshape(e,s){const r=[Zn(e.shape),...Yn(e.shape)],a={dtype:e.dtype,shape:r,dataId:e.dataId},i=[Zn(s),...Yn(s)],o=new pp(i,r),d=this.runWebGLProgram(o,[a],e.dtype,[r],!0);return{dataId:d.dataId,shape:s,dtype:d.dtype}}decode(e,s){const r=this.texData.get(e),{isPacked:a,shape:i,dtype:o}=r;if(null!=s){const f=l.util.sizeFromShape(i);l.util.assert(f<=s[0]*s[1]*4,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const u=$r(i);let c;c=a?new lR(u):new oR(u);const p=[s??Rr(u)];return{dtype:o,shape:i,dataId:this.runWebGLProgram(c,[{shape:u,dtype:o,dataId:e}],o,p,!0,s).dataId}}runWebGLProgram(e,s,r,a,i=!1,o){const u=this.makeTensorInfo(e.outputShape,r),c=this.texData.get(u.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Pt.DENSE){const b=o??Rr(e.outputShape);c.texShape=b.map(S=>2*S)}if(null!=e.outTexUsage&&(c.usage=e.outTexUsage),0===l.util.sizeFromShape(u.shape))return c.values=l.util.getTypedArrayFromDType(u.dtype,0),u;const d=[],p=s.map(b=>{if("complex64"===b.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let S=this.texData.get(b.dataId);if(null==S.texture){if(!e.packedInputs&&l.util.sizeFromShape(b.shape)<=(0,l.env)().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:S.values};e.packedInputs&&(S.isPacked=!0,S.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!S.isPacked!=!!e.packedInputs)b=S.isPacked?this.unpackTensor(b):this.packTensor(b),d.push(b),S=this.texData.get(b.dataId);else if(S.isPacked&&!_r(S.shape,b.shape)){const v=b,I=b.shape;b.shape=S.shape,b=this.packedReshape(b,I),d.push(b),S=this.texData.get(b.dataId),v.shape=I}return{shape:b.shape,texData:S,isUniform:!1}});this.uploadToGPU(u.dataId);const h={shape:u.shape,texData:c,isUniform:!1},f=function iR(n,t,e){let s="";t.concat(e).forEach(i=>{const o=null!=i.texData&&null!=i.texData.slice&&i.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!i.isUniform){const u=i.texData.texShape,{useSqueezeShape:c,uniformShape:d,keptDims:p}=qi(n.packedInputs,i.shape,u);let h="",f="",m="";if(1===d.length&&n.packedInputs){const I=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];h=`${I[0]>1}_${I[1]>1}`}else if(2!==d.length||n.packedInputs){if(d.length>2&&!n.packedInputs){const I=l.util.computeStrides(d);m=`${I[0]===u[1]}_${I[I.length-1]===u[1]}`}}else f=`${d[0]>1}_${d[1]>1}`;const y=i.shape.length,g=2===d.length&&l.util.arraysEqual(i.shape,u),x=1===l.util.sizeFromShape(i.shape),b=l.backend_util.getBroadcastDims(i.shape,e.shape),S=!n.packedInputs&&y===e.shape.length&&l.util.arraysEqual(u,e.texData.texShape);s+=`${y}_${S}_${c?p:""}_${d.length}_${x}_${b}_${g}_${h}_${f}_${m}_${n.packedInputs||d.length>2?"":`${u[0]>1}_${u[1]>1}`}_${o}`}else s+=`${i.shape}_${i.isUniform?"uniform":i.texData.texShape}_${o}`});let a=n.constructor.name;return a+="_"+s+"_"+n.userCode+`${(0,l.env)().getNumber("WEBGL_VERSION")}`,a}(e,p,h),m=this.getAndSaveBinary(f,()=>function rR(n,t,e,s){const r=e.map((d,p)=>{const h={logicalShape:d.shape,texShape:d.isUniform?null:d.texData.texShape,isUniform:d.isUniform,isPacked:!d.isUniform&&d.texData.isPacked,flatOffset:null};return null!=d.texData&&null!=d.texData.slice&&d.texData.slice.flatOffset>0&&(h.flatOffset=d.texData.slice.flatOffset),{name:t.variableNames[p],shapeInfo:h}}),a=r.map(d=>d.shapeInfo),i={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=S1(r,i,t),u=function Qk(n,t){const e=Ht(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(q(n,()=>n.shaderSource(e,t)),q(n,()=>n.compileShader(e)),(0,l.env)().get("ENGINE_COMPILE_ONLY"))return e;if(!1===n.getShaderParameter(e,n.COMPILE_STATUS))throw Hd(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}(n.gl,o),c=n.createProgram(u);return(0,l.env)().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(c),Object.assign({program:t,fragmentShader:u,source:o,webGLProgram:c,inShapeInfos:a,outShapeInfo:i},ep(n,t,c)))}(this.gpgpu,e,p,h)),y=null!=this.activeTimers;let g;y&&(g=this.startTimer()),(0,l.env)().get("ENGINE_COMPILE_ONLY")||function aR(n,t,e,s,r){t.program.enableShapeUniforms||(tp(t.inShapeInfos,e),tp([t.outShapeInfo],[s]));const a=s.texData.texture,i=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):n.setOutputMatrixTexture(a.texture,i[0],i[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),1===(0,l.env)().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&n.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&n.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<e.length;++u){const c=e[u],{uniform:d,offset:p,shape:h,texShape:f}=t.variablesLocations[u];if(h){const{uniformShape:m}=qi(t.program.packedInputs,c.shape,c.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(h,new Int32Array(m));break;case 2:n.gl.uniform2iv(h,new Int32Array(m));break;case 3:n.gl.uniform3iv(h,new Int32Array(m));break;case 4:n.gl.uniform4iv(h,new Int32Array(m))}}if(f&&n.gl.uniform2i(f,c.texData.texShape[0],c.texData.texShape[1]),null!=d){if(c.isUniform){if(l.util.sizeFromShape(c.shape)<2)n.gl.uniform1f(d,c.uniformValues[0]);else{let m=c.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}continue}null!=c.texData.slice&&null!=p&&n.gl.uniform1i(p,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture.texture,d,u)}}const o=t.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape))}if(t.outShapeStridesLocation){const u=l.util.computeStrides(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u))}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let u=0;u<t.program.customUniforms.length;++u){const c=t.program.customUniforms[u],d=t.customUniformLocations[u],p=r[u];if("float"===c.type)n.gl.uniform1fv(d,p);else if("vec2"===c.type)n.gl.uniform2fv(d,p);else if("vec3"===c.type)n.gl.uniform3fv(d,p);else if("vec4"===c.type)n.gl.uniform4fv(d,p);else if("int"===c.type)n.gl.uniform1iv(d,p);else if("ivec2"===c.type)n.gl.uniform2iv(d,p);else if("ivec3"===c.type)n.gl.uniform3iv(d,p);else{if("ivec4"!==c.type)throw Error(`uniform type ${c.type} is not supported yet.`);n.gl.uniform4iv(d,p)}}n.executeProgram()}(this.gpgpu,m,p,h,a),d.forEach(b=>this.disposeIntermediateTensorInfo(b)),y&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const x=(0,l.env)().get("WEBGL_FLUSH_THRESHOLD");if(x>0){const b=l.util.now();b-this.lastGlFlushTime>x&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!(0,l.env)().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&!1===i){const b=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),b}return u}compileAndRun(e,s,r,a,i=!1){return this.runWebGLProgram(e,s,r=r||s[0].dtype,a,i)}getAndSaveBinary(e,s){return e in this.binaryCache||(this.binaryCache[e]=s()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||((0,l.env)().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(s=>{this.gpgpu.deleteProgram(this.binaryCache[s].webGLProgram),delete this.binaryCache[s]}),this.textureManager.dispose(),null!=this.canvas&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=(0,l.tidy)(()=>{if(!(0,l.env)().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=(0,l.env)().getBool("DEBUG");(0,l.env)().set("DEBUG",!1);const s=this.abs((0,l.scalar)(1e-8)).dataSync()[0];if((0,l.env)().set("DEBUG",e),s>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const s=this.texData.get(e),{shape:r,dtype:a,values:i,texture:o,usage:u,isPacked:c}=s;if(null!=o)return;const d=null!=this.activeTimers;let p;d&&(p=l.util.now());let h=s.texShape;if(null==h&&(h=function p1(n,t=!1){let e=(0,l.env)().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=(0,l.env)().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&(0,l.env)().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=e/2),t&&(e*=2,s*=2,1===(n=n.map((o,u)=>u>=n.length-2?l.util.nearestLargerEven(n[u]):n[u])).length&&(n=[2,n[0]])),2!==n.length&&(n=l.util.squeezeShape(n).newShape);let r=l.util.sizeFromShape(n),a=null;n.length<=1&&r<=e?a=[1,r]:2===n.length&&n[0]<=e&&n[1]<=e?a=n:3===n.length&&n[0]*n[1]<=e&&n[2]<=e?a=[n[0]*n[1],n[2]]:3===n.length&&n[0]<=e&&n[1]*n[2]<=e?a=[n[0],n[1]*n[2]]:4===n.length&&n[0]*n[1]*n[2]<=e&&n[3]<=e?a=[n[0]*n[1]*n[2],n[3]]:4===n.length&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(a=[n[0],n[1]*n[2]*n[3]]);const i=null!=a&&Math.max(...a)>s&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(null==a||i)if(t){const o=Zn(n);let u=2,c=2;n.length&&([u,c]=Yn(n)),r=o*(u/2)*(c/2),a=l.util.sizeToSquarishShape(r).map(d=>2*d)}else a=l.util.sizeToSquarishShape(r);return a}(r,c),s.texShape=h),null!=i){const f=$r(r);let m,y=h[1],g=h[0];const x=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(c||!x)&&([y,g]=qn(h[0],h[1])),m=c?new pR(f,x):new np(f,x);const b=x?[g,y]:h,S=this.makeTensorInfo(b,a),v=this.texData.get(S.dataId);v.usage=x?ze.PIXELS:ze.UPLOAD,v.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(S.dataId),y,g,i);const N=this.runWebGLProgram(m,[S],a,[[g,y]],!0),T=this.texData.get(N.dataId);s.texShape=T.texShape,s.isPacked=T.isPacked,s.usage=T.usage,(0,l.env)().get("ENGINE_COMPILE_ONLY")?this.disposeData(N.dataId):(s.texture=T.texture,s.values=null,this.texData.delete(N.dataId)),this.disposeIntermediateTensorInfo(S),d&&(this.uploadWaitMs+=l.util.now()-p)}else{const f=this.acquireTexture(h,u,a,c);s.texture=f}}convertAndCacheOnCPU(e,s){const r=this.texData.get(e),{dtype:a}=r;return null!=s&&(r.values=function jA(n,t){if("float32"===t||"complex64"===t)return n;if("int32"===t||"bool"===t){const e="int32"===t?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<e.length;++s)e[s]=Math.round(n[s]);return e}throw new Error(`Unknown dtype ${t}`)}(s,a)),r.values}acquireTexture(e,s,r,a){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,s,a)}computeBytes(e,s){return e[0]*e[1]*l.util.bytesPerElement(s)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}checkCompileCompletionAsync(){var e=this;return(0,J.Z)(function*(){const s=[];if(e.gpgpu.parallelCompilationExtension){for(const[,r]of Object.entries(e.binaryCache))s.push(e.checkCompletionAsync_(r));return Promise.all(s)}for(const[,r]of Object.entries(e.binaryCache)){const a=new Promise(i=>{try{e.checkCompletion_(r),i(!0)}catch(o){throw o}});s.push(a)}return Promise.all(s)})()}checkCompletionAsync_(e){var s=this;return(0,J.Z)(function*(){return s.gpgpu.gl.getProgramParameter(e.webGLProgram,s.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?s.checkCompletion_(e):(yield(0,l.nextFrame)(),s.checkCompletionAsync_(e))})()}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS))throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)?(Hd(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:s,customUniformLocations:r,infLoc:a,nanLoc:i,outShapeLocation:o,outShapeStridesLocation:u,outTexShapeLocation:c}=ep(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=s,e.customUniformLocations=r,e.infLoc=a,e.nanLoc=i,e.outShapeLocation=o,e.outShapeStridesLocation=u,e.outTexShapeLocation=c}}createTensorFromGPUData(e,s,r){e.channels=e.channels||"RGBA";const{texture:a,height:i,width:o,channels:u}=e,c=(0,l.engine)().backend;if(!c.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const d=c.writeTexture(a,s,r,i,o,u);return(0,l.engine)().makeTensorFromDataId(d,s,r,c)}}return n.nextDataId=0,n})();l.device_util.isBrowser()&&(0,l.registerBackend)("webgl",()=>new HA,2);const Qi="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class ns{constructor(t,e,s){this.variableNames=["A","B"],this.outputShape=l.backend_util.assertAndGetBroadcastShape(e,s),this.enableShapeUniforms=Ze(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${t}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const _n="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class As{constructor(t,e,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=l.backend_util.assertAndGetBroadcastShape(e,s);const a=this.outputShape.length;this.enableShapeUniforms=Ze(a);let i="";if(r)if(0===a||1===l.util.sizeFromShape(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else if(i=`\n          ${xe(a)} coords = getOutputCoords();\n        `,1===a)i+=this.enableShapeUniforms?"\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const u=Qe("coords",a);i+=this.enableShapeUniforms?`\n            bool nextRowOutOfBounds =\n              (${u[a-2]} + 1) >= outShape[${a} - 2];\n            bool nextColOutOfBounds =\n              (${u[a-1]} + 1) >= outShape[${a} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:`\n            bool nextRowOutOfBounds =\n              (${u[a-2]} + 1) >= ${this.outputShape[a-2]};\n            bool nextColOutOfBounds =\n              (${u[a-1]} + 1) >= ${this.outputShape[a-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${t}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function at(n){const{inputs:t,backend:e}=n,{x:s}=t;return e.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const qA={kernelName:l.Identity,backendName:"webgl",kernelFunc:at};function dn(n){const{inputs:t,backend:e}=n,{real:s,imag:r}=t,a=e.makeTensorInfo(s.shape,"complex64"),i=e.texData.get(a.dataId),o=at({inputs:{x:s},backend:e}),u=at({inputs:{x:r},backend:e});return i.complexTensorInfos={real:o,imag:u},a}const ZA={kernelName:l.Complex,backendName:"webgl",kernelFunc:dn},yp="return (a < 0.) ? b * a : a;",xp="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",QA={kernelName:l.LeakyRelu,backendName:"webgl",kernelFunc:function YA(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{alpha:a}=s,i=e.makeTensorInfo([],"float32",l.util.createScalarValue(a,"float32")),o=(0,l.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new As(xp,r.shape,i.shape):new ns(yp,r.shape,i.shape),u=e.runWebGLProgram(o,[r,i],"float32");return e.disposeIntermediateTensorInfo(i),u}},bp="return (a < 0.) ? b * a : a;",Cp="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n",e2={kernelName:l.Prelu,backendName:"webgl",kernelFunc:function JA(n){const{inputs:t,backend:e}=n,{x:s,alpha:r}=t,a=(0,l.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new As(Cp,s.shape,r.shape):new ns(bp,s.shape,r.shape);return e.runWebGLProgram(a,[s,r],"float32")}},ss="if (isnan(x)) return x;";function pe({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:s}){return({inputs:r,backend:a})=>{const{x:i}=r,o=a,u=s||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=e){const p=o.texData.get(i.dataId),h=e(p.values,u);return o.makeTensorInfo(i.shape,u,h)}let d;return d=(0,l.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=t?new cn(i.shape,t):new Vt(i.shape,n),o.runWebGLProgram(d,[i],u)}}function je({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:i,backend:o})=>{const{a:u,b:c}=i,d=o;if(s&&"complex64"===u.dtype){const m=d.texData.get(u.dataId),y=d.texData.get(c.dataId),[g,x]=[[m.complexTensorInfos.real,y.complexTensorInfos.real],[m.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(S=>{const[v,I]=S,w={dataId:v.dataId,dtype:v.dtype,shape:u.shape},N={dataId:I.dataId,dtype:I.dtype,shape:c.shape},T=new ns(n,u.shape,c.shape);return d.runWebGLProgram(T,[w,N],(0,l.upcastType)(v.dtype,I.dtype))}),b=dn({inputs:{real:g,imag:x},backend:d});return d.disposeIntermediateTensorInfo(g),d.disposeIntermediateTensorInfo(x),b}const p=a||(0,l.upcastType)(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||d.shouldExecuteOnCPU([u,c]))&&null!=r){const m=d.texData.get(u.dataId).values,y=d.texData.get(c.dataId).values,g="string"===u.dtype?l.backend_util.fromUint8ToStringArray(m):m,x="string"===u.dtype?l.backend_util.fromUint8ToStringArray(y):y,[b,S]=r(u.shape,c.shape,g,x,p),v=d.makeTensorInfo(S,p);return d.texData.get(v.dataId).values=b,v}let f;return f=(0,l.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=t?new As(t,u.shape,c.shape,e):new ns(n,u.shape,c.shape),d.runWebGLProgram(f,[u,c],p)}}function Ds(n,t=!1){if("linear"===n)return t?EA:kA;if("relu"===n)return t?FA:AA;if("elu"===n)return t?_A:RA;if("relu6"===n)return t?OA:DA;if("prelu"===n)return t?Cp:bp;if("leakyrelu"===n)return t?xp:yp;if("sigmoid"===n)return t?zA:$A;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class vp{constructor(t,e,s,r=!1,a=!1,i=!1,o=null,u=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Ze(this.outputShape.length);const p=Math.ceil((r?t[1]:t[2])/2),h=r?"i * 2, rc.y":"rc.y, i * 2",f=a?"rc.z, i * 2":"i * 2, rc.z",m=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",x="";o&&(g=u?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${o}\n        }`:c?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${o}\n        }`:`vec4 activation(vec4 x) {\n          ${o}\n        }`,x="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let S="rc.x",v="rc.x";t[0]<e[0]?S=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(v=`imod(rc.x, ${e[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${p}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${S};\n        int batchB = ${v};\n        for (int i = 0; i < ${p}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${f});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${m[0]} * ${y[0]});\n          result += (${m[1]} * ${y[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${x}\n\n        setOutput(result);\n      }\n    `}}const Sp={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Ip{constructor(t,e,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=l.backend_util.assertAndGetBroadcastShape(e,s),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${t}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const wp="return a * b;";function Ji(n){const{inputs:t,backend:e}=n,{a:s,b:r}=t,a=l.backend_util.upcastType(s.dtype,r.dtype);if("complex64"===s.dtype){const o=e.texData.get(s.dataId),u=e.texData.get(r.dataId),c=new Ip(Sp.REAL,s.shape,r.shape),d=new Ip(Sp.IMAG,s.shape,r.shape),p=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:r.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:r.shape}],h=e.runWebGLProgram(c,p,"float32"),f=e.runWebGLProgram(d,p,"float32"),m=dn({inputs:{real:h,imag:f},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),m}if(e.shouldExecuteOnCPU([s,r])){const o=e.texData.get(s.dataId),u=e.texData.get(r.dataId),[c,d]=ZR(s.shape,r.shape,o.values,u.values,a),p=e.makeTensorInfo(d,a);return e.texData.get(p.dataId).values=c,p}let i;return i=(0,l.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new As(wp,s.shape,r.shape):new ns(wp,s.shape,r.shape),e.runWebGLProgram(i,[s,r],a)}const t2={kernelName:l.Multiply,backendName:"webgl",kernelFunc:Ji};function K(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{shape:a}=s,i=e,o=l.util.sizeFromShape(r.shape),u=l.util.inferFromImplicitShape(a,o),c=l.util.sizeFromShape(u);l.util.assert(o===c,()=>`The new shape (${u}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const d=i.texData.get(r.dataId);return!d.isPacked||_r(r.shape,u)||null!==d.texture&&_r(d.shape,u)?(i.incRef(r.dataId),{dataId:r.dataId,shape:u,dtype:r.dtype}):function n2(n,t,e){const s=[Zn(n.shape),...Yn(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},a=[Zn(t),...Yn(t)],i=new pp(a,s),c=e.runWebGLProgram(i,[r],n.dtype,[s],!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,u,i)}const s2={kernelName:l.Reshape,backendName:"webgl",kernelFunc:K};class Np{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=t;this.outputShape=[r,i];const o=4*Math.floor(s/4),u=s%4;let c="sumValue += dot(values, ones);";if(null!=e){const p=1/e;c=`sumValue += dot(values * ${l.util.isInt(p)?p.toPrecision(2):p}, ones);`}let d="";a%s>0&&(d=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${d}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${c}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===u}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${c}\n        } else if (${2===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${c}\n        } else if (${3===u}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${c}\n        }\n        setOutput(sumValue);\n      }\n    `}}class r2{constructor(t,e){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:i}=t;this.outputShape=[r,i];let o="0.0",u="";"prod"===e?o="1.0":"min"===e?(o="1.0 / 1e-20",u="min"):"max"===e&&(o="-1.0 / 1e-20",u="max");let c=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===e?c="sumValue":"prod"===e?c="prodValue":"all"===e?c="allValue":"any"===e&&(c="anyValue");const d=4*Math.floor(s/4),p=s%4;let h=`\n      if (${"sum"===e}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===e}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${u}(values, minMaxValue);\n        if (${"min"===e} || ${"max"===e}) {\n          minMaxValue = ${u}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,f="vec4";"all"===e?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",f="bvec4"):"any"===e&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",f="bvec4");let m="";a%s>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${o};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${m}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        vec4 minMaxValue = vec4(${o});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===p}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===p}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===p}) {\n          ${f} values = ${f}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${c});\n      }\n    `}}function Fn(n,t,e,s){const r=function a2(n){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const e=t.length?t[t.length-1].outSize:n[1],s=l.backend_util.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:s,outSize:Math.ceil(e/s)})}return t}(n.shape);let a=n;for(let i=0;i<r.length;i++){const{inSize:o,windowSize:u,outSize:c}=r[i];let d,p;d="mean"===e?0===i?new Np({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:c},o):new Np({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:c}):new r2({windowSize:u,inSize:o,batchSize:n.shape[0],outSize:c},e),p=a,a=s.runWebGLProgram(d,[a],t),p.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(p)}return a}class i2{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[e[i]];this.outputShape=s,this.rank=s.length;const r=xe(this.rank),a=function o2(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<n.length;r++)s[n[r]]=e[r];return s.join()}(e);this.userCode=`\n    void main() {\n      ${r} resRC = getOutputCoords();\n      setOutput(getA(${a}));\n    }\n    `}}class l2{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(t.length);for(let d=0;d<s.length;d++)s[d]=t[e[d]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=xe(this.rank),a=dp("rc",this.rank),i=new Array(this.rank);for(let d=0;d<e.length;d++)i[e[d]]=a[d];const o=`vec2(${i.slice(-2).join()})`,u=`++${a[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`\n    void main() {\n      ${r} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${c};\n      if(${u}) {\n        result[1] = ${c};\n      }\n      --${a[this.rank-1]};\n      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {\n        result[2] = ${c};\n        if(${u}) {\n          result[3] = ${c};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function Vr(n,t,e){const s=(0,l.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new l2(n.shape,t):new i2(n.shape,t);return e.runWebGLProgram(s,[n],n.dtype)}function Br(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s;return function u2(n,t,e,s){const a=n.shape.length,i=l.util.parseAxisParam(t,n.shape);let o=i;const u=l.backend_util.getAxesPermutation(o,a),c=null!=u;let d=n;c&&(d=Vr(n,u,s),o=l.backend_util.getInnerMostAxes(o.length,a)),l.backend_util.assertAxesAreInnerMostDims("sum",o,a);const[p,h]=l.backend_util.computeOutAndReduceShapes(d.shape,o);let f=p;e&&(f=l.backend_util.expandShapeToKeepDim(p,i));const m=l.util.sizeFromShape(h),x=K({inputs:{x:d},attrs:{shape:[l.util.sizeFromShape(n.shape)/m,m]},backend:s}),S=Fn(x,(0,l.sumOutType)(n.dtype),"sum",s),v=K({inputs:{x:S},attrs:{shape:f},backend:s});return s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(S),c&&s.disposeIntermediateTensorInfo(d),v}(r,a,i,e)}const c2={kernelName:l.Sum,backendName:"webgl",kernelFunc:Br};function Je(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{perm:a}=s,i=e,u=new Array(r.shape.length);for(let d=0;d<u.length;d++)u[d]=r.shape[a[d]];let c;if(i.shouldExecuteOnCPU([r])){const p=i.texData.get(r.dataId).values,h=Yi(p,r.shape,r.dtype,a,u);c=i.makeTensorInfo(u,r.dtype),i.texData.get(c.dataId).values=h}else c=Vr(r,a,i);return c}const d2={kernelName:l.Transpose,backendName:"webgl",kernelFunc:Je},Tp=1e3;function Mr({a:n,b:t,transposeA:e,transposeB:s,backend:r,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}){const c=n.shape.length,d=t.shape.length,p=e?n.shape[c-2]:n.shape[c-1],h=s?t.shape[d-1]:t.shape[d-2],f=e?n.shape[c-1]:n.shape[c-2],m=s?t.shape[d-2]:t.shape[d-1],y=n.shape.slice(0,-2),g=t.shape.slice(0,-2),x=l.util.sizeFromShape(y),b=l.util.sizeFromShape(g),v=l.broadcast_util.assertAndGetBroadcastShape(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);l.util.assert(p===h,()=>`Error in matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${s} must match.`);const I=e?[x,p,f]:[x,f,p],w=s?[b,m,h]:[b,h,m],N=K({inputs:{x:n},backend:r,attrs:{shape:I}}),T=K({inputs:{x:t},backend:r,attrs:{shape:w}}),D=[N,T],A=Math.max(x,b),$=e?N.shape[1]:N.shape[2],F=null!=a,O=null!=i,L="leakyrelu"===u,z=null!=u?Ds(u,!0):null;let B;if((1===f||1===m)&&$>Tp&&!1===(F||O||L||null!=z)){let V=N,G=T;e&&(V=Je({inputs:{x:N},backend:r,attrs:{perm:[0,2,1]}}),D.push(V)),s&&(G=Je({inputs:{x:T},backend:r,attrs:{perm:[0,2,1]}}),D.push(G));const j=1===m;let H=V;1!==m&&(H=K({inputs:{x:V},backend:r,attrs:{shape:[A,$,1]}}),D.push(H));const Z=1===m?2:1;let X=G;j&&(X=K({inputs:{x:G},backend:r,attrs:{shape:[A,1,$]}}),D.push(X));const Q=Ji({inputs:{a:H,b:X},backend:r});B=Br({inputs:{x:Q},backend:r,attrs:{axis:Z,keepDims:!0}}),D.push(Q)}else{const V=(0,l.upcastType)(n.dtype,t.dtype),G=new vp(I,w,[A,f,m],e,s,F,z,O,L),U=[N,T];if(null!=a&&U.push(a),O&&U.push(i),L){const j=r.makeTensorInfo([],"float32",l.util.createScalarValue(o,"float32"));U.push(j),D.push(j)}B=r.runWebGLProgram(G,U,V)}const _=K({inputs:{x:B},backend:r,attrs:{shape:v}});D.push(B);for(const V of D)r.disposeIntermediateTensorInfo(V);return _}const h2={kernelName:l._FusedMatMul,backendName:"webgl",kernelFunc:function p2(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:c,activation:d,leakyreluAlpha:p}=s;return Mr({a:r,b:a,transposeA:u,transposeB:c,backend:e,bias:i,preluActivationWeights:o,leakyreluAlpha:p,activation:d})}},kp="return abs(x);",m2={kernelName:l.Abs,backendName:"webgl",kernelFunc:function f2(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const a=e.texData.get(s.dataId),i=up(a.values);return e.makeTensorInfo(s.shape,s.dtype,i)}let r;return r=(0,l.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cn(s.shape,kp):new Vt(s.shape,kp),e.runWebGLProgram(r,[s],s.dtype)}},y2=pe({opSnippet:ct+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),x2={kernelName:l.Acos,backendName:"webgl",kernelFunc:y2},C2=pe({opSnippet:ct+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),v2={kernelName:l.Acosh,backendName:"webgl",kernelFunc:C2},Rp="return a + b;",S2=je({opSnippet:Rp,packedOpSnippet:Rp,supportsComplex:!0,cpuKernelImpl:DR}),I2={kernelName:l.Add,backendName:"webgl",kernelFunc:S2};class w2{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        float result = ${r};\n        setOutput(result);\n      }\n    `}}class N2{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((a,i)=>`T${i}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`\n      void main() {\n        ${s.join("\n        ")}\n\n        vec4 result = ${r};\n        setOutput(result);\n      }\n    `}}const T2={kernelName:l.AddN,backendName:"webgl",kernelFunc:function Wr(n){const{inputs:t,backend:e}=n,s=t;if(1===s.length)return at({inputs:{x:s[0]},backend:e});if(s.length>(0,l.env)().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(s.length/2),c=Wr({inputs:s.slice(0,u),backend:e}),d=Wr({inputs:s.slice(u),backend:e});return Wr({inputs:[c,d],backend:e})}const r=s.map(u=>u.dtype).reduce((u,c)=>(0,l.upcastType)(u,c)),a=s.map(u=>u.shape),o=(0,l.env)().getBool("WEBGL_PACK")?new N2(s[0].shape,a):new w2(s[0].shape,a);return e.runWebGLProgram(o,s,r)}},R2={kernelName:l.All,backendName:"webgl",kernelFunc:function k2(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=l.util.parseAxisParam(a,r.shape);let c=u;const d=l.backend_util.getAxesPermutation(c,o);let p=r;null!=d&&(p=Je({inputs:{x:r},backend:e,attrs:{perm:d}}),c=l.backend_util.getInnerMostAxes(c.length,o)),l.backend_util.assertAxesAreInnerMostDims("all",c,o);const[h,f]=l.backend_util.computeOutAndReduceShapes(p.shape,c),y=K({inputs:{x:p},backend:e,attrs:{shape:[-1,l.util.sizeFromShape(f)]}}),g=Fn(y,y.dtype,"all",e);let x;return x=K(i?{inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(h,u)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),null!=d&&e.disposeIntermediateTensorInfo(p),x}},D2={kernelName:l.Any,backendName:"webgl",kernelFunc:function A2(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=l.util.parseAxisParam(a,r.shape);let c=u;const d=l.backend_util.getAxesPermutation(c,o);let p=r;null!=d&&(p=Je({inputs:{x:r},backend:e,attrs:{perm:d}}),c=l.backend_util.getInnerMostAxes(c.length,o)),l.backend_util.assertAxesAreInnerMostDims("any",c,o);const[h,f]=l.backend_util.computeOutAndReduceShapes(p.shape,c),y=K({inputs:{x:p},backend:e,attrs:{shape:[-1,l.util.sizeFromShape(f)]}}),g=Fn(y,y.dtype,"any",e);let x;return x=K(i?{inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(h,u)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),null!=d&&e.disposeIntermediateTensorInfo(p),x}};class $2{constructor(t,e,s){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:i}=t;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${r};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${r}; i++) {\n          int inIdx = ${s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));"};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${"max"===e?">":"<"} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class E2{constructor(t,e,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,l.util.assert(t.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=Math.ceil(t[t.length-1]/e);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),r||this.variableNames.push("bestIndicesA");const o=this.outputShape,u=o.length,c=xe(u),d=Qe("coords",u);let p,h;if(1===i){h=u+1;const T=xe(h);p=`\n        ${T} sourceLocR = ${T}(${d.join()}, 0);\n        ++${d[u-1]};\n        ${T} sourceLocG = ${T}(${d.join()}, 0);\n        ++${d[u-2]};\n        ${T} sourceLocA = ${T}(${d.join()}, 0);\n        --${d[u-1]};\n        ${T} sourceLocB = ${T}(${d.join()}, 0);\n        --${d[u-2]};`}else h=u,p=`\n        ${c} sourceLocR = coords;\n        ++${d[u-1]};\n        ${c} sourceLocG = coords;\n        ++${d[u-2]};\n        ${c} sourceLocA = coords;\n        --${d[u-1]};\n        ${c} sourceLocB = coords;\n        --${d[u-2]};`;const f=["x","y","z","w","u","v"].slice(0,h),m="."+f[h-1],y=f.map(T=>"int "+T),g=Qe("sourceLocR",h-1).concat("inIdx.r"),x=Qe("sourceLocG",h-1).concat("inIdx.g"),b=Qe("sourceLocB",h-1).concat("inIdx.b"),S=Qe("sourceLocA",h-1).concat("inIdx.a"),v="max"===s?"greaterThan":"lessThan",I=r?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${x.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${S.join()})));`,w=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${x.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,N=r?"":`\n      float getBestIndicesAChannel(${y.join()}) {\n        return getChannel(getBestIndicesA(${f.join()}),\n                                          vec2(${f.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${y.join()}) {\n        return getChannel(getA(${f.join()}),\n                               vec2(${f.slice(-2).join()}));\n      }\n      ${N}\n      void main() {\n        ${c} coords = getOutputCoords();\n        bool hasNextCol = ${d[u-1]} < ${o[u-1]-1};\n        bool hasNextRow = ${d[u-2]} < ${o[u-2]-1};\n        ${p}\n        ivec4 srcIdx = ivec4(sourceLocR${m}, sourceLocG${m},\n          sourceLocB${m}, sourceLocA${m}) * ${e};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${e}; i++) {\n          inIdx = srcIdx;\n          ${I}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function Ap(n,t,e,s=null){let r=t.shape[0],a=t.shape[1];null!=s&&(r=s.shape[0],a=s.shape[1]);const i=l.backend_util.computeOptimalWindowSize(a),o={windowSize:i,inSize:a,batchSize:r,outSize:Math.ceil(a/i)},u=new $2(o,e,null==s),c=[t];null!=s&&c.push(s);const d=n.runWebGLProgram(u,c,"int32");if(1===d.shape[1])return d;const p=Ap(n,t,e,d);return n.disposeIntermediateTensorInfo(d),p}function Dp(n,t,e,s=null){const r=null!=s?s.shape:t.shape,i=l.backend_util.computeOptimalWindowSize(r[r.length-1]),o=new E2(r,i,e,null==s),c=n.runWebGLProgram(o,null==s?[t]:[t,s],"int32");if(c.shape.length===t.shape.length){const d=Dp(n,t,e,c);return n.disposeIntermediateTensorInfo(c),d}return c}function $p(n,t,e,s){const r=[e];if(l.backend_util.assertAxesAreInnerMostDims("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!(0,l.env)().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],i=n.texData.get(t.dataId);let u=t;null!==i&&i.isPacked&&(u=n.unpackTensor(t),a.push(u));const[c,d]=l.backend_util.computeOutAndReduceShapes(u.shape,r),p=l.util.sizeFromShape(d),h=K({inputs:{x:u},backend:n,attrs:{shape:[-1,p]}});a.push(h);const f=Ap(n,h,s);a.push(f);const m=K({inputs:{x:f},backend:n,attrs:{shape:c}});return a.forEach(y=>n.disposeIntermediateTensorInfo(y)),m}return Dp(n,t,s)}const F2={kernelName:l.ArgMax,backendName:"webgl",kernelFunc:function _2(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;let i=l.util.parseAxisParam(a,r.shape);const o=l.backend_util.getAxesPermutation(i,r.shape.length);let u=r;const c=[];null!=o&&(u=Je({inputs:{x:r},backend:e,attrs:{perm:o}}),c.push(u),i=l.backend_util.getInnerMostAxes(i.length,u.shape.length)),l.backend_util.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);const d=$p(e,u,i[0],"max");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}},z2={kernelName:l.ArgMin,backendName:"webgl",kernelFunc:function O2(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a}=s;let i=l.util.parseAxisParam(a,r.shape);const o=l.backend_util.getAxesPermutation(i,r.shape.length);let u=r;const c=[];null!=o&&(u=Je({inputs:{x:r},backend:e,attrs:{perm:o}}),c.push(u),i=l.backend_util.getInnerMostAxes(i.length,u.shape.length)),l.backend_util.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);const d=$p(e,u,i[0],"min");return c.forEach(p=>e.disposeIntermediateTensorInfo(p)),d}},P2=pe({opSnippet:ct+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),V2={kernelName:l.Asin,backendName:"webgl",kernelFunc:P2},M2=pe({opSnippet:ct+"return log(x + sqrt(x * x + 1.0));"}),W2={kernelName:l.Asinh,backendName:"webgl",kernelFunc:M2},U2=pe({opSnippet:ct+"\n  return atan(x);\n"}),H2={kernelName:l.Atan,backendName:"webgl",kernelFunc:U2},K2=je({opSnippet:Qi+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+_n+"\n  return result;\n"}),q2={kernelName:l.Atan2,backendName:"webgl",kernelFunc:K2},Y2=pe({opSnippet:ct+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),Q2={kernelName:l.Atanh,backendName:"webgl",kernelFunc:Y2};class $s{constructor(t,e,s,r=!1,a=!1){if(this.variableNames=["x"],"avg"===e&&s)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,p=t.effectiveFilterHeight,h=t.effectiveFilterWidth,f=t.padInfo.top,m=t.padInfo.left;this.outputShape=t.outShape;const y="avg"===e;let b="0.0";if(y||(b="-1.0 / 1e-20"),s)return void(this.userCode=`\n        const ivec2 strides = ivec2(${o}, ${u});\n        const ivec2 pads = ivec2(${f}, ${m});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${p};\n              wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${d}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value >= currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${r?a?`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`:`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let v=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(v="avgValue / max(count, 1.0)");const I=4*Math.floor(i/4),w=i%4,N=`\n      if (${y}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${o}, ${u});\n      const ivec2 pads = ivec2(${f}, ${m});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${I}; wC += 4) {\n            int xC = xCCorner + wC * ${d};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              getValue(batch, xR, xC + 3 * ${d}, d)\n            );\n\n            ${N}\n          }\n\n          int xC = xCCorner + ${I};\n          if (${1===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${N}\n          } else if (${2===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${N}\n          } else if (${3===w}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${d}, d),\n              getValue(batch, xR, xC + 2 * ${d}, d),\n              initializationValue\n            );\n\n            ${N}\n          }\n        }\n        setOutput(${v});\n      }\n    `}}class eo{constructor(t,e,s,r=!1,a=!1){if(this.variableNames=["x"],"avg"===e&&s)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,u=t.strideHeight,c=t.strideWidth,d=t.dilationDepth,p=t.dilationHeight,h=t.dilationWidth,f=t.effectiveFilterDepth,m=t.effectiveFilterHeight,y=t.effectiveFilterWidth,g=t.padInfo.front,x=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const S="avg"===e;let v="0.0";if(S||(v="-1.0 / 1e-20"),s)return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${o}, ${u}, ${c});\n        const ivec3 pads = ivec3(${g}, ${x}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${f};\n              wD += ${d}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${m};\n                wR += ${p}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${y};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value >= currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${r?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${m} * ${y} +\n                      wR * ${y} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `);let w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===e&&(w="avgValue / max(count, 1.0)");const N=4*Math.floor(i/4),T=i%4,D=`\n      if (${S}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${o}, ${u}, ${c});\n      const ivec3 pads = ivec3(${g}, ${x}, ${b});\n      const float initializationValue = ${v};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${t.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${v});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${f};\n            wD += ${d}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${m};\n            wR += ${p}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${N}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${D}\n            }\n\n            int xC = xCCorner + ${N};\n            if (${1===T}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${D}\n            } else if (${2===T}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${D}\n            } else if (${3===T}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${D}\n            }\n          }\n        }\n        setOutput(${w});\n      }\n    `}}const eD={kernelName:l.AvgPool,backendName:"webgl",kernelFunc:function J2(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;ks(r,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const d=l.backend_util.computePool2DInfo(r.shape,a,i,1,o,u);if(1===d.filterWidth&&1===d.filterHeight&&l.util.arraysEqual(d.inShape,d.outShape))return at({inputs:{x:r},backend:e});const p=new $s(d,"avg",!1);return e.runWebGLProgram(p,[r],"float32")}},nD={kernelName:l.AvgPool3D,backendName:"webgl",kernelFunc:function tD(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u,dataFormat:c}=s,p=l.backend_util.computePool3DInfo(r.shape,a,i,[1,1,1],o,u,c),h=new eo(p,"avg",!1);return e.runWebGLProgram(h,[r],"float32")}};class sD{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const u=t.effectiveFilterHeight,c=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${u-1-t.padInfo.top}, ${c-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${u};\n            wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${c};\n            wC+= ${t.dilationWidth}) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class rD{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const p=t.effectiveFilterDepth,h=t.effectiveFilterHeight,f=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${p-1-t.padInfo.front}, ${h-1-t.padInfo.top}, ${f-1-t.padInfo.left});\n      const float avgMultiplier = float(${1/(t.filterDepth*t.filterHeight*t.filterWidth)});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${p};\n            wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${f};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const iD={kernelName:l.AvgPool3DGrad,backendName:"webgl",kernelFunc:function aD(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,i=a,{filterSize:o,strides:u,pad:c,dimRoundingMode:d}=s,h=l.backend_util.computePool3DInfo(i.shape,o,u,[1,1,1],c,d),f=new rD(h);return e.runWebGLProgram(f,[r],i.dtype)}},lD={kernelName:l.AvgPoolGrad,backendName:"webgl",kernelFunc:function oD(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,i=a;ks([r,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:c}=s,d=l.backend_util.computePool2DInfo(i.shape,o,u,1,c),p=new sD(d);return e.runWebGLProgram(p,[r],i.dtype)}},cD={kernelName:l.BatchMatMul,backendName:"webgl",kernelFunc:function uD(n){const{inputs:t,backend:e,attrs:s}=n,{a:r,b:a}=t,{transposeA:i,transposeB:o}=s;return Mr({a:r,b:a,transposeA:i,transposeB:o,backend:e})}};class dD{constructor(t,e,s,r,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],l.backend_util.assertAndGetBroadcastShape(t,e),l.backend_util.assertAndGetBroadcastShape(t,s);let o="0.0";null!=r&&(l.backend_util.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="1.0";null!=a&&(l.backend_util.assertAndGetBroadcastShape(t,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${o};\n        float scale = ${u};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class pD{constructor(t,e,s,r,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],l.backend_util.assertAndGetBroadcastShape(t,e),l.backend_util.assertAndGetBroadcastShape(t,s);let o="vec4(0.0)";null!=r&&(l.backend_util.assertAndGetBroadcastShape(t,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let u="vec4(1.0)";null!=a&&(l.backend_util.assertAndGetBroadcastShape(t,a),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`\n      void main() {\n        vec4 offset = ${o};\n        vec4 scale = ${u};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const fD={kernelName:l.FusedBatchNorm,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s,mean:r,variance:a,offset:i,scale:o}=n;l.util.assert(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),l.util.assert(null==i||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),l.util.assert(null==o||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;null==u&&(u=.001);const c=[s,r,a];let d=null;null!=i&&(d=i.shape,c.push(i));let p=null;null!=o&&(p=o.shape,c.push(o));const h=(0,l.env)().getBool("WEBGL_PACK_NORMALIZATION")?new pD(s.shape,r.shape,a.shape,d,p,u):new dD(s.shape,r.shape,a.shape,d,p,u);return t.runWebGLProgram(h,c,c[0].dtype)}};class mD{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=xe(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=function gD(n){if(1===n)return"sourceLoc";if(n<=6)return to.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}(this.rank);let r;r=`\n        ${e} sourceLoc;\n        ${e} coords = getOutputCoords();\n        ${t.map((i,o)=>`sourceLoc.${to[o]} = start[${o}] + coords.${to[o]};`).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${r}\n        setOutput(getSource(${s}));\n      }\n    `}}const to=["x","y","z","w","u","v"];class yD{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=xe(this.rank),s=Qe("coords",this.rank),r=Qe("sourceLoc",this.rank),a=1===this.rank?"sourceLoc":`vec2(${r.slice(-2).join()})`,i=`getChannel(getSource(${r.join()}), ${a})`,o=`\n      result.x = ${i};\n      if (++${s[this.rank-1]} < ${t[this.rank-1]}) {\n        ++${r[this.rank-1]};\n        result.y = ${i};\n        --${r[this.rank-1]};\n      }\n    `,u=1===this.rank?"":`\n      --${s[this.rank-1]};\n      if (++${s[this.rank-2]} < ${t[this.rank-2]}) {\n        ++${r[this.rank-2]};\n        result.z = ${i};\n        if (++${s[this.rank-1]} < ${t[this.rank-1]}) {\n          ++${r[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,c=this.rank<=4?`sourceLoc = coords +\n            ${e}(${t.map((d,p)=>`start[${p}]`).join()});`:t.map((d,p)=>`${r[p]} = ${s[p]} + start[${p}];`).join("\n");this.userCode=`\n      void main() {\n        ${e} coords = getOutputCoords();\n        ${e} sourceLoc;\n        ${c}\n        vec4 result = vec4(0.);\n        ${o}\n        ${u}\n        setOutput(result);\n      }\n    `}}function rs(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,size:i}=s,[o,u]=l.slice_util.parseSliceParams(r,a,i);if(l.slice_util.assertParamsValid(r,o,u),0===l.util.sizeFromShape(u))return e.makeTensorInfo(u,r.dtype,[]);if(e.shouldExecuteOnCPU([r])||"string"===r.dtype){const p=e.texData.get(r.dataId),h=oA(p.values,o,u,r.shape,r.dtype);return e.makeTensorInfo(u,r.dtype,h)}const{isPacked:c}=e.texData.get(r.dataId),d=l.slice_util.isSliceContinous(r.shape,o,u);if(c||!d){const p=(0,l.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new yD(u):new mD(u);return e.runWebGLProgram(p,[r],r.dtype,[o])}return e.uploadToGPU(r.dataId),function xD(n,t,e,s){const r=s.texData.get(n.dataId),a=s.makeTensorInfo(e,n.dtype),i=s.texData.get(a.dataId);Object.assign(i,r),i.refCount=1,i.shape=e,i.dtype=n.dtype;let o=l.slice_util.computeFlatOffset(t,l.util.computeStrides(n.shape));r.slice&&(o+=r.slice.flatOffset),i.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||n.dataId};const u=s.dataRefCount.get(i.slice.origDataId)||1;return s.dataRefCount.set(i.slice.origDataId,u+1),a}(r,o,u,e)}const bD={kernelName:l.Slice,backendName:"webgl",kernelFunc:rs},vD={kernelName:l.BatchToSpaceND,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,crops:i}=s;l.util.assert(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,S)=>b*S),u=l.backend_util.getReshaped(r.shape,a,o),c=l.backend_util.getPermuted(u.length,a.length),d=l.backend_util.getReshapedPermuted(r.shape,a,o),p=l.backend_util.getSliceBeginCoords(i,a.length),h=l.backend_util.getSliceSize(d,i,a.length),f=[],m=K({inputs:{x:r},backend:e,attrs:{shape:u}}),y=Je({inputs:{x:m},backend:e,attrs:{perm:c}}),g=K({inputs:{x:y},backend:e,attrs:{shape:d}}),x=rs({inputs:{x:g},backend:e,attrs:{begin:p,size:h}});return f.push(m),f.push(y),f.push(g),f.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}},ID={kernelName:l.Bincount,backendName:"webgl",kernelFunc:function SD(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:i}=s,o=e.readSync(r.dataId),u=e.readSync(a.dataId),c=lp(o,u,a.dtype,a.shape,i);return e.makeTensorInfo([i],a.dtype,c)}},ND={kernelName:l.BroadcastArgs,backendName:"webgl",kernelFunc:function wD(n){const{inputs:t,backend:e}=n,{s0:s,s1:r}=t,a=e.readSync(s.dataId),i=e.readSync(r.dataId),o=l.backend_util.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return e.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},Ep=je({opSnippet:"return float(a != b);",cpuKernelImpl:QR,dtype:"bool"}),TD={kernelName:l.NotEqual,backendName:"webgl",kernelFunc:Ep};function Es(n){const{inputs:t,backend:e}=n,{input:s}=t;return at({inputs:{x:e.texData.get(s.dataId).complexTensorInfos.real},backend:e})}const kD={kernelName:l.Real,backendName:"webgl",kernelFunc:Es},DD={kernelName:l.Cast,backendName:"webgl",kernelFunc:function no(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return at({inputs:{x:r},backend:e});const i=l.zeros(r.shape),o=no({inputs:{x:r},backend:e,attrs:{dtype:"float32"}}),u=dn({inputs:{real:o,imag:i},backend:e});return i.dispose(),e.disposeIntermediateTensorInfo(o),u}if("complex64"===r.dtype){const i=Es({inputs:{input:r},backend:e}),o=no({inputs:{x:i},backend:e,attrs:{dtype:a}});return e.disposeIntermediateTensorInfo(i),o}if(!l.util.hasEncodingLoss(r.dtype,a)){const i=at({inputs:{x:r},backend:e});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(e.shouldExecuteOnCPU([r])){const i=e.texData.get(r.dataId).values,[o,u,c]=ER(i,r.shape,r.dtype,a);return e.makeTensorInfo(o,u,c)}if("int32"===a)return function AD(n,t){const e=new Vt(n.shape,"return float(int(x));"),s=t.runWebGLProgram(e,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(r,e);if("bool"===a){const i=e.makeTensorInfo([],"bool",l.util.getTypedArrayFromDType("bool",1)),u=Ep({inputs:{a:r,b:i},backend:e});return e.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}},_p="return ceil(x);",$D=pe({opSnippet:_p,packedOpSnippet:_p,cpuKernelImpl:_R}),ED={kernelName:l.Ceil,backendName:"webgl",kernelFunc:$D};class _D{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class FD{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const zD={kernelName:l.ClipByValue,backendName:"webgl",kernelFunc:function OD(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{clipValueMin:a,clipValueMax:i}=s;let o;return o=(0,l.env)().getBool("WEBGL_PACK_CLIP")?new FD(r.shape):new _D(r.shape),e.runWebGLProgram(o,[r],r.dtype,[[a],[i]])}};class LD{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function Fp(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}const VD={kernelName:l.ComplexAbs,backendName:"webgl",kernelFunc:function PD(n){const{inputs:t,backend:e}=n,{x:s}=t,r=e.texData.get(s.dataId),a=new LD(s.shape),i=[Fp(s,r.complexTensorInfos.real),Fp(s,r.complexTensorInfos.imag)];return e.runWebGLProgram(a,i,i[0].dtype)}};class BD{constructor(t){this.outputShape=[],this.outputShape=l.backend_util.computeOutShape(t,1),this.variableNames=t.map((i,o)=>`T${o}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let i=1;i<e.length;i++)e[i]=e[i-1]+t[i][1];const s=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<e.length;i++)s.push(`else if (yC < ${e[i]}) setOutput(getT${i}(yR, yC-${e[i-1]}));`);s.push(`else setOutput(getT${e.length}(yR, yC-${e[e.length-1]}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${s.join("\n        ")}\n      }\n    `}}class MD{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=l.backend_util.computeOutShape(t,e);const s=this.outputShape,r=s.length,a=xe(r),i=Qe("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=t.map((y,g)=>`T${g}`);const u=new Array(t.length-1);u[0]=t[0][e];for(let y=1;y<u.length;y++)u[y]=u[y-1]+t[y][e];const c=o[e],d=o.slice(-2),p=o.join();let h=`if (${c} < ${u[0]}) {\n        return getChannel(\n            getT0(${p}), vec2(${d.join()}));\n        }`;for(let y=1;y<u.length;y++){const g=u[y-1];h+=`\n        if (${c} < ${u[y]}  && ${c} >= ${u[y-1]}) {\n          return getChannel(\n            getT${y}(${Gr(o,c,g)}),\n            vec2(${Gr(d,c,g)}));\n        }`}const m=u[u.length-1];h+=`\n        return getChannel(\n          getT${u.length}(${Gr(o,c,m)}),\n          vec2(${Gr(d,c,m)}));`,this.userCode=`\n      float getValue(${o.map(y=>"int "+y)}) {\n        ${h}\n      }\n\n      void main() {\n        ${a} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[r-1]} = ${i[r-1]} + 1;\n        if (${i[r-1]} < ${s[r-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[r-2]} = ${i[r-2]} + 1;\n        if (${i[r-2]} < ${s[r-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[r-1]} = ${i[r-1]} - 1;\n        if (${i[r-2]} < ${s[r-2]} &&\n            ${i[r-1]} < ${s[r-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Gr(n,t,e){const s=n.indexOf(t);return n.map((a,i)=>i===s?`${a} - ${e}`:a).join()}function Ur(n){const{inputs:t,backend:e}=n,{input:s}=t;return at({inputs:{x:e.texData.get(s.dataId).complexTensorInfos.imag},backend:e})}const WD={kernelName:l.Imag,backendName:"webgl",kernelFunc:Ur};function _s(n,t,e){const s=n[0].dtype;if("complex64"===s){const f=n.map(b=>Es({inputs:{input:b},backend:e})),m=n.map(b=>Ur({inputs:{input:b},backend:e})),y=_s(f,t,e),g=_s(m,t,e),x=dn({inputs:{real:y,imag:g},backend:e});return f.forEach(b=>e.disposeIntermediateTensorInfo(b)),m.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),x}let r=e.shouldExecuteOnCPU(n);if("string"===s&&(r=!0),r){const f=n.map(v=>{const w=[-1,l.util.sizeFromShape(v.shape.slice(t))];return K({inputs:{x:v},backend:e,attrs:{shape:w}})}),m=f.map(v=>({vals:e.readSync(v.dataId),shape:v.shape})),y=l.backend_util.computeOutShape(f.map(v=>v.shape),1),x=FR(m,y,s,1===f[0].shape[0]),b=l.backend_util.computeOutShape(n.map(v=>v.shape),t),S=e.makeTensorInfo(b,s,x);return f.forEach(v=>e.disposeIntermediateTensorInfo(v)),S}const a=n.filter(f=>l.util.sizeFromShape(f.shape)>0),i=(0,l.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(1===a.length){const f=i?new Vt(n[0].shape,un):new cn(n[0].shape,un);return e.runWebGLProgram(f,n,s)}const o=(0,l.env)().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const f=[];for(let y=0;y<a.length;y+=o){const g=a.slice(y,y+o);f.push(_s(g,t,e))}const m=_s(f,t,e);for(const y of f)e.disposeIntermediateTensorInfo(y);return m}if(i){const f=new MD(a.map(m=>m.shape),t);return e.runWebGLProgram(f,a,s)}const{tensors2D:u,outShape:c}=function GD(n,t,e){const s=l.backend_util.computeOutShape(n.map(a=>a.shape),t);return{tensors2D:n.map(a=>K({inputs:{x:a},attrs:{shape:[-1,l.util.sizeFromShape(a.shape.slice(t))]},backend:e})),outShape:s}}(a,t,e),d=new BD(u.map(f=>f.shape)),p=e.runWebGLProgram(d,u,s);u.forEach(f=>e.disposeIntermediateTensorInfo(f));const h=K({inputs:{x:p},attrs:{shape:c},backend:e});return e.disposeIntermediateTensorInfo(p),h}function Op(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s,a=l.util.parseAxisParam(r,t[0].shape)[0],i=t.map(c=>c.shape);l.backend_util.assertParamsConsistent(i,a);const o=l.backend_util.computeOutShape(t.map(c=>c.shape),a);if(0===l.util.sizeFromShape(o))return e.makeTensorInfo(o,t[0].dtype,[]);const u=t.filter(c=>l.util.sizeFromShape(c.shape)>0);return 1===u.length?at({inputs:{x:u[0]},backend:e}):_s(u,a,e)}const UD={kernelName:l.Concat,backendName:"webgl",kernelFunc:Op};class zp{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,u=t.strideHeight,c=t.strideWidth,d=t.dilationHeight,p=t.dilationWidth,h=t.filterHeight,f=t.filterWidth,m=4*Math.floor(t.inChannels/4),y=t.inChannels%4,g="channelsLast"===t.dataFormat,x=g?1:2,b=g?2:3,S=g?3:1;let v="",I="";s&&(v=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`\n          float activation(float x) {\n            ${s}\n          }\n        `,I="result = activation(result);");const w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${v}\n\n      const ivec2 strides = ivec2(${u}, ${c});\n      const ivec2 pads = ivec2(${i}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${S}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${x}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${d};\n\n          if (xR < 0 || xR >= ${t.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${f}; wC++) {\n            int xC = xCCorner + wC * ${p};\n\n            if (xC < 0 || xC >= ${t.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${m}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===y}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${m}) *\n                    getW(wR, wC, ${m}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${m}, xR, xC) *\n                    getW(wR, wC, ${m}, d2);\n              }\n\n            } else if (${2===y}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${m}, d2),\n                getW(wR, wC, ${m} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${m}),\n                  getX(batch, xR, xC, ${m} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${m}, xR, xC),\n                  getX(batch, ${m} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===y}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${m}, d2),\n                getW(wR, wC, ${m} + 1, d2),\n                getW(wR, wC, ${m} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${m}),\n                  getX(batch, xR, xC, ${m} + 1),\n                  getX(batch, xR, xC, ${m} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${m}, xR, xC),\n                  getX(batch, ${m} + 1, xR, xC),\n                  getX(batch, ${m} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${I}\n        setOutput(result);\n      }\n    `}}class HD{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,s=t.padInfo.top,r=t.padInfo.left,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,u=t.dilationDepth,c=t.dilationHeight,d=t.dilationWidth,p=t.filterDepth,h=t.filterHeight,f=t.filterWidth,m=4*Math.floor(t.inChannels/4),y=t.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${a}, ${i}, ${o});\n      const ivec3 pads = ivec3(${e}, ${s}, ${r});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${p}; wF++) {\n          int xF = xFCorner + wF * ${u};\n\n          if (xF < 0 || xF >= ${t.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${c};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${f}; wC++) {\n              int xC = xCCorner + wC * ${d};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${m}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===y}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${m}) *\n                  getW(wF, wR, wC, ${m}, d2);\n              } else if (${2===y}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${m}),\n                  getX(batch, xF, xR, xC, ${m} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${m}, d2),\n                  getW(wF, wR, wC, ${m} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===y}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${m}),\n                  getX(batch, xF, xR, xC, ${m} + 1),\n                  getX(batch, xF, xR, xC, ${m} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${m}, d2),\n                  getW(wF, wR, wC, ${m} + 1, d2),\n                  getW(wF, wR, wC, ${m} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Lp{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Ze(this.outputShape.length);const i=t.padInfo.left,o=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,p=d;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<d;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${c}; r++) {\n      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {\n       `;for(let g=0;g<d;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(p+1)/2;g++){const x=2*g;if(h+=`\n           xC = xCCorner + ${x*u};\n           `,1===o){if(x<d&&(i%2==1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                   xTexelC${x} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${x}.zw = vec2(0.0);\n                   }\n                   xTexelC${x}Ready = 1;\n                 }\n               `,h+=1===u&&x>0?`\n                 xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${x} = vec4(previous.zw, xTexelC${x}.xy);\n                   } else {\n                     xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                   xTexelC${x} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${x}.zw = vec2(0.0);\n                   }\n                   xTexelC${x}Ready = 1;\n                 }\n\n                 xC${x} = xTexelC${x};\n                 `,x+1<d)){const b=i%2==0?l.util.nearestLargerEven(u):u;u%2==0&&i%2==1||u%2!=0&&i%2!=1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${b};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                     xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${x+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${x+1}Ready = 1;\n                   }\n                   `,h+=u>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);\n                     } else {\n                      xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);\n                     }\n                     `:`\n                     xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);\n                     `):h+=1===b?`\n                     xC${x+1} = xTexelC${x};\n                     `:`\n                     xCOffset = xC + ${b};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                       xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${x+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${x+1}Ready = 1;\n                     }\n\n                     xC${x+1} = xTexelC${x+1};\n                     `}}else x<d&&(i%2==1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {\n                   xTexelC${x} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${x}.zw = vec2(0.0);\n                   }\n                   xTexelC${x}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {\n                   xTexelC${x+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${x+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${x+1}Ready = 1;\n                 }\n\n                 xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);\n               `,x+1<d&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {\n                   xTexelC${x} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${x}.zw = vec2(0.0);\n                   }\n                   xTexelC${x}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {\n                   xTexelC${x+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${x+1}.zw = vec2(0.);\n                   }\n                   xTexelC${x+1}Ready = 1;\n                 }\n\n                 xC${x} = vec4(\n                   xTexelC${x}.xy, xTexelC${x+1}.xy);\n               `,x+1<d&&(h+=`\n                   xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);\n                 `)));x<d&&(h+=`\n             wTexel = getW(r, ${x}, d1, d2);\n             dotProd += xC${x}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${t.inChannels}) {\n               dotProd += xC${x}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,x+1<d&&(h+=`\n               wTexel = getW(r, ${x+1}, d1, d2);\n               dotProd += xC${x+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${t.inChannels}) {\n                 dotProd += xC${x+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let f="",m="";s&&(f=r?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${s}\n         }`:a?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${s}\n         }`:`vec4 activation(vec4 x) {\n           ${s}\n         }`,m="result = activation(result);");const y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${f}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${y}\n         ${m}\n         setOutput(result);\n       }\n     `}}class jD{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Ze(this.outputShape.length);const{dataFormat:s}=e,r=Ye(),a="channelsLast"===s,i=a?1:2,o=a?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let c="";for(let d=0;d<=1;d++)for(let p=0;p<=1;p++)c+=`\n          blockIndex = rc.z + ${p};\n          pos = rc.y + ${d};\n\n          ${u}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${o}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${a}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*d+p}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*d+p}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${c}\n\n        ${r.output} = result;\n      }\n    `}}function Hr(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&1===e&&n[0]>1?[n[0],1]:null}function Pp({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const u=n.shape,c=s.texData.get(n.dataId),d=e.inChannels,p=u[0]*u[1]*u[2],h=e.outChannels,f="channelsLast"===e.dataFormat;let g;const x=[];if(null!=a){const v=Hr(a.shape,f);null!=v&&(a=K({inputs:{x:a},backend:s,attrs:{shape:v}}),x.push(a))}if(null!=r){const v=Hr(r.shape,f);null!=v&&(r=K({inputs:{x:r},backend:s,attrs:{shape:v}}),x.push(r))}if((1!==p&&1!==h||!(d>Tp))&&c.isPacked&&f&&null!=c.texture&&u[2]%2!=0&&l.util.arraysEqual(c.shape.slice(-3),u.slice(-3))){const I={dataId:n.dataId,shape:[1,u[0]*u[1]*(u[2]+1),e.inChannels],dtype:n.dtype},w=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,l.util.assert(_r(c.shape,I.shape),()=>`packed reshape ${c.shape} to ${I.shape} isn't free`);const N=K({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}});x.push(N);const T=Mr({a:I,b:N,backend:s,transposeA:!1,transposeB:!1,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),D=s.texData.get(T.dataId);l.util.assert(D.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=w,D.shape=e.outShape,g=at({inputs:{x:T},backend:s}),g.shape=e.outShape,x.push(T)}else{const v=e.outHeight*e.outWidth,I=K({inputs:{x:n},backend:s,attrs:{shape:f?[e.batchSize,v,e.inChannels]:[e.batchSize,e.inChannels,v]}}),w=K({inputs:{x:t},backend:s,attrs:{shape:[1,e.inChannels,e.outChannels]}}),N=Mr({a:f?I:w,b:f?w:I,transposeA:!f,transposeB:!1,backend:s,bias:r,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=K({inputs:{x:N},backend:s,attrs:{shape:e.outShape}}),x.push(I),x.push(w),x.push(N)}for(const v of x)s.disposeIntermediateTensorInfo(v);return g}function Vp({x:n,filter:t,convInfo:e,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:u,filterHeight:c,inChannels:d,outWidth:p,outHeight:h,dataFormat:f}=e,m="channelsLast"===f,y=u*c*d,g=h*p,x=[e.batchSize,y,g],v=[];if(null!=a){const _=Hr(a.shape,m);null!=_&&(a=K({inputs:{x:a},backend:s,attrs:{shape:_}}),v.push(a))}if(null!=r){const _=Hr(r.shape,m);null!=_&&(r=K({inputs:{x:r},backend:s,attrs:{shape:_}}),v.push(r))}const I=K({inputs:{x:t},backend:s,attrs:{shape:[1,y,l.util.sizeFromShape(t.shape)/y]}});v.push(I);const w=new jD(x,e),T=s.runWebGLProgram(w,[n],"float32",[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]]),D=K({inputs:{x:T},backend:s,attrs:{shape:x}});v.push(T),v.push(D);const A=null!=r,$=null!=a,F="leakyrelu"===o,O=o?Ds(o,!0):null,L=new vp(m?D.shape:I.shape,m?I.shape:D.shape,m?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],!0,!1,A,O,$,F),z=m?[D,I]:[I,D];if(r&&z.push(r),$&&z.push(a),F){const _=s.makeTensorInfo([],"float32",l.util.createScalarValue(i,"float32"));z.push(_),v.push(_)}const P=s.runWebGLProgram(L,z,"float32"),B=K({inputs:{x:P},backend:s,attrs:{shape:e.outShape}});v.push(P);for(const _ of v)s.disposeIntermediateTensorInfo(_);return B}const KD={kernelName:l.Conv2D,backendName:"webgl",kernelFunc:function XD(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:c,dimRoundingMode:d}=s,p=l.backend_util.convertConv2DDataFormat(u),h=l.backend_util.computeConv2DInfo(r.shape,a.shape,i,c,o,d,!1,p);let f;if(1!==h.filterHeight||1!==h.filterWidth||1!==h.dilationHeight||1!==h.dilationWidth||1!==h.strideHeight||1!==h.strideWidth||"SAME"!==h.padInfo.type&&"VALID"!==h.padInfo.type)if(h.strideWidth<=2&&"channelsLast"===p&&(0,l.env)().getBool("WEBGL_EXP_CONV")){const y=new Lp(h);f=e.runWebGLProgram(y,[r,a],"float32",[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]])}else if((0,l.env)().getBool("WEBGL_CONV_IM2COL"))f=Vp({x:r,filter:a,convInfo:h,backend:e});else{const y=new zp(h);f=e.runWebGLProgram(y,[r,a],"float32")}else f=Pp({x:r,filter:a,convInfo:h,backend:e});const m=K({inputs:{x:f},backend:e,attrs:{shape:h.outShape}});return e.disposeIntermediateTensorInfo(f),m}};class qD{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              ${"channelsLast"===t.dataFormat?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class ZD{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,i="channelsLast"===t.dataFormat;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${i?3:1}];\n\n        ivec2 dyCorner = ivec2(coords[${i?1:2}], coords[${i?2:3}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class YD{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yF = 0; yF < ${t.outDepth}; yF++) {\n            int xF = wF + yF * ${t.strideDepth} - ${t.padInfo.front};\n\n            if (xF < 0 || xF >= ${t.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${t.outHeight}; yR++) {\n              int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n              if (xR < 0 || xR >= ${t.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${t.outWidth}; yC++) {\n                int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n                if (xC < 0 || xC >= ${t.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class QD{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,s=t.filterHeight,r=t.filterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${e-1-t.padInfo.front}, ${s-1-t.padInfo.top}, ${r-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${e}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${t.strideDepth}.0;\n\n          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${e} - 1 - wF;\n\n          for (int wR = 0; wR < ${s}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${s} - 1 - wR;\n\n            for (int wC = 0; wC < ${r}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${r} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const e$={kernelName:l.Conv2DBackpropFilter,backendName:"webgl",kernelFunc:function JD(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:c,filterShape:d}=s,p=l.backend_util.convertConv2DDataFormat(u),h=l.backend_util.computeConv2DInfo(r.shape,d,i,1,o,c,!1,p),f=new qD(h);return e.runWebGLProgram(f,[r,a],"float32")}};class t${constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Ze(this.outputShape.length);const e=t.filterHeight,s=t.filterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            int wCPerm = ${s} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const s$={kernelName:l.Conv2DBackpropInput,backendName:"webgl",kernelFunc:function n$(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:c,dimRoundingMode:d}=s,p=l.backend_util.convertConv2DDataFormat(c),h=l.backend_util.computeConv2DInfo(i,a.shape,o,1,u,d,!1,p);if((0,l.env)().getBool("WEBGL_PACK")&&"channelsLast"===p){const f=[[h.strideHeight,h.strideWidth]],m=new t$(h);return e.runWebGLProgram(m,[r,a],"float32",f)}{const f=new ZD(h);return e.runWebGLProgram(f,[r,a],"float32")}}},a$={kernelName:l.Conv3D,backendName:"webgl",kernelFunc:function r$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u}=s,c=l.backend_util.computeConv3DInfo(r.shape,a.shape,i,u,o),d=new HD(c);return e.runWebGLProgram(d,[r,a],"float32")}},o$={kernelName:l.Conv3DBackpropFilterV2,backendName:"webgl",kernelFunc:function i$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:i,pad:o,filterShape:u}=s,c=l.backend_util.computeConv3DInfo(r.shape,u,i,1,o),d=new YD(c);return e.runWebGLProgram(d,[r,a],"float32")}},u$={kernelName:l.Conv3DBackpropInputV2,backendName:"webgl",kernelFunc:function l$(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{pad:i,strides:o,inputShape:u}=s,c=l.backend_util.computeConv3DInfo(u,a.shape,o,1,i),d=new QD(c);return e.runWebGLProgram(d,[r,a],"float32")}},p$=pe({opSnippet:ss+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${_n}\n  return result;\n`}),h$={kernelName:l.Cos,backendName:"webgl",kernelFunc:p$},f$=pe({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),m$={kernelName:l.Cosh,backendName:"webgl",kernelFunc:f$};class g${constructor(t,e,s,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,u,c]=t,[d]=e,[p,h]=s;this.outputShape=[d,p,h,c];const f="bilinear"===r?1:0,[m,y]=[o-1+".0",u-1+".0"],[g,x,b]=p>1?[""+(o-1)/(p-1),"(y2-y1) * height_ratio",`y1*${m} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${m}`],[S,v,I]=h>1?[""+(u-1)/(h-1),"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${S});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${x};\n        float width_scale = ${v};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${m} ) {\n          setOutput(float(${a}));\n          return;\n        }\n        float in_x = ${I};\n        if( in_x < 0.0 || in_x > ${y} ) {\n          setOutput(float(${a}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${f} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const x$={kernelName:l.CropAndResize,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{image:r,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:c}=s,d=new g$(r.shape,a.shape,o,u,c);return e.runWebGLProgram(d,[r,a,i],"float32")}};var pn=(()=>((pn=pn||{}).Prod="*",pn.Sum="+",pn))();class Bp{constructor(t,e,s,r){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,o=s?this.op===pn.Prod?"1.0":"0.0":`getX(${Mp(a,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let c="",d="";s?(c=r?"end != "+(u-1):"end != 0",d=r?"end + 1":"end - 1"):(c=r?`end + pow2 < ${u}`:"end >= pow2",d=r?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${xe(a)} coords = getOutputCoords();\n        int end = ${Wp(a,"coords",this.op)};\n        float val = ${o};\n        int pow2 = int(pow(2.0, index));\n        if (${c}) {\n          int idx = ${d};\n          ${Wp(a,"coords",this.op)} = idx;\n          val ${this.op}= getX(${Mp(a,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function Mp(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.x, ${t}.y`;if(3===n)return`${t}.x, ${t}.y, ${t}.z`;if(4===n)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function Wp(n,t,e){if(1===n)return`${t}`;if(2===n)return`${t}.y`;if(3===n)return`${t}.z`;if(4===n)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function Gp(n,t,e,s,r,a){const i=t.shape.length,o=l.backend_util.getAxesPermutation([s],i);let u=t;null!=o&&(u=Je({inputs:{x:t},backend:e,attrs:{perm:o}}));const c=l.backend_util.getInnerMostAxes(1,i)[0];if(c!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const d=u.shape[c];let p=at({inputs:{x:u},backend:e});for(let h=0;h<=Math.ceil(Math.log2(d))-1;h++){const f=new Bp(n,u.shape,!1,a),y=p;p=e.runWebGLProgram(f,[p],p.dtype,[[h]]),e.disposeIntermediateTensorInfo(y)}if(r){const h=new Bp(n,u.shape,r,a),f=p;p=e.runWebGLProgram(h,[p],p.dtype),e.disposeIntermediateTensorInfo(f)}if(null!=o){const f=Je({inputs:{x:p},backend:e,attrs:{perm:l.backend_util.getUndoAxesPermutation(o)}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(u),f}return p}const C$={kernelName:l.Cumprod,backendName:"webgl",kernelFunc:function b$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:i,reverse:o}=s;return Gp(pn.Prod,r,e,a,i,o)}},S$={kernelName:l.Cumsum,backendName:"webgl",kernelFunc:function v$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,exclusive:i,reverse:o}=s;return Gp(pn.Sum,r,e,a,i,o)}},w$={kernelName:l.DenseBincount,backendName:"webgl",kernelFunc:function I$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,weights:a}=t,{size:i,binaryOutput:o}=s;if(1===r.shape.length){const u=e.readSync(r.dataId),c=e.readSync(a.dataId),d=lp(u,c,a.dtype,a.shape,i);return e.makeTensorInfo([i],a.dtype,d)}if(2===r.shape.length){const u=e.bufferSync(r),c=e.bufferSync(a),d=$R(u,c,i,o);return e.makeTensorInfo(d.shape,a.dtype,d.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class N${constructor(t,e,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=s,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${e};\n      int offset_h = imod(h, ${e});\n      int in_w = w / ${e};\n      int offset_w = imod(w, ${e});\n      int offset_d = (offset_h * ${e} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const k$={kernelName:l.DepthToSpace,backendName:"webgl",kernelFunc:function T$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockSize:a,dataFormat:i}=s,o=r.shape[0],p=("NHWC"===i?r.shape[1]:r.shape[2])*a,h=("NHWC"===i?r.shape[2]:r.shape[3])*a,f=("NHWC"===i?r.shape[3]:r.shape[1])/(a*a),y=new N$("NHWC"===i?[o,p,h,f]:[o,f,p,h],a,i);return e.runWebGLProgram(y,[r],r.dtype)}};class Up{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Ze(this.outputShape.length);const i=t.filterHeight,o=t.filterWidth,u=t.outChannels/t.inChannels;let c="",d="";s&&(c=r?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:a?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`\n          float activation(float x) {\n            ${s}\n          }\n        `,d="result = activation(result);");const p=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${c}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${u};\n        int q = d2 - d1 * ${u};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${o}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${p}\n        ${d}\n        setOutput(result);\n      }\n    `}}class Hp{constructor(t,e=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Ze(this.outputShape.length);const i=t.outChannels/t.inChannels,o=t.padInfo.left,u=t.strideWidth,c=t.dilationWidth,d=t.filterHeight,p=t.filterWidth,h=p;let f="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let x=0;x<p;x++)f+=`\n          vec4 xTexelC${2*x};\n          int xTexelC${2*x}Ready;\n          vec4 xTexelC${2*x+1};\n          int xTexelC${2*x+1}Ready;\n          vec4 xC${x};`;f+=`\n    for (int r = 0; r < ${d}; r++) {\n      `;for(let x=0;x<p;x++)f+=`\n          xTexelC${2*x} = vec4(0.0);\n          xTexelC${2*x}Ready = 0;\n          xTexelC${2*x+1} = vec4(0.0);\n          xTexelC${2*x+1}Ready = 0;\n          xC${x} = vec4(0.0);`;f+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let x=0;x<(h+1)/2;x++){const b=2*x;if(f+=`\n          xC = xCCorner + ${b*c};\n          `,1===u){if(b<p&&(o%2==1?(f+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n              `,f+=1===c&&b>0?`\n                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);\n                  } else {\n                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);\n                  }\n                  `):f+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xC${b} = xTexelC${b};\n                `,b+1<p)){const S=o%2==0?l.util.nearestLargerEven(c):c;c%2==0&&o%2==1||c%2!=0&&o%2!=1?(f+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${S};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${b+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${b+1}Ready = 1;\n                  }\n                  `,f+=c>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);\n                    } else {\n                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);\n                    }\n                    `:`\n                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);\n                    `):f+=1===S?`\n                    xC${b+1} = xTexelC${b};\n                    `:`\n                    xCOffset = xC + ${S};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${b+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${b+1}Ready = 1;\n                    }\n\n                    xC${b+1} = xTexelC${b+1};\n                    `}}else b<p&&(o%2==1?(f+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n              `,b+1<p&&(f+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);\n                `)):(f+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {\n                  xTexelC${b} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${b}.zw = vec2(0.0);\n                  }\n                  xTexelC${b}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {\n                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${b+1}.zw = vec2(0.);\n                  }\n                  xTexelC${b+1}Ready = 1;\n                }\n\n                xC${b} = vec4(\n                  xTexelC${b}.xy, xTexelC${b+1}.xy);\n              `,b+1<p&&(f+=`\n                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);\n                `)));b<p&&(f+=`\n            wTexel = getW(r, ${b}, d1, q);\n            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);\n          `,b+1<p&&(f+=`\n              wTexel = getW(r, ${b+1}, d1, q);\n              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}f+="\n    }\n  ",f+="\n      }\n    ";let m="",y="";s&&(m=r?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${s}\n        }`:a?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${s}\n        }`:`vec4 activation(vec4 x) {\n          ${s}\n        }`,y="result = activation(result);");const g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${m}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${f}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${y}\n        setOutput(result);\n      }\n    `}}const A$={kernelName:l.DepthwiseConv2dNative,backendName:"webgl",kernelFunc:function R$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u,dimRoundingMode:c}=s;let d=u;null==d&&(d=[1,1]),l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(i,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${d}'`);const p=l.backend_util.computeConv2DInfo(r.shape,a.shape,i,d,o,c,!0);let h;return h=(0,l.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&p.strideWidth<=2&&p.outChannels/p.inChannels==1?new Hp(p):new Up(p),e.runWebGLProgram(h,[r,a],"float32",[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]])}};class D${constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${t.outChannels/t.inChannels} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${t.batchSize}; b++) {\n          for (int yR = 0; yR < ${t.outHeight}; yR++) {\n            int xR = wR + yR * ${t.strideHeight} - ${t.padInfo.top};\n\n            if (xR < 0 || xR >= ${t.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${t.outWidth}; yC++) {\n              int xC = wC + yC * ${t.strideWidth} - ${t.padInfo.left};\n\n              if (xC < 0 || xC >= ${t.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class $${constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,s=t.filterWidth,u=t.outChannels/t.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${e-1-t.padInfo.top}, ${s-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${e}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${e} - 1 - wR;\n\n          for (int wC = 0; wC < ${s}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${s} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${u}; dm++) {\n              int d2 = d1 * ${u} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const _$={kernelName:l.DepthwiseConv2dNativeBackpropFilter,backendName:"webgl",kernelFunc:function E$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,filterShape:d}=s,p=l.backend_util.computeConv2DInfo(r.shape,d,i,o,u,c,!0),h=new D$(p);return e.runWebGLProgram(h,[r,a],"float32")}},O$={kernelName:l.DepthwiseConv2dNativeBackpropInput,backendName:"webgl",kernelFunc:function F$(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:c,inputShape:d}=s,p=l.backend_util.computeConv2DInfo(d,a.shape,i,o,u,c,!0),h=new $$(p);return e.runWebGLProgram(h,[r,a],"float32")}};class z${constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const P$={kernelName:l.Diag,backendName:"webgl",kernelFunc:function L$(n){const{inputs:t,backend:e}=n,{x:s}=t,r=[...s.shape,...s.shape],a=l.util.sizeFromShape(s.shape),i=K({inputs:{x:s},backend:e,attrs:{shape:[a]}}),o=new z$(a),u=e.runWebGLProgram(o,[i],i.dtype),c=K({inputs:{x:u},backend:e,attrs:{shape:r}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),c}};class V${constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:s,padInfo:r,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:u,dilationHeight:c,dilationWidth:d}=t,{top:p,left:h}=r;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${i});\n      const ivec2 pads = ivec2(${p}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${o}; h++) {\n          int hIn = hBeg + h * ${c};\n\n          if (hIn >= 0 && hIn < ${e}) {\n            for (int w = 0; w < ${u}; w++) {\n              int wIn = wBeg + w * ${d};\n\n              if (wIn >= 0 && wIn < ${s}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const M$={kernelName:l.Dilation2D,backendName:"webgl",kernelFunc:function B$(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a}=t,{strides:i,pad:o,dilations:u}=s,c=l.backend_util.computeDilation2DInfo(r.shape,a.shape,i,o,"NHWC",u);let d;const p=new V$(c);d=e.runWebGLProgram(p,[r,a],"float32");const h=K({inputs:{x:d},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(d),h}},G$={kernelName:l.Einsum,backendName:"webgl",kernelFunc:function W$(n){const{inputs:t,backend:e,attrs:s}=n,{equation:r}=s,a=t,{allDims:i,summedDims:o,idDims:u}=l.backend_util.decodeEinsumEquation(r,a.length);l.backend_util.checkEinsumDimSizes(i.length,u,a);const{path:c,steps:d}=l.backend_util.getEinsumComputePath(o,u),p=d.length;let h=null,f=i.length;const m=[];for(let y=0;y<p;++y){for(const g of d[y]){const{permutationIndices:x,expandDims:b}=l.backend_util.getEinsumPermutation(f,u[g]);let S;l.backend_util.isIdentityPermutation(x)?S=a[g]:(S=Je({inputs:{x:a[g]},backend:e,attrs:{perm:x}}),m.push(S));const v=S.shape.slice();for(let I=0;I<b.length;++I)v.splice(b[I],0,1);l.util.arraysEqual(S.shape,v)||(S=K({inputs:{x:S},backend:e,attrs:{shape:v}}),m.push(S)),null===h?h=S:(h=Ji({inputs:{a:S,b:h},backend:e}),m.push(h))}y<p-1&&(c[y]>=0&&(h=Br({inputs:{x:h},backend:e,attrs:{axis:c[y]-(i.length-f),keepDims:!1}}),m.push(h)),f--)}for(const y of m)y!==h&&e.disposeIntermediateTensorInfo(y);return h}},U$=pe({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),H$={kernelName:l.Elu,backendName:"webgl",kernelFunc:U$},q$={kernelName:l.EluGrad,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e}=n,{dy:s,y:r}=t,a=(0,l.env)().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new As("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new ns("return (b >= 0.0) ? a : a * (b + 1.0);",s.shape,r.shape);return e.runWebGLProgram(a,[s,r],s.dtype)}},Z$=je({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:OR}),Y$={kernelName:l.Equal,backendName:"webgl",kernelFunc:Z$},J$=pe({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${l.backend_util.ERF_P};\n  float a1 = ${l.backend_util.ERF_A1};\n  float a2 = ${l.backend_util.ERF_A2};\n  float a3 = ${l.backend_util.ERF_A3};\n  float a4 = ${l.backend_util.ERF_A4};\n  float a5 = ${l.backend_util.ERF_A5};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),eE={kernelName:l.Erf,backendName:"webgl",kernelFunc:J$},jp=pe({opSnippet:ss+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:zR,dtype:"float32"}),nE={kernelName:l.Exp,backendName:"webgl",kernelFunc:jp};function so(n){const{inputs:t,attrs:e,backend:s}=n,{dim:r}=e,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=r;return r<0&&(l.util.assert(-(i+1)<=r,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+r+1),o.splice(u,0,1),K({inputs:{x:a},backend:s,attrs:{shape:o}})}const sE={kernelName:l.ExpandDims,backendName:"webgl",kernelFunc:so},Xp="return exp(x) - 1.0;",rE=pe({opSnippet:Xp,packedOpSnippet:Xp,cpuKernelImpl:LR}),aE={kernelName:l.Expm1,backendName:"webgl",kernelFunc:rE};class Kp{constructor(t,e,s){this.variableNames=["real","imag"];const r=e[1];this.outputShape=e;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=s?`${r}.0`:"1.0";let o;if("real"===t)o="return real * expR - imag * expI;";else{if("imag"!==t)throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);o="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${a};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${o}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${r});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${r}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function qp(n,t,e){const s=e.texData.get(n.dataId),r=l.util.sizeFromShape(n.shape),a=n.shape[n.shape.length-1],o=K({inputs:{x:n},backend:e,attrs:{shape:[r/a,a]}}),u=o.shape,c=new Kp("real",u,t),d=new Kp("imag",u,t),p=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:u},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:u}],h=e.runWebGLProgram(c,p,"float32"),f=e.runWebGLProgram(d,p,"float32"),m=dn({inputs:{real:h,imag:f},backend:e});e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f);const y=K({inputs:{x:m},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(m),y}const oE={kernelName:l.FFT,backendName:"webgl",kernelFunc:function iE(n){const{inputs:t,backend:e}=n,{input:s}=t;return qp(s,!1,e)}};class lE{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function Fs(n){const{backend:t,attrs:e}=n,{shape:s,value:r}=e;let{dtype:a}=e;if(a=a||l.util.inferDtype(r),"string"===a){const i=l.util.getArrayFromDType(a,l.util.sizeFromShape(s));return i.fill(r),t.makeTensorInfo(s,a,i)}{const i=new lE(s,r);return t.runWebGLProgram(i,[],a,[[r]])}}const uE={kernelName:l.Fill,backendName:"webgl",kernelFunc:Fs};class cE{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${e} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${e}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const dE={kernelName:l.FlipLeftRight,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,s=t,r=new cE(e.shape);return s.runWebGLProgram(r,[e],e.dtype)}},Zp="return floor(x);",pE=pe({opSnippet:Zp,packedOpSnippet:Zp,cpuKernelImpl:PR}),hE={kernelName:l.Floor,backendName:"webgl",kernelFunc:pE},fE=je({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),mE={kernelName:l.FloorDiv,backendName:"webgl",kernelFunc:fE};class gE{constructor(t){this.variableNames=["A"];const e=Ye(),[s,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);\n\n        vec4 values = ${e.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class yE{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=Ye(),[s,r]=t;this.outputShape=t,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${r}.0, ${s}.0);\n            vec4 values = ${e.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${e.output} = result;\n      }\n    `}}const xE={kernelName:l.FromPixels,backendName:"webgl",kernelFunc:function bE(n){const{inputs:t,backend:e,attrs:s}=n;let{pixels:r}=t;const{numChannels:a}=s,i=typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement,[u,c]=i?[r.videoWidth,r.videoHeight]:[r.width,r.height],d=[c,u],p=[c,u,a];if(o||i){const y=(0,l.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(null==as||y!==ro)&&(ro=y,as=document.createElement("canvas").getContext("2d",{willReadFrequently:ro})),as.canvas.width=u,as.canvas.height=c,as.drawImage(r,0,0,u,c),r=as.canvas}const h=e.makeTensorInfo(d,"int32");e.texData.get(h.dataId).usage=ze.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(h.dataId),r);const f=(0,l.env)().getBool("WEBGL_PACK")?new yE(p):new gE(p),m=e.runWebGLProgram(f,[h],"int32");return e.disposeData(h.dataId),m}};let as,ro=(0,l.env)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const vE={kernelName:l.FusedConv2D,backendName:"webgl",kernelFunc:function CE(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dataFormat:d,dilations:p,dimRoundingMode:h,activation:f,leakyreluAlpha:m}=s,y=l.backend_util.convertConv2DDataFormat(d),g=l.backend_util.computeConv2DInfo(r.shape,a.shape,u,p,c,h,!1,y);let x;const b=[],S=null!=i,v=null!=o,I="leakyrelu"===f,w=()=>{const T=[r,a],D=(A,$)=>{if("NCHW"===$&&1===A.shape.length&&1!==A.shape[0]){const F=K({inputs:{x:A},backend:e,attrs:{shape:[A.shape[0],1,1]}});return b.push(F),F}return A};if(S&&T.push(D(i,d)),v&&T.push(D(o,d)),I){const A=e.makeTensorInfo([],"float32",l.util.createScalarValue(m,"float32"));T.push(A),b.push(A)}return T};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===y&&(0,l.env)().getBool("WEBGL_EXP_CONV")){const T=f?Ds(f,!0):null,D=new Lp(g,S,T,v,I),A=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=w();x=e.runWebGLProgram(D,$,"float32",A)}else if((0,l.env)().getBool("WEBGL_CONV_IM2COL"))x=Vp({x:r,filter:a,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:o,leakyreluAlpha:m});else{const T=f?Ds(f,!1):null,D=new zp(g,S,T,v,I),A=w();x=e.runWebGLProgram(D,A,"float32")}else x=Pp({x:r,filter:a,convInfo:g,backend:e,bias:i,activation:f,preluActivationWeights:o,leakyreluAlpha:m});const N=K({inputs:{x},backend:e,attrs:{shape:g.outShape}});return b.push(x),b.forEach(T=>e.disposeIntermediateTensorInfo(T)),N}},IE={kernelName:l.FusedDepthwiseConv2D,backendName:"webgl",kernelFunc:function SE(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:c,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s,m=[];let y=d;null==y&&(y=[1,1]),l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(u,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${y}'`);const g=l.backend_util.computeConv2DInfo(r.shape,a.shape,u,y,c,p,!0),x=(0,l.env)().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,b=h?Ds(h,x):null,S=[r,a],v=null!=i,I=null!=o,w="leakyrelu"===h;if(v&&S.push(i),I&&S.push(o),w){const A=e.makeTensorInfo([],"float32",l.util.createScalarValue(f,"float32"));S.push(A),m.push(A)}let N;N=x?new Hp(g,v,b,I,w):new Up(g,v,b,I,w);const D=e.runWebGLProgram(N,S,"float32",[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]]);return m.forEach(A=>e.disposeIntermediateTensorInfo(A)),D}};class wE{constructor(t,e,s,r){this.sliceDim=t,this.strides=e,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=s;const a=xe(s.length);let i="\n    int index;";for(let o=0;o<this.sliceDim;o++)i+=`\n          index = round(getIndices(coords[0], ${o}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};\n          flattenIndex += index * ${this.strides[o]};`;this.userCode=`\n         void main() {\n          ${a} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const TE={kernelName:l.GatherNd,backendName:"webgl",kernelFunc:function NE(n){const{inputs:t,backend:e}=n,{params:s,indices:r}=t,a=r.shape,i=a[a.length-1],o=l.util.sizeFromShape(s.shape),[u,c,d,p]=l.backend_util.prepareAndValidate(s,r),h=K({inputs:{x:r},backend:e,attrs:{shape:[c,i]}}),f=K({inputs:{x:s},backend:e,attrs:{shape:[l.util.sizeFromShape(s.shape)/d,d]}});if(e.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const x=e.readSync(r.dataId),b=e.bufferSync(s),S=VR(x,b,s.dtype,c,i,d,p,s.shape,o);return e.makeTensorInfo(u,s.dtype,S.values)}const m=new wE(i,p,[c,d],s.shape),y=e.runWebGLProgram(m,[f,h],f.dtype),g=K({inputs:{x:y},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(y),g}};class kE{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const s=xe(this.rank),r=function RE(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)s.push(2===r?"index":`${e[r]}`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${r}));\n      }\n    `}}function Yp(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,indices:a}=t,{axis:i,batchDims:o}=s,u=l.util.parseAxisParam(i,r.shape)[0];if((0,l.env)().get("DEBUG")){const b=e.readSync(a.dataId),S=r.shape[u];for(let v=0;v<b.length;++v){const I=b[v];l.util.assert(I<=S-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${S-1}]`)}}const c=l.backend_util.segment_util.collectGatherOpShapeInfo(r,a,u,o),d=l.util.sizeFromShape(a.shape),p=[],h=K({inputs:{x:r},backend:e,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),f=K({inputs:{x:a},backend:e,attrs:{shape:[c.batchSize,d/c.batchSize]}});p.push(h),p.push(f);const m=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize];if(e.shouldExecuteOnCPU([r,a])||"string"===r.dtype){const b=e.bufferSync(f),S=e.bufferSync(h),v=BR(S,b,m);return p.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.makeTensorInfo(c.outputShape,v.dtype,v.values)}const y=new kE(h.shape,m),g=e.runWebGLProgram(y,[h,f],h.dtype);p.push(g);const x=K({inputs:{x:g},backend:e,attrs:{shape:c.outputShape}});return p.forEach(b=>e.disposeIntermediateTensorInfo(b)),x}const AE={kernelName:l.GatherV2,backendName:"webgl",kernelFunc:Yp},DE=je({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:MR,dtype:"bool"}),$E={kernelName:l.Greater,backendName:"webgl",kernelFunc:DE},EE=je({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:WR}),_E={kernelName:l.GreaterEqual,backendName:"webgl",kernelFunc:EE},OE={kernelName:l.IFFT,backendName:"webgl",kernelFunc:function FE(n){const{inputs:t,backend:e}=n,{input:s}=t;return qp(s,!0,e)}},zE=pe({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),LE={kernelName:l.IsFinite,backendName:"webgl",kernelFunc:zE},PE=pe({opSnippet:"return float(isinf(x));",dtype:"bool"}),VE={kernelName:l.IsInf,backendName:"webgl",kernelFunc:PE},BE=pe({opSnippet:"return float(isnan(x));",dtype:"bool"}),ME={kernelName:l.IsNan,backendName:"webgl",kernelFunc:BE},WE=je({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:GR,dtype:"bool"}),GE={kernelName:l.Less,backendName:"webgl",kernelFunc:WE},UE=je({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:UR,dtype:"bool"}),HE={kernelName:l.LessEqual,backendName:"webgl",kernelFunc:UE},XE={kernelName:l.LinSpace,backendName:"webgl",kernelFunc:function jE(n){const{backend:t,attrs:e}=n,{start:s,stop:r,num:a}=e,i=HR(s,r,a);return t.makeTensorInfo([i.length],"float32",i)}},qE=pe({opSnippet:ss+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:jR}),ZE={kernelName:l.Log,backendName:"webgl",kernelFunc:qE},QE=pe({opSnippet:ss+"\n  return log(1.0 + x);\n"}),JE={kernelName:l.Log1p,backendName:"webgl",kernelFunc:QE},e_=je({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),t_={kernelName:l.LogicalAnd,backendName:"webgl",kernelFunc:e_},n_=pe({opSnippet:"return float(!(x >= 1.0));"}),s_={kernelName:l.LogicalNot,backendName:"webgl",kernelFunc:n_},r_=je({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),a_={kernelName:l.LogicalOr,backendName:"webgl",kernelFunc:r_};class i_{constructor(t,e,s,r,a){this.variableNames=["x"],this.outputShape=[];const i=e,o=t[3]-1;let u;this.outputShape=t;const c=`float(${s}) + float(${r}) * sum`;u=.5===a?`inversesqrt(${c})`:1===a?`1.0/(${c})`:`exp(log(${c}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${o}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${u};\n        setOutput(val);\n      }\n    `}}class o_{constructor(t,e,s,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=e,o=t[3]-1;let u;this.outputShape=t;const c=`float(${s}) + float(${r}) * sum`;u=.5===a?`inversesqrt(${c})`:1===a?`1.0/(${c})`:`exp(log(${c}) * float(-${a}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${u};\n        setOutput(result);\n      }\n    `}}const u_={kernelName:l.LRN,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=s,c=(0,l.env)().getBool("WEBGL_PACK_NORMALIZATION")?new o_(r.shape,a,i,o,u):new i_(r.shape,a,i,o,u);return e.runWebGLProgram(c,[r],r.dtype)}};class c_{constructor(t,e,s,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=s,this.alpha=r,this.beta=a,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${e})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${e} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${r}) * norm + float(${s});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${r})\n                * float(${a})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${a});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const p_={kernelName:l.LRNGrad,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:c,beta:d}=s,p=new c_(r.shape,o,u,c,d);return e.runWebGLProgram(p,[r,a,i],r.dtype)}};function Qp(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reductionIndices:a,keepDims:i}=s,o=r.shape.length,u=l.util.parseAxisParam(a,r.shape);let c=u;const d=l.backend_util.getAxesPermutation(c,o),p=null!=d,h=e.shouldExecuteOnCPU([r]);let f=r;if(p){if(h){const S=e.texData.get(f.dataId).values,v=new Array(o);for(let N=0;N<v.length;N++)v[N]=r.shape[d[N]];const I=Yi(S,r.shape,r.dtype,d,v);f=e.makeTensorInfo(v,r.dtype),e.texData.get(f.dataId).values=I}else f=Vr(r,d,e);c=l.backend_util.getInnerMostAxes(c.length,o)}l.backend_util.assertAxesAreInnerMostDims("max",c,o);const[m,y]=l.backend_util.computeOutAndReduceShapes(f.shape,c);let x,g=m;if(i&&(g=l.backend_util.expandShapeToKeepDim(m,u)),h){const S=e.texData.get(f.dataId).values,v=XR(S,l.util.sizeFromShape(y),g,r.dtype);x=e.makeTensorInfo(g,r.dtype),e.texData.get(x.dataId).values=v}else x=function h_(n,t,e,s){const r=l.util.sizeFromShape(t),o=K({inputs:{x:n},attrs:{shape:[l.util.sizeFromShape(n.shape)/r,r]},backend:s}),u=Fn(o,n.dtype,"max",s),c=K({inputs:{x:u},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),c}(f,y,g,e);return p&&e.disposeIntermediateTensorInfo(f),x}const f_={kernelName:l.Max,backendName:"webgl",kernelFunc:Qp},y_=je({opSnippet:Qi+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+_n+"\n  return result;\n",cpuKernelImpl:KR}),x_={kernelName:l.Maximum,backendName:"webgl",kernelFunc:y_},C_={kernelName:l.MaxPool,backendName:"webgl",kernelFunc:function b_(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;ks(r,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=s;l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(i,1),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '1'`);const d=l.backend_util.computePool2DInfo(r.shape,a,i,1,o,u);if(1===d.filterWidth&&1===d.filterHeight&&l.util.arraysEqual(d.inShape,d.outShape))return at({inputs:{x:r},backend:e});const p=new $s(d,"max",!1);return e.runWebGLProgram(p,[r],r.dtype)}},S_={kernelName:l.MaxPool3D,backendName:"webgl",kernelFunc:function v_(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:c}=s,p=l.backend_util.computePool3DInfo(r.shape,a,i,[1,1,1],o,c,u),h=new eo(p,"max",!1);return e.runWebGLProgram(h,[r],r.dtype)}};class I_{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const a=t.effectiveFilterHeight,i=t.effectiveFilterWidth;this.userCode=`\n      const ivec2 pads = ivec2(${a-1-t.padInfo.top}, ${i-1-t.padInfo.left});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${a};\n          wR += ${t.dilationHeight}) {\n          float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${a*i-1} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class w_{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth;this.userCode=`\n      const ivec3 pads = ivec3(${u-1-t.padInfo.front}, ${c-1-t.padInfo.top}, ${d-1-t.padInfo.left});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${u};\n           wD += ${t.dilationDepth}) {\n          float dyD = float(dyDCorner + wD) / ${t.strideDepth}.0;\n\n          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${c};\n              wR += ${t.dilationHeight}) {\n            float dyR = float(dyRCorner + wR) / ${t.strideHeight}.0;\n\n            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${t.dilationWidth}) {\n              float dyC = float(dyCCorner + wC) / ${t.strideWidth}.0;\n\n              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${u*c*d-1} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${c} * ${d} +\n                  wR * ${d} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const T_={kernelName:l.MaxPool3DGrad,backendName:"webgl",kernelFunc:function N_(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a}=t,i=a,{filterSize:o,strides:u,pad:c,dimRoundingMode:d}=s,h=l.backend_util.computePool3DInfo(i.shape,o,u,[1,1,1],c,d),f=new eo(h,"max",!0),m=e.runWebGLProgram(f,[i],i.dtype),y=new w_(h),g=e.runWebGLProgram(y,[r,m],i.dtype);return e.disposeIntermediateTensorInfo(m),g}},R_={kernelName:l.MaxPoolGrad,backendName:"webgl",kernelFunc:function k_(n){const{inputs:t,backend:e,attrs:s}=n,{dy:r,input:a,output:i}=t,o=a;ks([a,i],"maxPoolGrad");const{filterSize:u,strides:c,pad:d,dimRoundingMode:p}=s,h=l.backend_util.computePool2DInfo(o.shape,u,c,1,d,p),m=new $s(h,"max",!0),y=e.runWebGLProgram(m,[o],o.dtype),g=new I_(h),x=e.runWebGLProgram(g,[r,y],o.dtype);return e.disposeIntermediateTensorInfo(y),x}},D_={kernelName:l.MaxPoolWithArgmax,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{filterSize:r,strides:a,pad:i,includeBatchInIndex:o}=t,u=e;l.util.assert(4===s.shape.length,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];l.util.assert(l.backend_util.eitherStridesOrDilationsAreOne(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const d=l.backend_util.computePool2DInfo(s.shape,r,a,c,i),[p,h]=function A_(n,t,e,s){let r=new $s(e,"max",!1);const a=s.runWebGLProgram(r,[n],"float32");return r=new $s(e,"max",!0,!0,t),[a,s.runWebGLProgram(r,[n],"float32")]}(s,o,d,u);return[p,h]}},E_={kernelName:l.Mean,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:s}=n,{keepDims:r,axis:a}=t,i=e,o=s.shape.length,u=l.util.parseAxisParam(a,s.shape);let c=u;const d=l.backend_util.getAxesPermutation(c,o),p=null!=d,h=i.shouldExecuteOnCPU([s]),f=[];let m=s;if(p){if(h){const v=i.texData.get(m.dataId).values,I=new Array(o);for(let T=0;T<I.length;T++)I[T]=s.shape[d[T]];const w=Yi(v,s.shape,s.dtype,d,I);m=i.makeTensorInfo(I,s.dtype),i.texData.get(m.dataId).values=w}else m=Vr(s,d,i);f.push(m),c=l.backend_util.getInnerMostAxes(c.length,o)}l.backend_util.assertAxesAreInnerMostDims("sum",c,o);const[y,g]=l.backend_util.computeOutAndReduceShapes(m.shape,c);let x=y;r&&(x=l.backend_util.expandShapeToKeepDim(y,u));const b=function $_(n,t,e,s){const r=l.util.sizeFromShape(t),o=K({inputs:{x:n},attrs:{shape:[l.util.sizeFromShape(n.shape)/r,r]},backend:s}),u=Fn(o,"float32","mean",s),c=K({inputs:{x:u},attrs:{shape:e},backend:s});return s.disposeIntermediateTensorInfo(o),s.disposeIntermediateTensorInfo(u),c}(m,g,x,i);for(const S of f)i.disposeIntermediateTensorInfo(S);return b}},F_={kernelName:l.Min,backendName:"webgl",kernelFunc:function __(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=l.util.parseAxisParam(a,r.shape);let c=u;const d=l.backend_util.getAxesPermutation(c,o);let p=r;null!=d&&(p=Je({inputs:{x:r},backend:e,attrs:{perm:d}}),c=l.backend_util.getInnerMostAxes(c.length,r.shape.length)),l.backend_util.assertAxesAreInnerMostDims("min",c,o);const[h,f]=l.backend_util.computeOutAndReduceShapes(p.shape,c),y=K({inputs:{x:p},backend:e,attrs:{shape:[-1,l.util.sizeFromShape(f)]}}),g=Fn(y,y.dtype,"min",e);let x;return x=K(i?{inputs:{x:g},backend:e,attrs:{shape:l.backend_util.expandShapeToKeepDim(h,u)}}:{inputs:{x:g},backend:e,attrs:{shape:h}}),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(g),null!=d&&e.disposeIntermediateTensorInfo(p),x}},L_=je({opSnippet:Qi+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+_n+"\n  return result;\n",cpuKernelImpl:qR}),P_={kernelName:l.Minimum,backendName:"webgl",kernelFunc:L_};class V_{constructor(t,e,s){this.variableNames=["x"],this.outputShape=e.map((d,p)=>d[0]+t[p]+d[1]);const r=t.length,a=xe(r),i=e.map(d=>d[0]).join(","),o=e.map((d,p)=>d[0]+t[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c="reflect"===s?0:1;this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        for (int i = 0; i < ${r}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${c};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};\n          }\n        }\n        ${a} coords = outC - start;\n        setOutput(getX(${u}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${c};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${c};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class B_{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((m,y)=>m[0]+t[y]+m[1]);const r=t.length,a=xe(r),i=e.map(m=>m[0]).join(","),o=e.map((m,y)=>m[0]+t[y]).join(","),u=Qe("rc",r),c=Qe("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${c.slice(-2).join()})`,h="reflect"===s?0:1;let f="";if(1===r){const m=`\n        ${a} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;f=`\n        ${a} rc = outputLoc;\n        ${m}\n        result[0] = getChannel(getX(${c.join()}), ${p});\n        ${u[r-1]} += 1;\n        if(${d}) {\n          ${m}\n          result[1] = getChannel(getX(${c.join()}), ${p});\n        }\n      `}else{const m=`\n        ${a} source = rc;\n        ${a} lt = ${a}(lessThan(source, start));\n        ${a} gte = ${a}(greaterThanEqual(source, end));\n        ${a} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;f=`\n        ${a} rc = outputLoc;\n        ${m}\n        result[0] = getChannel(getX(${c.join()}), ${p});\n        ${u[r-1]} += 1;\n        if(${d}) {\n          ${m}\n          result[1] = getChannel(getX(${c.join()}), ${p});\n        }\n        rc = outputLoc;\n        ${u[r-2]} += 1;\n        if(${u[r-2]} < ${this.outputShape[r-2]}) {\n          ${m}\n          result[2] = getChannel(getX(${c.join()}), ${p});\n          ${u[r-1]} += 1;\n          if(${d}) {\n            ${m}\n            result[3] = getChannel(getX(${c.join()}), ${p});\n          }\n        }\n      `}this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${f}\n        setOutput(result);\n      }\n    `}}const W_={kernelName:l.MirrorPad,backendName:"webgl",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:s}=n,{paddings:r,mode:a}=e,i=(0,l.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new B_(s.shape,r,a):new V_(s.shape,r,a);return t.runWebGLProgram(i,[s],s.dtype)}},H_=je({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+_n+"\n  return result;\n"}),j_={kernelName:l.Mod,backendName:"webgl",kernelFunc:H_};class X_{constructor(t,e,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,s],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${e-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${e-1}));\n      }\n    `}}const Jp=je({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),K_={kernelName:l.RealDiv,backendName:"webgl",kernelFunc:Jp},eh="return a - b;",th=je({opSnippet:eh,packedOpSnippet:eh,supportsComplex:!0,cpuKernelImpl:gA}),q_={kernelName:l.Sub,backendName:"webgl",kernelFunc:th};function nh(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{dim:a}=s,i=l.util.parseAxisParam([a],r.shape),o=Qp({inputs:{x:r},backend:e,attrs:{reductionIndices:i,keepDims:!1}}),u=l.backend_util.expandShapeToKeepDim(o.shape,i),c=K({inputs:{x:o},backend:e,attrs:{shape:u}}),d=th({inputs:{a:r,b:c},backend:e}),p=jp({inputs:{x:d},backend:e}),h=Br({inputs:{x:p},backend:e,attrs:{axis:i,keepDims:!1}}),f=K({inputs:{x:h},backend:e,attrs:{shape:u}}),m=Jp({inputs:{a:p,b:f},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(f),m}const Z_={kernelName:l.Softmax,backendName:"webgl",kernelFunc:nh},Q_={kernelName:l.Multinomial,backendName:"webgl",kernelFunc:function Y_(n){const{inputs:t,backend:e,attrs:s}=n,{logits:r}=t,{numSamples:a,seed:i,normalized:o}=s,u=o?r:nh({inputs:{logits:r},backend:e,attrs:{dim:r.shape.length-1}}),p=new X_(u.shape[0],u.shape[1],a),f=e.runWebGLProgram(p,[u],"int32",[[i]]);return o||e.disposeIntermediateTensorInfo(u),f}},J_=ct+"\n  return -x;\n",nF={kernelName:l.Neg,backendName:"webgl",kernelFunc:function tF(n){const{inputs:t,backend:e}=n,{x:s}=t;if(e.shouldExecuteOnCPU([s])){const a=e.texData.get(s.dataId),[i,o]=YR(a.values,s.shape,s.dtype);return e.makeTensorInfo(o,s.dtype,i)}let r;return r=(0,l.env)().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new cn(s.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new Vt(s.shape,J_),e.runWebGLProgram(r,[s],s.dtype)}},sF=l.kernel_impls.nonMaxSuppressionV3Impl,aF={kernelName:l.NonMaxSuppressionV3,backendName:"webgl",kernelFunc:function rF(n){l.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=s,c=e.readSync(r.dataId),d=e.readSync(a.dataId),{selectedIndices:p}=sF(c,d,i,o,u);return e.makeTensorInfo([p.length],"int32",new Int32Array(p))}},iF=l.kernel_impls.nonMaxSuppressionV4Impl,lF={kernelName:l.NonMaxSuppressionV4,backendName:"webgl",kernelFunc:function oF(n){l.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,padToMaxOutputSize:c}=s,d=e.readSync(r.dataId),p=e.readSync(a.dataId),{selectedIndices:h,validOutputs:f}=iF(d,p,i,o,u,c);return[e.makeTensorInfo([h.length],"int32",new Int32Array(h)),e.makeTensorInfo([],"int32",new Int32Array([f]))]}},uF=l.kernel_impls.nonMaxSuppressionV5Impl,dF={kernelName:l.NonMaxSuppressionV5,backendName:"webgl",kernelFunc:function cF(n){l.backend_util.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:s}=n,{boxes:r,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:c}=s,d=e.readSync(r.dataId),p=e.readSync(a.dataId),h=i,f=o,m=u,y=c,{selectedIndices:g,selectedScores:x}=uF(d,p,h,f,m,y);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class pF{constructor(t,e,s,r){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${r}), float(${s}),\n                      float(index == coords.y)));\n      }\n    `}}const fF={kernelName:l.OneHot,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{indices:r}=t,{dtype:a,depth:i,onValue:o,offValue:u}=s,c=l.util.sizeFromShape(r.shape),d=new pF(c,i,o,u),p=K({inputs:{x:r},backend:e,attrs:{shape:[c]}}),h=e.runWebGLProgram(d,[p],a);e.disposeIntermediateTensorInfo(p);const m=K({inputs:{x:h},backend:e,attrs:{shape:[...r.shape,i]}});return e.disposeIntermediateTensorInfo(h),m}};function jr(n){const{inputs:t,backend:e}=n,{x:s}=t;if("complex64"===s.dtype){const r=Es({inputs:{input:s},backend:e}),a=jr({inputs:{x:r},backend:e}),i=Ur({inputs:{input:s},backend:e}),o=jr({inputs:{x:i},backend:e}),u=dn({inputs:{real:a,imag:o},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),u}return Fs({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:e})}const mF={kernelName:l.ZerosLike,backendName:"webgl",kernelFunc:jr},gF={kernelName:l.OnesLike,backendName:"webgl",kernelFunc:function sh(n){const{inputs:t,backend:e}=n,{x:s}=t;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const r=Es({inputs:{input:s},backend:e}),a=sh({inputs:{x:r},backend:e}),i=Ur({inputs:{input:s},backend:e}),o=jr({inputs:{x:i},backend:e}),u=dn({inputs:{real:a,imag:o},backend:e});return e.disposeIntermediateTensorInfo(r),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(o),u}return Fs({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:e})}},xF={kernelName:l.Pack,backendName:"webgl",kernelFunc:function yF(n){const{inputs:t,backend:e,attrs:s}=n,{axis:r}=s;if(1===t.length)return so({inputs:{input:t[0]},backend:e,attrs:{dim:r}});const a=t[0].shape,i=t[0].dtype;t.forEach(d=>{l.util.assertShapesMatch(a,d.shape,"All tensors passed to stack must have matching shapes"),l.util.assert(i===d.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=Op({inputs:t.map(d=>{const p=so({inputs:{input:d},backend:e,attrs:{dim:r}});return o.push(p),p}),backend:e,attrs:{axis:r}});return o.forEach(d=>e.disposeIntermediateTensorInfo(d)),c}};class bF{constructor(t,e,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((c,d)=>c[0]+t[d]+c[1]);const r=t.length,a=xe(r),i=e.map(c=>c[0]).join(","),o=e.map((c,d)=>c[0]+t[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=1!==r?`\n      ${a} start = ${a}(${i});\n      ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${a} coords = outC - start;\n          setOutput(getX(${u}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${o};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class CF{constructor(t,e,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((y,g)=>y[0]+t[g]+y[1]);const r=t.length,a=xe(r),i=e.map(y=>y[0]).join(","),o=e.map((y,g)=>y[0]+t[g]).join(","),u=Qe("rc",r),c=Qe("source",r),d=`${u[r-1]} < ${this.outputShape[r-1]}`,p=1===r?"source":`vec2(${c.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${u[r-1]} += 1;\n       if(${d}) {\n      `,1===r?"":`}\n       rc = outputLoc;\n       ${u[r-2]} += 1;\n       if(${u[r-2]} < ${this.outputShape[r-2]}) {`,1===r?"":`  ${u[r-1]} += 1;\n         if(${d}) {`],f=1===r?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let m="";for(let y=0,g=1===r?2:4;y<g;y++)m+=`\n        ${h[y]}\n        if (${f}) {\n          result[${y}] = float(value);\n        } else {\n          ${a} source = rc - start;\n          result[${y}] = getChannel(getX(${c.join()}), ${p});\n        }\n      `;m+=1===r?"} ":"}}",this.userCode=`\n      const ${a} start = ${a}(${i});\n      const ${a} end = ${a}(${o});\n\n      void main() {\n        ${a} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${m}\n        setOutput(result);\n      }\n    `}}const rh=n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{paddings:a,constantValue:i}=s;if(0===l.util.sizeFromShape(r.shape))return Fs({backend:e,attrs:{shape:a.map((d,p)=>d[0]+r.shape[p]+d[1]),value:i,dtype:r.dtype}});const o=(0,l.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CF(r.shape,a,i):new bF(r.shape,a,i);return e.runWebGLProgram(o,[r],r.dtype,[[i]])},vF={kernelName:l.PadV2,backendName:"webgl",kernelFunc:rh},wF=je({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+_n+"\n  return result;\n"}),NF={kernelName:l.Pow,backendName:"webgl",kernelFunc:wF},kF={kernelName:l.Prod,backendName:"webgl",kernelFunc:function TF(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{axis:a,keepDims:i}=s,o=r.shape.length,u=[],c=l.util.parseAxisParam(a,r.shape);let d=c;const p=l.backend_util.getAxesPermutation(d,o);let f,h=r;if(null!=p&&(h=Je({inputs:{x:r},backend:e,attrs:{perm:p}}),d=l.backend_util.getInnerMostAxes(d.length,o),u.push(h)),l.backend_util.assertAxesAreInnerMostDims("prod",d,o),e.shouldExecuteOnCPU([h])){const m=e.texData.get(h.dataId).values,{outVals:y,outShape:g,outDtype:x}=JR(h.shape,h.dtype,m,d);f=e.makeTensorInfo(g,x,y)}else{const[m,y]=l.backend_util.computeOutAndReduceShapes(h.shape,d),g=l.util.sizeFromShape(y),x=K({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}}),S=Fn(x,(0,l.sumOutType)(r.dtype),"prod",e);f=K({inputs:{x:S},backend:e,attrs:{shape:m}}),u.push(x),u.push(S)}if(i){u.push(f);const m=l.backend_util.expandShapeToKeepDim(f.shape,c);f=K({inputs:{x:f},backend:e,attrs:{shape:m}})}return u.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}},AF={kernelName:l.RaggedGather,backendName:"webgl",kernelFunc:function RF(n){const{inputs:t,backend:e,attrs:s}=n,{paramsNestedSplits:r,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=s,u=r.map(x=>e.readSync(x.dataId)),c=r.map(x=>x.shape),d=e.readSync(a.dataId),p=e.readSync(i.dataId),[h,f,m]=eA(u,c,d,a.shape,a.dtype,p,i.shape,o),y=h.map(x=>e.makeTensorInfo([x.length],"int32",x)),g=e.makeTensorInfo(m,a.dtype,f);return y.concat([g])}},$F={kernelName:l.RaggedRange,backendName:"webgl",kernelFunc:function DF(n){const{inputs:t,backend:e}=n,{starts:s,limits:r,deltas:a}=t,i=e.readSync(s.dataId),o=e.readSync(r.dataId),u=e.readSync(a.dataId),[c,d]=tA(i,s.shape,s.dtype,o,r.shape,u,a.shape);return[e.makeTensorInfo([c.length],"int32",c),e.makeTensorInfo([d.length],s.dtype,d)]}},_F={kernelName:l.RaggedTensorToTensor,backendName:"webgl",kernelFunc:function EF(n){const{inputs:t,backend:e,attrs:s}=n,{shape:r,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:u}=s,c=e.readSync(r.dataId),d=e.readSync(a.dataId),p=e.readSync(i.dataId),h=o.map(g=>e.readSync(g.dataId)),f=o.map(g=>g.shape),[m,y]=nA(c,r.shape,d,a.shape,a.dtype,p,i.shape,h,f,u);return e.makeTensorInfo(m,a.dtype,y)}},ah=n=>{const{backend:t,attrs:e}=n,{start:s,stop:r,step:a,dtype:i}=e,o=sA(s,r,a,i);return t.makeTensorInfo([o.length],i,o)},FF={kernelName:l.Range,backendName:"webgl",kernelFunc:ah},OF=pe({opSnippet:"return 1.0 / x;"}),zF={kernelName:l.Reciprocal,backendName:"webgl",kernelFunc:OF},PF=pe({opSnippet:ct+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),VF={kernelName:l.Relu,backendName:"webgl",kernelFunc:PF},MF=pe({opSnippet:ct+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),WF={kernelName:l.Relu6,backendName:"webgl",kernelFunc:MF};class GF{constructor(t,e,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,e,s,c];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let h;h=a?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class UF{constructor(t,e,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,e,s,c];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let h;h=a?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]},\n          ${d[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${s-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const jF={kernelName:l.ResizeBilinear,backendName:"webgl",kernelFunc:function HF(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s,[u,c]=o,d=(0,l.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new UF(r.shape,u,c,a,i):new GF(r.shape,u,c,a,i);return e.runWebGLProgram(d,[r],"float32")}};class XF{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,i,o]=t,u=[s&&i>1?r-1:r,s&&o>1?a-1:a],c=[s&&i>1?i-1:i,s&&o>1?o-1:o],d=u[0]/c[0],p=u[1]/c[1],h=1/d,f=1/p,m=2*Math.ceil(h)+2,y=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${m});\n        const int winWidth = int(${y});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const qF={kernelName:l.ResizeBilinearGrad,backendName:"webgl",kernelFunc:function KF(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:i}=s,o=new XF(a.shape,r.shape,i);return e.runWebGLProgram(o,[a],a.dtype)}};class ZF{constructor(t,e,s,r,a){this.variableNames=["A"],this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,e,s,c];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let f;f=a?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]});\n      const vec2 inputShapeRC = vec2(${o}.0, ${u}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class YF{constructor(t,e,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,u,c]=t;this.outputShape=[i,e,s,c];const d=[r&&e>1?o-1:o,r&&s>1?u-1:u],p=[r&&e>1?e-1:e,r&&s>1?s-1:s];let f;f=a?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${d[0]/p[0]},\n          ${d[1]/p[1]},\n          ${d[1]/p[1]});\n      const vec3 inputShapeRC = vec3(${o}.0, ${u}.0,\n                                     ${u}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${f};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${r?"0.5":"0.0"})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${c-1};\n        bool hasNextRow = coords.z < ${s-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const JF={kernelName:l.ResizeNearestNeighbor,backendName:"webgl",kernelFunc:function QF(n){const{inputs:t,backend:e,attrs:s}=n,{images:r}=t,{alignCorners:a,halfPixelCenters:i,size:o}=s,[u,c]=o,d=(0,l.env)().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new YF(r.shape,u,c,a,i):new ZF(r.shape,u,c,a,i);return e.runWebGLProgram(d,[r],r.dtype)}};class eO{constructor(t,e,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,r,a]=e,[,i,o]=t,u=[s&&i>1?r-1:r,s&&o>1?a-1:a],c=[s&&i>1?i-1:i,s&&o>1?o-1:o],d=u[0]/c[0],p=u[1]/c[1],h=1/d,f=1/p,m=2*Math.ceil(h)+2,y=2*Math.ceil(f)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${d});\n        const float widthScale = float(${p});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${f});\n\n        const int winHeight = int(${m});\n        const int winWidth = int(${y});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${o}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${u[0]}) *\n                (float(dyR) / float(${c[0]}));\n\n            float sourceFracCol =\n                float(${u[1]}) *\n                  (float(dyC) / float(${c[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${r}) - 1),\n                ${s} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${a}) - 1),\n                ${s} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const nO={kernelName:l.ResizeNearestNeighborGrad,backendName:"webgl",kernelFunc:function tO(n){const{inputs:t,backend:e,attrs:s}=n,{images:r,dy:a}=t,{alignCorners:i}=s,o=new eO(a.shape,r.shape,i);return e.runWebGLProgram(o,[a],a.dtype)}};class sO{constructor(t,e){this.variableNames=["x"];const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=t,1===s)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${t[0]} - coord - 1));\n        }\n      `);const a=t.map((o,u)=>(o=>-1!==e.indexOf(o)&&1!==t[o]?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`)(u)).join(","),i=xe(s);this.userCode=`\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}class rO{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=t.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=t;const r=Qe("rc",s),a=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,i=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,o=xe(s);function h(m){const y=t.map((b,S)=>function f(m,y){return-1!==e.indexOf(m)&&1!==t[m]?`${t[m]} - ${y[m]} - 1`:`${y[m]}`}(S,m));return`getChannel(getX(${y.join(",")}), vec2(${y.slice(-2).join(",")}))`}this.userCode=1===s?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${t[0]} - rc - 1),\n            ${t[0]} - rc - 1);\n          if(${a}){\n              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),\n                ${t[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${o} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function u(m){return h(m)}(r.slice())};\n          if(${a}){\n            result.g = ${function c(m){return m[s-1]="("+m[s-1]+" + 1)",h(m)}(r.slice())};\n          }\n          if(${i}) {\n            result.b = ${function d(m){return m[s-2]="("+m[s-2]+" + 1)",h(m)}(r.slice())};\n            if(${a}) {\n              result.a = ${function p(m){return m[s-1]="("+m[s-1]+" + 1)",m[s-2]="("+m[s-2]+" + 1)",h(m)}(r.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const iO={kernelName:l.Reverse,backendName:"webgl",kernelFunc:function aO(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{dims:a}=s,i=r.shape.length,o=l.util.parseAxisParam(a,r.shape);if(0===i)return at({inputs:{x:r},backend:e});const u=(0,l.env)().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rO(r.shape,o):new sO(r.shape,o);return e.runWebGLProgram(u,[r],r.dtype)}};class oO{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=t[1],r=t[2];this.outputShape=t;let a="";a="number"==typeof e?`float outputValue = ${e.toFixed(2)};`:`\n        vec3 fill = vec3(${e.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${a}\n          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const lO={kernelName:l.RotateWithOffset,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:s}=n,{radians:r,fillValue:a,center:i}=t,o=e,u=new oO(s.shape,a),[c,d]=l.backend_util.getImageCenter(i,s.shape[1],s.shape[2]),p=[[c,d,Math.sin(r),Math.cos(r)]];return o.runWebGLProgram(u,[s],s.dtype,p)}},uO=pe({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),cO={kernelName:l.Round,backendName:"webgl",kernelFunc:uO},dO=pe({opSnippet:"return inversesqrt(x);",cpuKernelImpl:rA}),pO={kernelName:l.Rsqrt,backendName:"webgl",kernelFunc:dO};class ao{constructor(t,e,s,r,a,i,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const c=xe(a.length),d=xe(i.length);let p="";1===s?p="i":2===s&&(p="i, j");let f="";1===r?f="i":2===r&&(f="i, coords[1]");let y="";u&&(y="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${a});\n\n        void main() {\n          ${d} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${t}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${e}; j++) {\n              int index = round(getIndices(${p}));\n              flattenedIndex += index * ${e>1?"strides[j]":"strides"};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += getUpdates(${f});\n              found = true;\n            }\n          }\n          setOutput(mix(getDefaultValue(${y}), sum, float(found)));\n        }\n      `}}class hO{constructor(t,e,s,r,a,i,o=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const c=xe(a.length),d=xe(i.length);let p="";1===s?p="i":2===s&&(p="i, j");let f="";1===r?f="i":2===r&&(f="i, coords[1]");let y="";u&&(y="coords[0], coords[1]"),this.userCode=`\n        ${c} strides = ${c}(${a});\n\n        void main() {\n          ${d} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${t}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${e}; j+=2) {\n              ivec4 index = round(getIndices(${p}));\n              flattenedIndex += index.xz * ${e>1?"strides[j]":"strides"};\n              if (j + 1 < ${e}) {\n                flattenedIndex += index.yw * ${e>1?"strides[j + 1]":"strides"};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = getUpdates(${f});\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(getDefaultValue(${y}), sum, found));\n        }\n      `}}const mO={kernelName:l.ScatterNd,backendName:"webgl",kernelFunc:function fO(n){const{inputs:t,backend:e,attrs:s}=n,{indices:r,updates:a}=t,{shape:i}=s,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=l.backend_util.calculateShapes(a,r,i),h=[p/c,c];if(0===p)return e.makeTensorInfo(i,r.dtype);const f=K({inputs:{x:r},backend:e,attrs:{shape:[u,o]}}),m=K({inputs:{x:a},backend:e,attrs:{shape:[u,c]}}),y=e.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=(0,l.env)().getBool("WEBGL_PACK")?new hO(u,o,f.shape.length,m.shape.length,d,h):new ao(u,o,f.shape.length,m.shape.length,d,h);const x=e.runWebGLProgram(g,[m,f,y],m.dtype),b=K({inputs:{x},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(x),e.disposeIntermediateTensorInfo(y),b}};class gO{constructor(t,e,s,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,s];const i=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,o=2===(0,l.env)().getNumber("WEBGL_VERSION")?"while (left < right) {":i;this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${o}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${"left"===r?"<":"<="} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const xO={kernelName:l.SearchSorted,backendName:"webgl",kernelFunc:function yO(n){const{inputs:t,backend:e,attrs:s}=n,{sortedSequence:r,values:a}=t,{side:i}=s,o=new gO(r.shape[0],r.shape[1],a.shape[1],i);return e.runWebGLProgram(o,[r,a],"int32",[[r.shape[1]]])}};class bO{constructor(t,e,s){let r,a;if(this.variableNames=["c","a","b"],this.outputShape=e,s>4)throw Error(`Where for rank ${s} is not yet supported`);if(1===s)a="resRC",r="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],c=[];for(let d=0;d<e.length;d++)c.push(`${o[d]}`),d<t&&u.push(`${o[d]}`);r=u.join(),a=c.join()}const i=xe(s);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${r});\n        if (cVal >= 1.0) {\n          setOutput(getA(${a}));\n        } else {\n          setOutput(getB(${a}));\n        }\n      }\n    `}}const vO={kernelName:l.Select,backendName:"webgl",kernelFunc:function CO(n){const{inputs:t,backend:e}=n,{condition:s,t:r,e:a}=t,i=new bO(s.shape.length,r.shape,r.shape.length);return e.runWebGLProgram(i,[s,r,a],(0,l.upcastType)(r.dtype,a.dtype))}},IO=pe({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${l.backend_util.SELU_SCALEALPHA};\n  float scale = ${l.backend_util.SELU_SCALE};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),wO={kernelName:l.Selu,backendName:"webgl",kernelFunc:IO},TO=pe({opSnippet:ss+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:iA}),kO={kernelName:l.Sigmoid,backendName:"webgl",kernelFunc:TO},RO=pe({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),AO={kernelName:l.Sign,backendName:"webgl",kernelFunc:RO},EO=pe({opSnippet:ss+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${_n}\n  return result;\n`}),_O={kernelName:l.Sin,backendName:"webgl",kernelFunc:EO},FO=pe({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),OO={kernelName:l.Sinh,backendName:"webgl",kernelFunc:FO},zO=pe({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),LO={kernelName:l.Softplus,backendName:"webgl",kernelFunc:zO},VO={kernelName:l.SpaceToBatchND,backendName:"webgl",kernelFunc:n=>{const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{blockShape:a,paddings:i}=s;l.util.assert(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((x,b)=>x*b),u=[[0,0]];u.push(...i);for(let x=1+a.length;x<r.shape.length;++x)u.push([0,0]);const c=[],d=rh({inputs:{x:r},backend:e,attrs:{paddings:u,constantValue:0}}),p=l.backend_util.getReshaped(d.shape,a,o,!1),h=l.backend_util.getPermuted(p.length,a.length,!1),f=l.backend_util.getReshapedPermuted(d.shape,a,o,!1),m=K({inputs:{x:d},backend:e,attrs:{shape:p}}),y=Je({inputs:{x:m},backend:e,attrs:{perm:h}}),g=K({inputs:{x:y},backend:e,attrs:{shape:f}});return c.push(d),c.push(m),c.push(y),c.forEach(x=>e.disposeIntermediateTensorInfo(x)),g}},MO={kernelName:l.SparseFillEmptyRows,backendName:"webgl",kernelFunc:function BO(n){const{inputs:t,backend:e}=n,{indices:s,values:r,denseShape:a,defaultValue:i}=t;if(1!==a.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${a.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==i.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${i.shape}`);const o=e.readSync(s.dataId),u=e.readSync(r.dataId),c=e.readSync(a.dataId),d=e.readSync(i.dataId)[0],[p,h,f,m,y]=lA(o,s.shape,s.dtype,u,r.dtype,c,d);return[e.makeTensorInfo(h,s.dtype,p),e.makeTensorInfo([h[0]],r.dtype,f),e.makeTensorInfo([m.length],"bool",new Uint8Array(m.map(g=>Number(g)))),e.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}},GO={kernelName:l.SparseReshape,backendName:"webgl",kernelFunc:function WO(n){const{inputs:t,backend:e}=n,{inputIndices:s,inputShape:r,newShape:a}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==a.shape.length)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(e.readSync(r.dataId)),o=e.readSync(s.dataId),u=Array.from(e.readSync(a.dataId)),[c,d,p]=uA(o,s.shape,s.dtype,i,u);return[e.makeTensorInfo(d,s.dtype,c),e.makeTensorInfo([p.length],a.dtype,new Int32Array(p))]}},HO={kernelName:l.SparseSegmentMean,backendName:"webgl",kernelFunc:function UO(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${a.shape}`);const i=e.readSync(s.dataId),o=e.readSync(r.dataId),u=e.readSync(a.dataId),[c,d]=cp(i,s.shape,s.dtype,o,u,!0);return e.makeTensorInfo(d,s.dtype,c)}},XO={kernelName:l.SparseSegmentSum,backendName:"webgl",kernelFunc:function jO(n){const{inputs:t,backend:e}=n,{data:s,indices:r,segmentIds:a}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==a.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${a.shape}`);const i=e.readSync(s.dataId),o=e.readSync(r.dataId),u=e.readSync(a.dataId),[c,d]=cp(i,s.shape,s.dtype,o,u);return e.makeTensorInfo(d,s.dtype,c)}},qO={kernelName:l.SparseToDense,backendName:"webgl",kernelFunc:function KO(n){const{inputs:t,backend:e,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:i}=t,{outputShape:o}=s,{sliceRank:u,numUpdates:c,sliceSize:d,strides:p,outputSize:h}=l.backend_util.calculateShapes(a,r,o);if("string"===a.dtype){const x=e.bufferSync(r),b=e.bufferSync(a),S=l.util.decodeString(e.readSync(i.dataId)[0]),v=aA(x,b,o,h,d,c,u,p,S,!1);return e.makeTensorInfo(o,v.dtype,v.values)}const m=new ao(c,u,r.shape.length,a.shape.length,p,[h,1],!1),y=e.runWebGLProgram(m,[a,r,i],a.dtype),g=K({inputs:{x:y},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(y),g}},YO={kernelName:l.SplitV,backendName:"webgl",kernelFunc:function ZO(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{numOrSizeSplits:a,axis:i}=s,o=l.util.parseAxisParam(i,r.shape)[0],u=l.backend_util.prepareSplitSize(r,a,o),d=new Array(r.shape.length).fill(0),p=r.shape.slice();return u.map(h=>{const f=[...p];f[o]=h;const m=rs({inputs:{x:r},backend:e,attrs:{begin:d,size:f}});return d[o]+=h,m})}},ih="return sqrt(x);",QO=pe({opSnippet:ih,packedOpSnippet:ih,cpuKernelImpl:cA}),JO={kernelName:l.Sqrt,backendName:"webgl",kernelFunc:QO},ez=pe({opSnippet:"return x * x;"}),tz={kernelName:l.Square,backendName:"webgl",kernelFunc:ez},oh="return (a - b) * (a - b);",nz=je({opSnippet:oh,packedOpSnippet:oh}),sz={kernelName:l.SquaredDifference,backendName:"webgl",kernelFunc:nz},az={kernelName:l.StaticRegexReplace,backendName:"webgl",kernelFunc:function rz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const a=e.readSync(r.dataId),i=l.backend_util.fromUint8ToStringArray(a),o=dA(i,"string",s);return e.makeTensorInfo(r.shape,"string",o)}},oz={kernelName:l.Step,backendName:"webgl",kernelFunc:function iz({inputs:n,attrs:t,backend:e}){const{x:s}=n,a=new Vt(s.shape,ct+`\n    return x > 0.0 ? 1.0 : float(${t.alpha});\n  `);return e.runWebGLProgram(a,[s],s.dtype)}};class lz{constructor(t,e,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,a=xe(s.length),i=xe(s.length);let o="";if(1===r)o="coords * strides + begin";else{let u=0;o=s.map((c,d)=>(u++,1===s.length?`coords * strides[${d}] + begin[${d}]`:`coords[${u-1}] * strides[${d}] + begin[${d}]`)).join(",")}this.userCode=`\n      ${a} begin = ${a}(${t});\n      ${a} strides = ${a}(${e});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${o}));\n      }\n    `}}const cz={kernelName:l.StridedSlice,backendName:"webgl",kernelFunc:function uz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:c,ellipsisMask:d,newAxisMask:p,shrinkAxisMask:h}=s,{finalShapeSparse:f,finalShape:m,isIdentity:y,sliceDim0:g,isSimpleSlice:x,begin:b,end:S,strides:v}=l.slice_util.sliceInfo(r.shape,a,i,o,u,c,d,p,h);let I;if(y)I=K({inputs:{x:r},backend:e,attrs:{shape:m}});else if(g||x){l.util.assert(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const N=l.slice_util.computeOutShape(b,S,v),T=rs({inputs:{x:r},backend:e,attrs:{begin:b,size:N}});I=K({inputs:{x:T},backend:e,attrs:{shape:m}}),e.disposeIntermediateTensorInfo(T)}else if(e.shouldExecuteOnCPU([r])){const T=e.readSync(r.dataId),D=(0,l.buffer)(r.shape,r.dtype,T),A=pA(f,D,v,b);I=e.makeTensorInfo(m,r.dtype,A.values)}else{const T=new lz(b,v,f);I=e.runWebGLProgram(T,[r],r.dtype)}const w=K({inputs:{x:I},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(I),w}},pz={kernelName:l.StringNGrams,backendName:"webgl",kernelFunc:function dz(n){const{inputs:t,backend:e,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:c}=s,{data:d,dataSplits:p}=t,h=e.readSync(d.dataId),f=e.readSync(p.dataId),[m,y]=hA(h,f,r,a,i,o,u,c);return[e.makeTensorInfo([m.length],"string",m),e.makeTensorInfo(p.shape,"int32",y)]}},fz={kernelName:l.StringSplit,backendName:"webgl",kernelFunc:function hz(n){const{inputs:t,backend:e,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:i}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(1!==a.shape.length)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(0!==i.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=e.readSync(a.dataId),u=e.readSync(i.dataId)[0],[c,d,p]=fA(o,u,r),h=d.length;return[e.makeTensorInfo([h,2],"int32",c),e.makeTensorInfo([h],"string",d),e.makeTensorInfo([2],"int32",new Int32Array(p))]}},gz={kernelName:l.StringToHashBucketFast,backendName:"webgl",kernelFunc:function mz(n){const{inputs:t,backend:e,attrs:s}=n,{numBuckets:r}=s,{input:a}=t;if("string"!==a.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const i=e.readSync(a.dataId),o=mA(i,r);return e.makeTensorInfo(a.shape,"int32",o)}},yz=pe({opSnippet:"return tan(x);"}),xz={kernelName:l.Tan,backendName:"webgl",kernelFunc:yz},bz=pe({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),Cz={kernelName:l.Tanh,backendName:"webgl",kernelFunc:bz},Sz={kernelName:l.TensorScatterUpdate,backendName:"webgl",kernelFunc:function vz(n){const{inputs:t,backend:e}=n,{tensor:r,indices:a,updates:i}=t,{sliceRank:o,numUpdates:u,sliceSize:c,strides:d,outputSize:p}=l.backend_util.calculateShapes(i,a,r.shape),h=[p/c,c];if(0===p)return e.makeTensorInfo(r.shape,a.dtype);const f=K({inputs:{x:a},backend:e,attrs:{shape:[u,o]}}),m=K({inputs:{x:i},backend:e,attrs:{shape:[u,c]}}),y=K({inputs:{x:r},backend:e,attrs:{shape:h}}),g=new ao(u,o,f.shape.length,m.shape.length,d,h,!1,!0),x=e.runWebGLProgram(g,[m,f,y],y.dtype),b=K({inputs:{x},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(x),b}};class Iz{constructor(t,e){this.variableNames=["A"];const s=new Array(t.length);for(let i=0;i<s.length;i++)s[i]=t[i]*e[i];this.outputShape=s,this.rank=s.length;const r=xe(this.rank),a=function wz(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${e[r]}, ${n[r]})`);return s.join()}(t);this.userCode=`\n      void main() {\n        ${r} resRC = getOutputCoords();\n        setOutput(getA(${a}));\n      }\n    `}}function lh(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{reps:a}=s;if("string"===r.dtype||r.shape.length>5){const u=e.readSync(r.dataId),c="string"===r.dtype?u.map(h=>l.util.decodeString(h)):u,d=(0,l.buffer)(r.shape,r.dtype,c),p=yA(d,a);return e.makeTensorInfo(p.shape,p.dtype,p.values)}const i=new Iz(r.shape,a);return e.runWebGLProgram(i,[r],r.dtype)}const Nz={kernelName:l.Tile,backendName:"webgl",kernelFunc:lh};class Tz{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class kz{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function On(n,t){null!==t&&n.disposeIntermediateTensorInfo(t)}function uh(n){let t=1;for(;t<n;)t*=2;return t}const Az={kernelName:l.TopK,backendName:"webgl",kernelFunc:function Rz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r}=t,{k:a,sorted:i}=s,o=(0,l.env)().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=(0,l.env)().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,d=c[c.length-1];if(e.shouldExecuteOnCPU([r])||d<o||a>u){const A=e.readSync(r.dataId),[$,F]=xA(A,c,r.dtype,a,i);return[e.makeTensorInfo($.shape,$.dtype,$.values),e.makeTensorInfo(F.shape,F.dtype,F.values)]}if(0===a)return c[c.length-1]=0,[e.makeTensorInfo(c,r.dtype,[]),e.makeTensorInfo(c,"int32",[])];if(1===d)return[r,Fs({attrs:{shape:c,dtype:"int32",value:0},backend:e})];const p=e.texData.get(r.dataId),h=null!==p&&p.isPacked,f=h?e.unpackTensor(r):r,y=l.util.sizeFromShape(c)/d,g=K({inputs:{x:f},attrs:{shape:[y,d]},backend:e});h&&On(e,f);const x=uh(a),b=uh(d);let S=null;const v=()=>null===S?[g,g]:[g,S],I=(A,$,F)=>{const O=v(),L=new Tz(F),B=S;S=e.runWebGLProgram(L,O,"int32",[[d],[null===S?1:0],[Number.NEGATIVE_INFINITY],[A],[$]]),On(e,B)};for(let A=1;A<x;A*=2){const $=2*A;for(let F=A;F>=1;F/=2)I($,F,[y,b])}for(let A=b;A>x;A/=2){const $=v(),F=new kz([y,A/2]),z=S;S=e.runWebGLProgram(F,$,"int32",[[d],[null===S?1:0],[x]]),On(e,z);const P=x/2,B=2*P;for(let _=P;_>=1;_/=2)I(B,_,S.shape)}let w=S;S=rs({inputs:{x:S},backend:e,attrs:{begin:0,size:[y,a]}}),On(e,w);let N=Yp({inputs:{x:g,indices:S},backend:e,attrs:{axis:1,batchDims:1}});On(e,g);const T=c.slice(0,-1);T.push(a),w=S,S=K({inputs:{x:S},attrs:{shape:T},backend:e}),On(e,w);const D=N;return N=K({inputs:{x:N},attrs:{shape:T},backend:e}),On(e,D),[N,S]}};class Dz{constructor(t,e,s,r,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o="nearest"===s?1:2;let u;switch(r){case"constant":default:u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${u} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${u} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${a});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${a});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${e}));\n                float mapY = mapCoord(inY, float(${t}));\n\n                if (${o} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const Ez={kernelName:l.Transform,backendName:"webgl",kernelFunc:function $z(n){const{inputs:t,backend:e,attrs:s}=n,{image:r,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:c}=s,[d,p,h,f]=r.shape,[m,y]=c??[p,h],x=new Dz(p,h,i,o,u,[d,m,y,f]);return e.runWebGLProgram(x,[r,a],"float32")}},Fz={kernelName:l.Unique,backendName:"webgl",kernelFunc:function _z(n){const{inputs:t,attrs:e,backend:s}=n,{axis:r}=e,{x:a}=t;ks(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=s.readSync(a.dataId),{outputValues:o,outputShape:u,indices:c}=bA(i,r,a.shape,a.dtype);return[s.makeTensorInfo(u,a.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}},zz={kernelName:l.Unpack,backendName:"webgl",kernelFunc:function Oz(n){const{inputs:t,backend:e,attrs:s}=n,{value:r}=t;let{axis:a}=s;a<0&&(a+=r.shape.length);const i=r,o=i.shape.length,u=r.shape[a],c=new Array(o-1);let d=0;for(let y=0;y<o;y++)y!==a&&(c[d++]=i.shape[y]);const p=[],h=new Array(o).fill(0),f=i.shape.slice();f[a]=1;const m=new Array(u);for(let y=0;y<m.length;y++){h[a]=y;const g=rs({inputs:{x:i},backend:e,attrs:{begin:h,size:f}}),x=K({inputs:{x:g},backend:e,attrs:{shape:c}});m[y]=x,p.push(g)}return p.forEach(y=>e.disposeIntermediateTensorInfo(y)),m}};class Lz{constructor(t,e){this.variableNames=["x","segmentIds"];const s=t.windowSize,r=t.batchSize,a=t.inSize,i=t.numSegments,o=i*Math.ceil(a/s);this.outputShape=[r,o];const d=4*Math.floor(s/4),p=s%4,h="\n        sumValue += dot(values, segFilter);\n    ";let f="";a%s>0&&(f=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return initializationValue;\n        }\n      `);let m="";a%s>0&&(m=`\n        if (inIdx < 0 || inIdx >= ${a}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${f}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${m}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${s}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${d}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${d};\n        if (${1===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${h}\n        } else if (${2===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${h}\n        } else if (${3===p}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${h}\n        }\n        setOutput(sumValue);\n      }\n    `}}const Bz=[h2,m2,x2,v2,I2,T2,R2,D2,F2,z2,V2,W2,H2,q2,Q2,eD,nD,iD,lD,cD,fD,vD,ID,ND,DD,ED,zD,ZA,VD,UD,KD,e$,s$,a$,o$,u$,h$,m$,x$,C$,S$,w$,k$,A$,_$,O$,P$,M$,G$,H$,q$,Y$,eE,nE,sE,aE,oE,uE,dE,hE,mE,xE,vE,IE,TE,AE,$E,_E,qA,OE,WD,LE,VE,ME,QA,GE,HE,XE,ZE,JE,t_,s_,a_,u_,p_,f_,x_,C_,S_,T_,R_,D_,E_,F_,P_,W_,j_,Q_,t2,nF,aF,lF,dF,TD,fF,gF,xF,vF,NF,e2,kF,AF,$F,_F,FF,kD,K_,zF,VF,WF,s2,jF,qF,JF,nO,iO,lO,cO,pO,mO,xO,vO,wO,kO,AO,_O,OO,bD,Z_,LO,VO,MO,GO,HO,XO,qO,YO,JO,tz,sz,az,oz,cz,pz,fz,gz,q_,c2,xz,Cz,Sz,Nz,Az,Ez,d2,Fz,zz,{kernelName:l.UnsortedSegmentSum,backendName:"webgl",kernelFunc:function Pz(n){const{inputs:t,backend:e,attrs:s}=n,{x:r,segmentIds:a}=t,{numSegments:i}=s,o=r.shape.length,u=[];let c=0;const d=l.backend_util.getAxesPermutation([c],o);let p=r;null!=d&&(p=Je({inputs:{x:r},backend:e,attrs:{perm:d}}),u.push(p),c=l.backend_util.getInnerMostAxes(1,o)[0]);const h=l.backend_util.segment_util.computeOutShape(p.shape,c,i),f=l.util.sizeFromShape([p.shape[c]]),m=K({inputs:{x:p},backend:e,attrs:{shape:[-1,f]}});u.push(m);const y=(0,l.sumOutType)(r.dtype),g=(v,I,w,N,T)=>{const D=v.shape[0],A=v.shape[1],$=l.backend_util.segment_util.segOpComputeOptimalWindowSize(A,T),O=new Lz({windowSize:$,inSize:A,batchSize:D,numSegments:T},I),L=e.compileAndRun(O,[v,w],N);if(u.push(L),L.shape[1]===T)return L;const z=ah({backend:e,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),P=lh({inputs:{x:z},backend:e,attrs:{reps:[A/$]}});return u.push(z),u.push(P),g(L,I,P,N,T)},b=K({inputs:{x:g(m,"unsortedSegmentSum",a,y,i)},backend:e,attrs:{shape:h}});let S=b;if(null!=d){u.push(b);const v=l.backend_util.getUndoAxesPermutation(d);S=Je({inputs:{x:S},backend:e,attrs:{perm:v}})}return u.forEach(v=>e.disposeIntermediateTensorInfo(v)),S}},mF];for(const n of Bz)(0,l.registerKernel)(n)},9434:()=>{},7792:()=>{},4977:()=>{}}]);